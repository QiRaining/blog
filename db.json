{"Asset":[{"source":"source/favicon.ico","mtime":1378965763000,"_id":"t1sq5se4ge3hxk5b"},{"source":"themes/bootstrap/source/search.html","mtime":1378965763000,"_id":"rilbsv2yzwd8f03k"},{"source":"themes/bootstrap/source/css/bootstrap-responsive.css","mtime":1378965763000,"_id":"tepbobybc2x834jd"},{"source":"themes/bootstrap/source/css/bootstrap-responsive.min.css","mtime":1378965763000,"_id":"x0odyd5gzxwq7i8d"},{"source":"themes/bootstrap/source/css/bootstrap.css","mtime":1378965763000,"_id":"w4043umlp3vkoaht"},{"source":"themes/bootstrap/source/css/bootstrap.min.css","mtime":1378965763000,"_id":"iuh10r49hf5qi1jr"},{"source":"themes/bootstrap/source/css/hexobootstrapcss.css","mtime":1378965763000,"_id":"qnvxfq03u9ou3kew"},{"source":"themes/bootstrap/source/css/hf.css","mtime":1378965763000,"_id":"uz4rbpanqnaq3u39"},{"source":"themes/bootstrap/source/css/tab.css","mtime":1378965763000,"_id":"0yffufsongizmfoq"},{"source":"themes/bootstrap/source/css/xcode.css","mtime":1378965763000,"_id":"27z9hbozw1pst8xj"},{"source":"themes/bootstrap/source/js/bootstrap.js","mtime":1378965763000,"_id":"3qmrpjj4akokb0pb"},{"source":"themes/bootstrap/source/js/bootstrap.min.js","mtime":1378965763000,"_id":"449eatmow15uicge"},{"source":"themes/bootstrap/source/js/gotop.js","mtime":1378965763000,"_id":"eagvqpwiqdopkkzl"},{"source":"themes/bootstrap/source/js/jquery-1.8.3.min.js","mtime":1378965763000,"_id":"tfqira9kcznzbtrs"},{"source":"themes/bootstrap/source/js/jquery-tapir.js","mtime":1378965763000,"_id":"qp4c04n1hedv7rg2"},{"source":"themes/bootstrap/source/js/jquery.easing.min.js","mtime":1378965763000,"_id":"yjzlzfvworwl7p5d"},{"source":"themes/bootstrap/source/js/jquery.imagesloaded.min.js","mtime":1378965763000,"_id":"ecsegczv6eddlt7a"},{"source":"themes/bootstrap/source/js/jquery.js","mtime":1378965763000,"_id":"zvnbhb8t9mw74i6b"},{"source":"themes/bootstrap/source/js/jquery.menuindex.js","mtime":1378965763000,"_id":"jugpnv3z8a4nlrvh"},{"source":"themes/bootstrap/source/js/jquery.pagination.js","mtime":1378965763000,"_id":"ajg380u30ljdbp7u"},{"source":"themes/bootstrap/source/js/jquery.scrollUp.js","mtime":1378965763000,"_id":"21z3y7m8drlond7q"},{"source":"themes/bootstrap/source/js/jquery.scrollUp.min.js","mtime":1378965763000,"_id":"w65pivn11y0qw1q9"},{"source":"themes/bootstrap/source/img/glyphicons-halflings-white.png","mtime":1378965763000,"_id":"ls483f3lmh4aiyw0"},{"source":"themes/bootstrap/source/img/glyphicons-halflings.png","mtime":1378965763000,"_id":"myvract0zlwp11n0"},{"source":"themes/bootstrap/source/img/hufeng825.jpg","mtime":1378965763000,"_id":"85x0pa45vu8s3exh"},{"source":"themes/bootstrap/source/img/loading.gif","mtime":1378965763000,"_id":"cn7807k7uz3y3jbe"},{"source":"themes/bootstrap/source/img/patterns/mooning.png","mtime":1378965763000,"_id":"oap3krq9aacjdoot"},{"source":"themes/bootstrap/source/img/patterns/white_wall_hash.png","mtime":1378965763000,"_id":"7kvdzluirps8n3cg"},{"source":"themes/bootstrap/source/Jianli.htm","mtime":1378965763000,"_id":"njymynvxcublurm0"}],"Cache":[{"content":"title: How to get the color of a pixel in an UIView?\ndate: 2013-09-03 16:33:35\ntags: [技术]\ncategories: ios\n---\n记得一年前做招行掌上生活M+的时候 其中有个需求是画一画功能，就是在地图上用手指画个圈 然后得到这个圈里面所有指定商户。\n当时为了精度 除了利用 \n\n```\nBOOL mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView.path, NULL, polygonViewPoint, NO);\n```\n来验证此点是否在画的区域内 同时为了精度 还用到了点位的颜色色值进行校验。\n\n无法把全部代码给出 下面把 如何得到uiview 某点的函数给出\n\n UIView+ColorOfPoint.h\n\n```\n@interface UIView (ColorOfPoint)\n- (UIColor *) colorOfPoint:(CGPoint)point;\n@end\n```\n\n UIView+ColorOfPoint.m\n\n```\n#import \"UIView+ColorOfPoint.h\"\n#import <QuartzCore/QuartzCore.h>\n\n@implementation UIView (ColorOfPoint)\n\n- (UIColor *) colorOfPoint:(CGPoint)point\n{\n    unsigned char pixel[4] = {0};\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    CGContextRef context = CGBitmapContextCreate(pixel, 1, 1, 8, 4, colorSpace, kCGImageAlphaPremultipliedLast);\n\n    CGContextTranslateCTM(context, -point.x, -point.y);\n\n    [self.layer renderInContext:context];\n\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n\n    //NSLog(@\"pixel: %d %d %d %d\", pixel[0], pixel[1], pixel[2], pixel[3]);\n\n    UIColor *color = [UIColor colorWithRed:pixel[0]/255.0 green:pixel[1]/255.0 blue:pixel[2]/255.0 alpha:pixel[3]/255.0];\n\n    return color;\n}\n```\n@end\n\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg 300 600 模拟器%}\n","mtime":1378965763000,"source":"_posts/22.md","_id":"mn4gdxmfj1672m3b"},{"content":"title: 判断地图坐标是否在区域内\ndate: 2013-09-03 16:51:48\ntags: [技术]\ncategories: ios\n\n---\n\n>此方法与前一篇文章中的得到UIView某点的色值达到的效果一直，通常为了保持精度 两个方法一起使用。\n  \n<!-- more -->\n```\n-(IBAction)foundTap:(UITapGestureRecognizer *)recognizer\n{\n    CGPoint point = [recognizer locationInView:self.mapView];\n\n    CLLocationCoordinate2D tapPoint = [self.mapView convertPoint:point toCoordinateFromView:self.view];\n\n    [self pointInsideOverlay:tapPoint];\n\n    if (isInside) \n     {\n       ....\n     }\n}\n```\nHere is a method to call from the previous to check if the point is inside the overlay:\n```\n-(void)pointInsideOverlay:(CLLocationCoordinate2D )tapPoint \n{\n    isInside = FALSE; \n\n    MKPolygonView *polygonView = (MKPolygonView *)[mapView viewForOverlay:polygonOverlay];\n\n    MKMapPoint mapPoint = MKMapPointForCoordinate(tapPoint);\n\n    CGPoint polygonViewPoint = [polygonView pointForMapPoint:mapPoint];\n\n    BOOL mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView.path, NULL, polygonViewPoint, NO);\n\n        if ( !mapCoordinateIsInPolygon )\n\n            //we are finding points that are inside the overlay\n        {\n            isInside = TRUE;\n        }\n}\n```\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg 300 600 %}\n","mtime":1378965763000,"source":"_posts/23.md","_id":"wfzypk863i0orv3j"},{"content":"title: ios 笔记之 内购\ndate: 2013-08-21 09:18:13\ntags: [技术]\ncategories: ios\n---\n> 昨晚同事拿了一个app 发现其app 内部页面打开了appstore  并没有唤起手机自带的appstore， 刚开始以为是用webview 加载的\n<!-- more --> ，可是自己些了一个demo 发现并不是那样一回事 用webview 加载appstore 地址 会被js 自动吊起本地的appstore，\n下面是我的发给同事的邮件 直接贴下来\n\n我们都绕了弯路 一直以为是用webview 加载的。 我下班做了测试 发现用webview 加载appstore的地址 ，ios 会根据User-Agent 自动判断 唤起本地的app store，其效果跟用[[UIApplicationsharedApplication] openURL:[NSURL URLWithString:@\"\"]];是一样的。\n\n后来我尝试改写User-Agent  发现打开的页面是电脑打开的页面一样的 并不是我们通过手机 打开app store 看到的页面。\n\n后来我看苹果的文档 发现 他们提供了一个类SKStoreProductViewController专门来干这个事情的\n\n[https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html)\n\n\n实现效果如下图\n\n{% img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1e7u10xs9nwj20m015c0x9.jpg 250 600  %}\n\n##下面是关键代码\n\n```\n需要引入的\n#import <StoreKit/StoreKit.h>\ndelegate 为SKStoreProductViewControllerDelegate\n\n\n调用方式\n    [self openAppWithIdentifier:@\"592043421\"];\n\n\n\n#pragma mark - SKStoreProductViewControllerDelegate\n- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController {\n    [viewController dismissViewControllerAnimated:YES completion:^{\n    }];\n}\n\n\n\n\n\n\n- (void)openAppWithIdentifier:(NSString *)appId {\n    SKStoreProductViewController *storeProductVC = [[SKStoreProductViewController alloc] init];\n    storeProductVC.delegate = self;\n    \n    NSDictionary *dict = [NSDictionary dictionaryWithObject:appId forKey:SKStoreProductParameterITunesItemIdentifier];\n    [storeProductVC loadProductWithParameters:dict completionBlock:^(BOOL result, NSError *error) {\n        if (result) {\n            [self presentViewController:storeProductVC animated:YES completion:nil];\n        }\n    }];\n}\n\n```\n","mtime":1378965763000,"source":"_posts/appstore.md","_id":"k5zfcy5vdxg7mf5o"},{"content":"title: git系类教程之 找出最懒的程序员\ndate: 2013-09-03 11:19:34\ntags: [技术]\ncategories: git\n---\n\n>场景假设:⼀一个开发⼩小组有10个程序员,他们⽤用 Git 做版本控制,某⼀一天程序员A push了当天的⼏几个 commit之后,突然在想“我在这个项⺫⽬目到底⼀一共进⾏行过多少次commit?谁⽐比我commit更多?多多少?谁是 组⾥里⾯面进⾏行最多commit的?谁是最少的?”\n<!-- more -->\n\nGit ⾮非常⼈人性化地⽀支持这样⼀一个命令:$ git shortlog\n这个命令会返回这个 git repository 底下每个⽤用户进⾏行 commit 的次数,以及每次 commit 的注释。 -s 参数省略每次 commit 的注释,仅仅返回⼀一个简单的统计。\n-n 参数按照 commit 数量从多到少的顺利对⽤用户进⾏行排序\n\n```\n$ git shortlog -s -n\n  135  Tom Preston-Werner\n  6  remi\n  3  Mikael Lind\n  3  Toby DiPasquale\n  2  Aristotle Pagaltzis\n  2  Basil Shkara\n  1  Marc Chung\n  1  Nick Gerakines\n\n ```","mtime":1378965763000,"source":"_posts/git10.md","_id":"xpgd98pwpcquo2ir"},{"content":"title: git错误 fatal: remote origin already exists.\ndate: 2013-09-03 13:37:59\ntags: [技术]\ncategories: git\n---\n\n> 当执行 git remote addorigin git@github.com:hufeng825/test.git\n\n错误提示：fatal: remote origin already exists.\n<!-- more -->\n解决办法\n\n```\n$ git remote rm origin\n\n```","mtime":1378965763000,"source":"_posts/git11.md","_id":"75lf4zufdm3mrm15"},{"content":"title: git错误 git rebase master First, rewinding head to replay your work on top of it... error: The following unt\ndate: 2013-09-03 13:39:50\ntags: [技术]\ncategories: git\n---\n\ngit rebase master\nFirst, rewinding head to replay your work on top of it...\nerror: The following untracked working tree files would be overwritten by checkout:\n<!-- more -->\nHFFrame.xcodeproj/project.xcworkspace/xcuserdata/apple.xcuserdatad/UserInterfaceState.xcuserstate\nPlease move or remove them before you can switch branches.\nAborting\ncould not detach HEAD\n\n执行\n```\n~/Desktop/HFFrame(example) $ git clean -d -fx \"\"\n\n```\n","mtime":1378965763000,"source":"_posts/git12.md","_id":"52r2afk75xht432d"},{"content":"title: mac 开发 git svn 应该添加那些忽略列表\ndate: 2013-09-03 13:45:11\ntags: [技术]\ncategories: \n- git\n- svn\n---\n>如题，git svn 应该添加那些忽略列表?\n<!-- more -->\n\n1. .DS_Store\n2. build\n3. *~.nib\n4. *.so\n5. *.pbxuser\n6. *.mode\n7. *.perspective*\n","mtime":1378965763000,"source":"_posts/git13.md","_id":"u0f9thbk3psim372"},{"content":"title: git 系类教程之 log显示\ndate: 2013-09-02 17:59:59\ntags: [技术]\ncategories: git\n---\n查看log是程序员常用的操作之一,不要以为一个git log了事,下面介绍下git log 的高级操作.\n<!-- more -->\n\n1. 显示所有提交记录的包括提交时间 提交人员联系方式等等: git log\n\n2. 显示所有提交记录 只显示提交信息: git shortlog\n\n3. 显⽰示版本历史,以及版本间的内容差异:git log -p\n\n4. 只显⽰示最近⼀一次提交:git log -1\n\n5. 显⽰示最近的20个提交:以及版本间的内容差异:git log -20 -p\n\n6. 显⽰示最近6⼩小时的提交:git log --since=\"6 hours\"\n\n7. 显⽰示两天之前的提交:git log --before=\"2 days\" ","mtime":1378965763000,"source":"_posts/git2.md","_id":"vkb14kr7u9ecxaju"},{"content":"title: git 系列教程之 提交信息的后悔药 修改提交信息\ndate: 2013-09-02 18:06:42\ntags: [技术]\ncategories: git\n---\n有没有提交过\"修改bug\" \"上传代码\" 等等类似脑残的提交信息. code review 时看到这样的提交信息 每个team leader 肯定不会容忍的. 下面要介绍的是如何修改之前提交的历史信息\n<!-- more -->\n\n##方法一 可以修改最后一次 commit\n\t git commit --amend \n----\n\n##方法二 交互式修改\n\n###步骤一\n   \n\tgit rebase -i master~1 //最\n\tgit rebase -i master~5 //最后五次\n\n###步骤二\n // 显示结果如下，修改 pick 为 edit ，并 :wq 保存退出\n\t pick 91b495b 2012-01-08: \"提交信息内容\"\n\n\t# Rebase 9ef2b1f..91b495b onto 9ef2b1f\n\t#\n\t# Commands:\n\t#  pick = use commit\n\t#  edit = use commit, but stop for amending //改上面的 pick 为 edit\n\t#  squash = use commit, but meld into previous commit\n\t#\n\t# If you remove a line here THAT COMMIT WILL BE LOST.\n\t# However, if you remove everything, the rebase will be aborted.\n\t#\n\n###步骤三\n 使用\n\n\tgit rebase --continue //完成操作\n","mtime":1378965763000,"source":"_posts/git3.md","_id":"q7izftubyuzl2f1q"},{"content":"title: git 系类教程之 懂的这些配置能让git 更好用\ndate: 2013-09-02 18:16:59\ntags: [技术]\ncategories: git\n---\n\n是不是抱怨git操作太过于复杂,是不是想要让log 更加漂亮 是不是想要让git 跟svn 一样支持st ci 等等这样的缩写命令……\n<!-- more -->\n下面的这些配置能够满足你.\n\n打开终端 执行\n```\ncd\nvi .git/.gitconfig\n```\n然后修改gitconfig\n```\n[alias]\n  logs = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n  st = status\n  ci = commit\n  br = branch\n  co = checkout\n  df = diff\n  lg = log -p\n```\n\n如果想要把 rebase 當做 git pull 的預設值，可以在專在 .gitconfig 加上\n```\n\n[branch \"master\"]\n  remote = origin\n  merge = refs/heads/master\n  rebase = true\n```\n\n也可以直接加到 ~/.gitconfig 讓所有的 tracked branches 都自動套用這個設定：\n```\n[branch]  \n\tautosetuprebase = always\n```\n\n\n\n\n","mtime":1378965763000,"source":"_posts/git4.md","_id":"wurp9b7ghf8zxlec"},{"content":"title: git系列教程之 修改远程仓库地址 modify remote url\ndate: 2013-09-03 09:50:37\ntags: [技术]\ncategories: git\n---\n某天突然IT部门告之服务器要换地址了，本地有clone出来的git厍，则需要修改一下origin的地址，以便能继续push和pull，方法是，在命令行项目所在目录下执行：\n<!-- more -->\n\tgit remote set-url origin 新地址\n\n","mtime":1378965763000,"source":"_posts/git5.md","_id":"aoysp7jaw1u6vvpf"},{"content":"title: git系类教程之 获取指定分支指定文件的更新\ndate: 2013-09-03 10:03:50\ntags: [技术]\ncategories: git\n---\n多分支并行时，主干A 想要获取某分支上的某个文件的更新，但是并不像merge 这个分支，如图\n\n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1e89338drs8j20ib0g4abh.jpg 150 200 %}\n<!-- more -->\n\n```\ngit checkout 指定分支 指定文件\n\ngit checkout breanchA HFFrame/Global/Global_macro.h\n```","mtime":1378965763000,"source":"_posts/git6.md","_id":"iq4skog4q2rr7yr4"},{"content":"title: git系类教程之 指定公钥\ndate: 2013-09-03 10:13:04\ntags: [技术]\ncategories: git\n---\n\n如果本地有多个公钥 如何对git 进行指定用哪个公钥呢？\n<!-- more -->\n\n```\nvi .git/config \n\n\n[core]\n\n       repositoryformatversion = 0\n\n       filemode = true\n\n       bare = false\n\n       logallrefupdates = true\n\n       ignorecase = true\n\n[remote \"origin\"]\n\n       fetch = +refs/heads/*:refs/remotes/origin/*\n\n       url = ssh://dev@nav.fun-guide.mobi:6521/home/dev/git/cmb.git\n\n[branch \"master\"]\n\n       remote = origin\n\n       merge = refs/heads/master\n\n[branch \"cmb-dingcan\"]\n\n       remote = origin\n\n       merge = refs/heads/cmb-dingcan\n\n~                                                                               \n\n\n\nHost git.magus-soft.com\n\nHostName git.magus-soft.com\n\nPort 6521\n\nUser git\n\nIdentityFile ~/.ssh/iphone_git\n\n~                                                                                 \n\n\n\n／.ssh/config\n\n```","mtime":1378965763000,"source":"_posts/git7.md","_id":"g6kq8ilcz6ym6nve"},{"content":"title: git与SVN协同的工作流程\ndate: 2013-09-03 11:00:12\ntags: [技术]\ncategories: [git, svn]\n---\n\ngit可以和SVN服务器一起使用，即，中央服务器采用svn，本地代码库使用git。这样的好处是，可以兼容以前的项目，同时本地有一套完整的版本控制系统，可以随时查看代码修改历史，随时提交，不需要网络。合适的时候再提交到SVN服务器。git-svn的工作流程也有很多，我们推荐使用下面这种方式。\n\n<!-- more-->\n\n\n##一.git-svn初始化\n\n```\ngit svn init SVNREMOTEURL\n\n```\n-s 参数是表面使用的是svn标准命名方法,即 trunk,tags,branches,这个参数有时很重要,建议使用,命 令后面还可以加个文件夹名字作为clone后的目录\n\n```\ngit svn fetch\n\n```\n可能碰到只想从某个版本开始进行fetch,那么请需要 –r 参数。 例如:\n\n```\n$ git svn fetch -r 1342:HEAD\n\n$ git remote add origin GITREMOTEURL 初始化远程git 地址 \n\n这⼀一步可以省略 如果没必要提交到远程git 服务器中\n\n```\n\n##二.git-svn基本⽤用法\n\n###本地修改代码后提交 \n\n```\ngit commit -a -m “”\n\n```\n###同步远程svn 服务器 \n\n```\ngit svn rebase \n\n```\n###推送到远程svn服务器 \n\n```\ngit svn dcommit \n\n```\n###推送到远程git 服务器 \n\n```\ngit push\n\n```\n\n###从SVN服务器获取代码\n\n```\n$ git svn clone http://svnserver/project/trunk\n\n```\n### 创建一个本地分支\n\n```\n为了方便合并，减少不必要的麻烦，最好保持主分支master不变，在一个新的分支进行日常工作\n\ngit branch workA\n\n```\n###日常修改和提交\n\n\n与git的工作流程完全一样\n\n```\n$ git checkout -b work\n$ git commit -a\n\n```\n###切回master从SVN获取最新代码\n\n```\n$ git checkout master\n$ git svn rebase\n\n```\n\n###master同步后，与工作分支合并\n\n```\n$ git checkout work\n$ git rebase master     ## 手工解决可能的冲突\n\n```\n\n###合并主分支\n\n```\n$ git checkout master $ git merge work\n\n```\n\n###git-svn 解决冲突 \n\n* ⼿动打开冲突的⽂文件 找到冲突的地⽅方修改完成后保存\n\n* 执⾏行 git add 冲突⽂文件\n\n* git rebase --continue \n\n* git svn dcommit","mtime":1378965763000,"source":"_posts/git9.md","_id":"b256xrt44i56aq0y"},{"content":"title: hexo教程1 如何安装hexo\ndate: 2013-08-08 14:21:33\ntags: [技术]\ncategories: [hexo]\n---\n<!--more-->\n##前言\n>很早之前就想自己搭建一个博客，但是无奈已没有时间 而没有银子购买服务器，把家里的mac 当做服务器搭建wordpress但是不能保证速度和访问时间。偶然间发现了octopress,于是兴冲冲的折腾起来，最后搭建成功了，废了很大的经历，最主要的原因是还是网络原因，octopress 安装需要下载大量的安装依赖非常繁琐，到处是坑。后来偶然间发现了hexo，发现要比octopress 好用的太多了。于是果断废弃octopress 转头hexo\n\n***\n\n##概念理解\nhexo 是基于node.js 的 和rails 差不多。再次使用前 需要安装两个插件\n\n *   nvm （版本控制）\n     nodejs version manager,可以把它理解为 rails里面的rvm  \n *   npm （包管理机制 ）\n \t nodejs package manager,可以把它理解为 rails 里面的bundle \n     \n- - -\n###安装步骤(mac)\n>只针对于mac 其他的请到官网查看相应平台的安装方法http://zespia.tw/hexo \n\n***\n#### npm\n***\n打开终端 执行一下命令\n\n```\ngit clone git://github.com/creationix/nvm.git ~/nvm\n```\n安装完毕后，在~/.bash_profile或~/.bashrc加入以下内容\n\n```\n. ~/nvm/nvm.sh`\n```\n执行\n\n```\nsource .bash_profile //或者 source .bashrc\n```\n之后即可使用 nvm 来安装 Node.js\n\n```\n   nvm install v0.8.14\n   nvm use v0.8.14\n   nvm alias default v0.8.14 \n```\n***\n#### hexo\n安装\n\n```\nnpm install -g hexo\n```\n更新\n\n```\nnpm update -g \n```\n***\n\n###设定\n\n编辑 _config.yml\n\n下面贴出我的配置 大家自行根据各自的配置进行相应修改\n\n\n\t// Site\n\ttitle: 阿峰的技术窝窝\n\tsubtitle: 专注于移动互联网\n\tdescription: C/C++/Linux/嵌入式/IOS/WEB/\n\tauthor: Jason Hu\n\temail: hufeng@hufengvip.cn\n\tlanguage: zh-CN\n\n\t// URL\n\t// If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://hufeng825.github.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\ttag_dir: tags\n\tarchive_dir: archives\n\tcategory_dir: categories\n\tcode_dir: downloads/code\n\n\t// Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\n\tauto_spacing: false # Add spaces between asian characters and western characters\n\ttitlecase: false # Transform title into titlecase\n\tmax_open_file: 100\n\tfilename_case: 0\n\thighlight:\n\t  enable: true\n\t  line_number: true\n\t  tab_replace:\n\n\t// Category & Tag\n\tdefault_category: IOS\n\tcategory_map:\n\ttag_map:\n\n\t// Archives\n\t// 2: Enable pagination\n\t// 1: Disable pagination\n\t// 0: Fully Disable\n\tarchive: 2\n\tcategory: 2\n\ttag: 2\n\n\t// Server\n\t// Hexo uses Connect as a server\n\t// You can customize the logger format as defined in\n\t// http://www.senchalabs.org/connect/logger.html\n\tport: 4000\n\tlogger: false\n\tlogger_format:\n\n\t// Date / Time format\n\t// Hexo uses Moment.js to parse and display date\n\t// You can customize the date format as defined in\n\t// http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY MMM D\n\ttime_format: H:mm:ss\n\n\t// Pagination\n\t// Set per_page to 0 to disable pagination\n\tper_page: 10\n\tpagination_dir: page\n\n\t// Disqus\n\tdisqus_shortname:\n\n\t// Extensions\n\t// Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n\t// Themes: https://github.com/tommy351/hexo/wiki/Themes\n\n\tplugins:\n\t- hexo-generator-sitemap\n\n\n\ttheme: bootstrap\n\texclude_generator:\n\n\t// Deployment\n\t// Docs: http://zespia.tw/hexo/docs/deploy.html\n\tdeploy: \n\t  type: github\n\t  repository: https://github.com/hufeng825/hufeng825.github.io.git\n\t  branch: master\n ","mtime":1378965763000,"source":"_posts/hexo1.md","_id":"krhfdw14jeftb9mk"},{"content":"title: mac 下的默认配置\ndate: 2013-08-31 21:45:59\ntags: [技术]\ncategories: [ios, mac]\n---\n\n请几天安装其他的shell 结果把默认的shell更改了  有没有快捷的方法更换会默认配置 <!--more-->其实mac 下 有一个很简单命令可以搞定这些用户默认设置\n打开终端社着敲敲如下的命令\n\n\tchsh\n\n{%img left http://ww3.sinaimg.cn/mw690/a43af4ffjw1e866tu4f66j20a107sq3i.jpg  运行效果 300  400 %}\n\n\n","mtime":1378965763000,"source":"_posts/ios10.md","_id":"gqqnjm55zvbkanai"},{"content":"title: 银行支付控件之 自动随机(shuffle)密码键盘的实现算法\ndate: 2013-08-31 22:05:28\ntags: [技术]\ncategories: ios\n---\n为了广大用户的支付安全,输入密码的页面密码键盘要用随机排序,因为有版权问题无法把自己写的代码全部贴出 所以下面只把关键的洗牌算法贴出来\n\n##算法一\n```\nNSMutableArray *randSequence = [[NSMutableArray alloc] initWithCapacity:8];\nfor (int ii = 0; ii < 10; ++ii)\n    [randSequence addObject:[NSNumber numberWithInt:ii]];\n\nfor (int ii = 9; ii > -1; --ii) {\n    int r = arc4random() % 9\n    [randSequence exchangeObjectAtIndex:ii withObjectAtIndex:r];\n\n```\n##算法二\n```\n\n@interface NSMutableArray (Shuffling)\n- (void)shuffle;\n@end\n\n\n//  NSMutableArray_Shuffling.m\n\n#import \"NSMutableArray_Shuffling.h\"\n\n@implementation NSMutableArray (Shuffling)\n\n- (void)shuffle\n{\n    NSUInteger count = [self count];\n    for (NSUInteger i = 0; i < count; ++i) {\n        // Select a random element between i and end of array to swap with.\n        NSInteger nElements = count - i;\n        NSInteger n = (arc4random() % nElements) + i;\n        [self exchangeObjectAtIndex:i withObjectAtIndex:n];\n    }\n}\n\n@end\n```\n\n","mtime":1378965763000,"source":"_posts/ios11.md","_id":"v26l7mf0viffhyyw"},{"content":"title: git系类教程之 综合篇\ndate: 2013-09-03 10:18:19\ntags: [技术]\ncategories: git\n---\n\n不敢说这是git常用操作最全的教程，这是本人再前人的基础上加上应用了三年多git总结的，应该是比较全的，后续我还会把git 常见的错误总结出来。\n<!-- more -->\n\n##git基本工作流程\n\ngit支持很多种不同的工作流程，我们采用的是与SVN接近的模拟中央服务器流程。即，有一个公用的代码库放在服务器上，开发者从这个共享的服务器克隆后，在本地开发，然后提交到服务器，并且从服务器获取其他用户提交的内容。\n\n**注意** git是分布式的代码控制系统，所以每个代码库都是平等的，这里只是在逻辑上划分了一个中央服务器而已，在物理结构上，中央代码库与本地代码库没有什么不同。\n[编辑]创建帐号\ngit可以使用多种协议在代码库之间通信。我们目前采用ssh协议，需要用户在服务器上有一个ssh帐号才能访问代码库。用户需要在本机创建一个ssh密钥对，把公钥发给管理员，密钥保存在自己本机。这样，就可以使用密钥连接服务器。\n\n\n##开始工作\n开始工作之前，需要复制一套中央服务器的代码库：\n\n```\n$ git clone /server/repo/project\n\n```\n\n###本地修改和提交\n\ngit的提交操作是在本地完成的，不需要网络连接。\n\n```\n$ git checkout branch\n--- 编辑现有文件或者添加新文件 ...\n\n```\n\n```\n$ git add newfile\n$ git commit -a\n--- 填写此次提交的备注\n\n```\n###从中央服务器获取其他人的更新\n\n这个操作实际是执行了获取更新，并且与本地代码合并两个操作。因为有可能2人改了同一个地方，所以这里有可能会出现冲突的情况。出现冲突时，需要手工合并代码。\n\n```\n$ git pull\n向中央服务器发送本地的修改\n这个操作是把本地的所有新的commit历史都提交到服务器\n\n```\n\n```\n$ git push\n\n```\n\n##一：版本控制守则\n\n1. 不要提交垃圾文件。包括临时文件，编译产生的二进制文件，个人设置文件，系统cache，与项目无关的文件等等。使用.gitignore文件来告诉git哪些文件应该忽略掉。  \n\n2. 不要提交不能编译运行的代码到master分支。平时创建临时分支来工作，可以随时提交，当告一段落之后再合并到master分支。保证master分支的代码是可运行的，这样不会给团队中的其他人带来不必要的影响。 \n\n3. 善用分支。可以每开始一个新功能时就创建一个新分支，改完后合并到master。每个新版本也要用一个新分支，这样如果需要改老版本的bug，那么可以很轻松地切换到老分支，改完后再切回新分支。 \n\n4. 多提交，及时提交。每当改动达到可以用一句话描述的时候，就提交。 \n\n5. 一定要写清楚提交注释，写明做了哪些修改，不要用笼统的一句话例如“改bug”，而是要写具体的说明例如，“按钮文字从转发改成分享”。\n每个准备提交上线的版本要打tag，命名成v1.0.0_rc1这种格式，第一次提交就是rc1，第二次提交就是rc2等等 \n\n---\n\n##二：git仓库\n\n###请求代码\n\n```\n$ git clone ssh://%%%%.git\n$ git clone ssh://%%%%%%.git\n\n```\n\n##三： 本地代码库管理\n\n### 1.让git使用你的用户名来标记每次commit\n\n```\n$ git config --global user.name \"hufeng\"\n$ git config --global user.email hufeng@hufengvip.cn\n\n```\n### 2.在当前目录初始化一个代码库\n\n```\n$ git init\n\n```\n\n### 3.把所有文件加入版本控制\n\n```\n$ git add .\n\n```\n### 4.commit所有修改过的文件\n\n```\n$ git commit -a\n\n```\n\n### 5.扔掉对代码库所做的修改，恢复到HEAD版本\n\n```\n$ git checkout -f\n或\n$ git reset --hard\n\n```\n### 6.优化log显示\n\n```\ngit log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n\n```\n### 7.创建一个分支\n\n```\n$ git branch test\n\n```\n\n### 8.切换到一个分支\n\n```\n$ git checkout test\n\n```\n\n### 9.切换回主分支\n\n```\n$ git checkout master\n\n```\n### 10.命令行提示符脚本\n\n*把下面的脚本放到 ~/.profile 或者 ~/.bashrc 里，命令行的提示符即会显示出当前的git分支名称。例如：~/Projects/cmb (master) $*\n\n```\nfunction parse_git_branch {\n      ref=$(git symbolic-ref HEAD 2> /dev/null) || return\n        echo \"(\"${ref#refs/heads/}\")\"\n}\n\nPS1=\"\\w \\$(parse_git_branch)\\$ \"\n\n```\n---\n\n## 三. 操作远程代码库\n\n### 1.使用git协议共享本地代码库\n\ngit本身带了一个服务器命令，启动后，其他机器可以用git协议访问本机的代码库\n\n```\n$ git daemon --export-all --base-path=/home/pub/projects/ test.git\n\n```\n**注意：**\n\n* 如果返回\"fatal: no matching remote head\"，说明代码库里没有文件或者没有commit过。\n* 在.git目录下应该有git-daemon-export-ok这个文件，否则必须使用export-all参数来强制共享\n* 如果允许远程提交代码，需要加上 --enable=receive-pack 参数\n\n### 2.从版本库中删除文件\n\n```\n在git rm -rf  --cached  CCB.xcodeproj/project.xcworkspace/xcuserdata/  \n\n--cached 本地保留服务器删除\n\n```\n### 3.远程仓库的重命名\n\n在新版 Git 中可以用 git remote rename 命令修改某个远程仓库的简短名称，比如想把 pb 改成 paul，可以这么运行：\n\n```\n$ git remote rename pb paul\n$ git remote origin pau\n\n```\n**注意**\n对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了paul/master。\n\n### 4.远程仓库的删除\n\n碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：\n\n```\n$ git remote rm branchA\n\n```\n或者使用\t\n\n```\n $ git push origin :xx //删除远程\n \n $ git branch -d xx //删除本地\n\n```\n\n### 5.更新指定分支指定文件\n\n```\n$ git checkout 指定分支 指定文件\n\n$ git checkout master HFFrame/Global/Global_macro.h\n\n```\n\n### 6.复制一个远程代码库\n\n```\n$ git clone git://10.150.150.136/test.git test\n\n```\n\n### 7.从远程代码库上的主分支获取最新的代码\n\n第一次：\n\n```\n$ git pull git://10.150.###.###/test.git master\n或\n$ git pull ssh://10.150.###.###/test.git master\n\n```\n以后：\n\n```\n$git pull origin master\n\n指定好配置文件后可以直接执行pull push 不用跟后面的分支 骨干\n\n具体方法是 仓库跟目录 .git/config \n\n [core]\n           repositoryformatversion = 0\n           filemode = true\n           bare = false\n           logallrefupdates = true\n           ignorecase = true\n   [remote \"origin\"]\n           fetch = +refs/heads/*:refs/remotes/orig    in/*\n           url = ssh://git@git.huaxia.com:6521    /cmblife.git\n   [branch \"master\"]\n          remote = origin\n          merge = refs/heads/master\n   [branch \"hufeng\"]\n          remote = origin\n          merge = refs/heads/hufeng\n\n```\n### 8.将本地代码库的修改传给远程代码库\n\n如果是提交到master分支：\n\n```\n$ git push origin master\n\n```\n**警告** 远程代码库应该是一个空的bare库，否则会搞乱working copy！！如果working copy是干净的，可以使用git checkout -f来同步代码库。如果已经做了修改，则就没有很好的办法恢复同步状态了！\n\n### 9. 在远程代码库创建一个分支\n\n有时候在本地创建的分支希望分享到远程代码库的分支里，下面命令会在远程创建一个名为branch的分支，并且和本地的branch分支关联起来\n\n```\n$ git push origin branch\n\n```\n以后，即可使用 git push 来分享代码到远程库。\n\n\n### 10.在本地关联一个远程库的分支\n\n有时候需要在本地获取一个远程分支，使用这个命令：\n\n```\n$ git branch --track origin/branch\n\n```\n以后即可使用 git pull 来获取远程的更新\n\n\n\n\n\n\n\n\n","mtime":1378965763000,"source":"_posts/git8.md","_id":"t2pc762y7nrwismp"},{"content":"title: 复杂页面消退的一个简单实例\ndate: 2013-08-31 22:42:52\ntags: [技术]\ncategories: ios\n---\n\n如图\n\n{% img left http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8680v5hirj20df09qglv.jpg  400 600 %}\n\n<!-- more -->\n实现上面的这个又两种实现方式 \n\n* 一种是给页面1 发广播通知 \n\n* 另外一种就是我要介绍的\n\n```\n [(UINavigationController*)self.parentViewController.presentingViewController\n\n     popToRootViewControllerAnimated:YES];\n\n    [self dismissModalViewControllerAnimated:YES];\n```\n","mtime":1378965763000,"source":"_posts/ios13.md","_id":"oj53rwqhl1nfpvwx"},{"content":"title: 如何清空 NSUserDefaults 下所有数据\ndate: 2013-09-02 08:18:20\ntags: [技术]\ncategories: ios\n---\n每个app 难免要在NSUserDefaults中记一些数据,但这些数据某些清空下药全部清空,比如系统版本升级啦,后台存储数据结构变更啦\n<!-- more -->\n下面给出的代码端就是清空NSUserDefaults的一个实现\n```\n  if (![[NSUserDefaults standardUserDefaults] boolForKey:@\"dontClearHXCache\"])\n\n    {\n\n        NSString *appDomainStr = [[NSBundle mainBundle] bundleIdentifier];\n\n        [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomainStr];\n\n        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"dontClearHXCache\"];\n\n       [[NSUserDefaults standardUserDefaults]synchronize];\n\n    }\n\n    else\n\n    {\n\n        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"dontClearHXCache\"];\n\n        [[NSUserDefaults standardUserDefaults]synchronize];\n\n\n\n    }\n```","mtime":1378965763000,"source":"_posts/ios14.md","_id":"vpodekf8vsfisbe9"},{"content":"title: hibernate 笔记之 基础概念和配置\ndate: 2013-08-14 15:56:58\ntags: [技术]\ncategories: hibernate\n---\n## ORM 概念\n> ORM 解决主要的问题是对象-- 关系映射， 域模型是面向对象的，而关系模型数据是面向关系的，一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录。\n\n<!-- more -->\n\n### 对象的持久化\n\n• 狭义的理解,“持久化”仅仅指把对象永久保存到数据库中\n\n• 广义的理解,“持久化”包括和数据库相关的各种操作:\n\t\n* 保存:把对象永久保存到数据库中。\n\n* 更新:更新数据库中对象(记录)的状态。\n\n* 删除:从数据库中删除一个对象。\n\n* 查询:根据特定的查询条件,把符合查询条件的一个或多个对象从数据 库加载到内存中。\n\n* 加载:根据特定的OID,把一个对象从数据库加载到内 \n\t>' OID --->为了在系统中能够找到所需对象,需要为每一个对象分配一个唯一的标识号。 在关系数据库中称之为主键,而在对象术语中,则叫做对象标识(Object identifier-OID). '\n\n\n 标号  | 面向对象概念 | 面向关系概念 \n--- | --- | ---\n*1* | `对象` | **表的行（即记录）**\n2 | 属性 | 表的列（即字段）\n\n## 注意事项\n\n1. 有一个无参的构造器  反射时需要\n2.  类不能声明为final  如果声明就不能实现延迟加载了\n\n## hibernate 配置文件\n\n> hibernate.cfg.xml\n\n```\n<hibernate-configuration>\n\t<session-factory>\n\t\t<!-- 数据连接相关的配置 -->\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/test</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\t\t\t\n\t\t<property name=\"hibernate.connection.password\">1234</property>\n\t\t\t\n\t\t<!-- 执行操作时显示SQL语句 -->\n\t\t<property name=\"show_sql\">true</property>\n\n\t\t<!-- 格式化输出的SQL语句 -->\n\t\t<property name=\"format_sql\">true</property>\n\t\t\n\t\t<!-- 配置数据库方言 -->\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\t\n\t\t<property name=\"hibernate.hbm2ddl.auto\">update</property>\n\t\t\t\n\t\t<!-- 配置映射文件 -->\t\t\t\n\t\t<mapping resource=\"com/vince/entity/User.hbm.xml\"/>\t\n\t\t</session-factory>\t\n</hibernate-configuration>\n\n```\n\nhbm2ddl.auto:该属性可帮助程序员实现正向工程, 即由 java 代码生成数据库脚本, 进而生成具体的表结构. 。取值 create | update | create-drop | validate\n\n– create : 会根据 .hbm.xml 文件来生成数据表, 但是每次运行都会删 除上一次的表 ,重新生成表, 哪怕二次没有任何改变\n\n– create-drop:会根据.hbm.xml文件生成表,但是SessionFactory一关 闭, 表就自动删除\n\n– update:最常用的属性值,也会根据.hbm.xml文件生成表,但 若 .hbm.xml 文件和数据库中对应的数据表的表结构不同, Hiberante 将更新数据表结构,但不会删除已有的行和列\n\n– validate : 会和数据库中的表进行比较, 若 .hbm.xml 文件中的列在数 据表中不存在,则抛出异常\n\n* format_sql:是否将 SQL 转化为格式良好的 SQL . 取值 true | false\n\n------------------\n\n## hibernate 映射文件\n\n> User.hbm.xml\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE hibernate-mapping PUBLIC\n\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\n<hibernate-mapping package=\"com.vince.entity\">\n\t<class name=\"User\" table=\"USER_TABLE\" dynamic-update=\"true\" dynamic-insert=\"true\">\n\t\t<!-- 配置主键 -->\n\t\t<id name=\"id\" column=\"ID\">\n\t\t\t<!-- native表示使用本地数据库生成主键的方式 -->\n\t\t\t<generator class=\"native\"></generator>\n\t\t</id>\n\t\t<!-- 其它属性的配置 -->\n\t\t<property name=\"name\" column=\"NAME\" not-null=\"true\"></property>\n\t\t<property name=\"age\" column=\"AGE\"></property>\n\t\t<property name=\"createDate\" column=\"CREATE_DATE\"></property>\n\t</class>\n\n</hibernate-mapping>\n\n\n-------\n\n<hibernate-mapping package=\"com.vince.entity\">\n\t<class name=\"Emp\" table=\"EMP\" dynamic-insert=\"true\"\n\t\tdynamic-update=\"true\">\n\t\t<id name=\"id\" type=\"int\">\n\t\t\t<column name=\"ID\" />\n\t\t\t<generator class=\"native\" />\n\t\t</id>\n\t\t<property name=\"name\" type=\"java.lang.String\">\n\t\t\t<column name=\"NAME\" />\n\t\t</property>\n\t\t<property name=\"salary\" type=\"float\">\n\t\t\t<column name=\"SALARY\" />\n\t\t</property>\n\t\t<property name=\"age\" type=\"int\">\n\t\t\t<column name=\"AGE\" />\n\t\t</property>\n\t</class>\n</hibernate-mapping>\n\n```\n\n###主键生成策略\n\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7n5a834npj20x00lajw6.jpg\n  hiberate 主键生成策略 %}\n\n ------\n\n\n##SessionFactory 接口\n• 针对单个数据库映射关系经过编译后的内存镜像,是线程安 全的。\n\n• Configuration 对象根据当前的配置信息生成 SessionFactory 对象。SessionFactory 对象一旦构造完毕,即被赋予特定的 配置信息\n\n* Configuration cfg = new Configuration().configure();\n\n* SessionFactory sf = cfg.buildSessionFactory();\n\n• SessionFactory是生成Session的工厂:\n\n* Session session = sf.openSession();\n\n• 构造 SessionFactory 很消耗资源\n\n\n## hibernate.hbm2ddl.auto \n1. create-drop   每次启动重新创建 结束后删除\n2. create 每次启动都重新创建\n3. update 不一样就更新\n4. validate 仅仅验证\n\n\n\n## 如何使用\n\n### 使用范例\n\n\n```\npackage hufeng.test ;\n\nimport org.hibernate.Session ;\nimport org.hibernate.SessionFactory ;\nimport org.hibernate.cfg.Configuration ;\n\npublic class  Test{\n\tpublick static void main(String[] args){\n\t// 加载hibernate 配置文件 （默认加载classpath 下的hibernate.cfg.xml）\n\tConfiguration cfg = new Configuration().config();\n\t\n\t// 通过Configulation 对象创建SessionFactory 工厂\n\tSessionFactory factory = cfg.buildSessionFactory();\n \t\n \t//Session操作数据库的一次会话\n \t//线程不安全\n \tSession session = factory.openSession();\n\n\n \t//开启事务 --> 把很多操作组合成一个整体 让事物具有原子性\n \tTransaction tx =  session.beginTransation();\n\n\n \tCustomUser user = new CustomUser(\"jason\",20,new Date());\n\n \t//保存数据\n \tsession.save(user);\n\n \t//提交事物\n \ttx.commit();\n\n \t//关闭\n \tsession.close();\n \tfactory.close();\n }\n}\n\n```\n\n### 创建Hibernate 工具类\n\n```\npublic final class HibernateUtil{\n\tprivate static SessionFactory sessionFactory;\n\tprivate HibernateUtil(){}\n\n\tstatic {\n\t\tConfiguration cfg  = new Configuration().configure();\n\t\tsessionFactory = cfg.buildSessionFactory();\n\t}\n\n\t public static SessionFactory  getSesstionFactory()\n\t {\n\t \treturn sessionFactory;\n\t }\n\n\t public static Session getSession()\n\t {\n\t \treturn sessionFactory.openSession();\n\t }\n\n\t public static void save(Object obj)\n\t {\n\t \tSession session = getSession();\n\t \tTransaction tx = session.benginTransaction();\n\t \tsession.save(obj);\n\t \tsession.evict(obj);//把对象清理出esssion 避免批处理时session中的缓存过多 导致内存溢出\n\t \t//session.clear()；清楚session中所有的对象\n\t \ttx.commit();\n\t \tsession.close();\n\t }\n}\n\n```\n\n### 应用工具类后的代码\n\n\n```\npackage hufeng.test ;\n\nimport org.hibernate.Session ;\nimport org.hibernate.SessionFactory ;\nimport org.hibernate.cfg.Configuration ;\nimport org.util.HibernateUtil;\n\npublic class Test {\n\tpublic static void save()\n\t{\n\t\tUser user =new User(\"jack\",22,new Date()));\n\t\tHibernateUtil.save(user);\n\t}\n}\n\npublick static void main(String[] args)\n{\n\tsave();\n}\n\n```\n### 更加规范应用HQL的代码\n\n```\npublic final class HibernateUtil {\n\n\tprivate static SessionFactory sessionFactory;\n\n\tprivate HibernateUtil() {\n\t}\n\n\tstatic {\n\t\tConfiguration cfg = new Configuration().configure();\n\t\tsessionFactory = cfg.buildSessionFactory();\n\t}\n\n\tpublic static SessionFactory getSessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tpublic static Session getSession() {\n\t\treturn sessionFactory.openSession();\n\t}\n\n\tpublic static void save(Object obj) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\tTransaction tx = session.beginTransaction();\n\t\t\tsession.save(obj);\n\t\t\ttx.commit();\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t}\n\tpublic static void update(Object obj) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\tTransaction tx = session.beginTransaction();\n\t\t\tsession.update(obj);\n\t\t\ttx.commit();\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t}\n\t\n\tpublic static void delete(Object obj) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\tTransaction tx = session.beginTransaction();\n\t\t\tsession.delete(obj);\n\t\t\ttx.commit();\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t}\n\t\n\tpublic static Object get(Class clazz,Serializable id) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\treturn session.get(clazz, id);\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t\treturn null;\n\t}\n\n}\n\n--------\n@Override\n\tpublic List<Emp> list() throws Exception {\n\t\tSession session  = HibernateUtil.getSession();\n\t\t//hql针对对象查询语句\n\t\tString hql = \"from Emp\";//\n\t\t//创建查询(hql)\n\t\tQuery query = session.createQuery(hql);\n\t\tList<Emp> list = query.list();\n\t\tsession.close();\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic void add(Emp emp) throws Exception {\n\t\tHibernateUtil.save(emp);\n\t\t\n\t}\n\n\t@Override\n\tpublic List<Emp> listByName(String name) throws Exception {\n\t\tSession session  = HibernateUtil.getSession();\n\t\tString hql = \"from Emp e where e.name=?\";\n\t\tQuery query = session.createQuery(hql);\n\t\t//sql ？起始位置从1开始\n\t\t//hql ？起始位置从0开始\n\t\tquery.setString(0, name);\n\t\t\n\t\tList<Emp> list = query.list();\n\t\tsession.close();\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic List<Emp> listByAge(int age) throws Exception {\n\t\t\n\t\t\n\t\treturn null;\n\t}\n\n\t//使用别名代替?方式，可以不用考虑设置参数的顺序\n\t@Override\n\tpublic List<Emp> listByNameAge(String name, int age) throws Exception {\n\t\tSession session = HibernateUtil.getSession();\n\t\tString hql = \"from Emp e where e.age=:age and e.name=:name\";\n\t\tQuery query = session.createQuery(hql);\n//\t\tquery.setString(0, name);\n//\t\tquery.setInteger(1, age);\n\t\tquery.setString(\"name\", name);\n\t\tquery.setInteger(\"age\", age);\n\t\t\n\t\t//对分页的支持\n\t\tquery.setFirstResult(0);//设置查询的起始位置\n\t\tquery.setMaxResults(1);//设置每页的记录数\n\t\t\n\t\t\n\t\tList<Emp> emps = query.list();\n\t\t\n\t\t\n\t\t\n\t\t//iterate查询会执行 N+1条语句\n//\t\tIterator<Emp> emps = query.iterate();\n\t\t\n\t\tsession.close();\n\t\treturn emps;\n\t}\n\n\t@Override\n\tpublic List<Emp> listLikeName(String name) {\n\t\tSession session = HibernateUtil.getSession();\n\t\tString hql = \"from Emp e where e.name like :name\";\n\t\tQuery query = session.createQuery(hql);\n\t\tquery.setString(\"name\", \"%\"+name+\"%\");\n\t\tList<Emp> list = query.list();\n\t\tsession.close();\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic Emp getByName(String name) {\n\t\tString hql = \"from Emp e where e.name=:name\";\n\t\tSession session = HibernateUtil.getSession();\n\t\tQuery query = session.createQuery(hql);\n\t\tquery.setString(\"name\", name);\n\t\t//返回唯一的结果\n\t\tEmp emp = (Emp)query.uniqueResult();\n\t\tsession.close();\n\t\treturn emp;\n\t}\n\n\t//QBC检索方式(了解)\n\t@Override\n\tpublic Emp getById(int id) {\n\t\t\n\t\tSession session = HibernateUtil.getSession();\n\t\tCriteria criteria = session.createCriteria(Emp.class);\n\t\t//添加查询条件\n\t\tcriteria.add(Restrictions.eq(\"id\", id));\n\t\tEmp emp = (Emp)criteria.uniqueResult();\n\t\tsession.close();\n\t\treturn emp;\n\t}\n\n\t@Override\n\tpublic long countEmp() {\n\t\tString hql = \"select count(id) as id from Emp\";\n\t\tSession session = HibernateUtil.getSession();\n\t\tQuery query = session.createQuery(hql);\n\t\tlong count = (long)query.uniqueResult();\n\t\tsession.close();\n\t\treturn count;\n\t}\n\tpublic void countEmp2() {\n\t\tString hql = \"select count(id),avg(age) as id from Emp\";\n\t\tSession session = HibernateUtil.getSession();\n\t\tQuery query = session.createQuery(hql);\n\t\tList list = query.list();\n\t\tObject[] objs = (Object[])list.get(0);\n\t\tint count = (int)objs[0];\n\t\tint avg = (int)objs[1];\n\t\tsession.close();\n\t}\n\n\n```\n","mtime":1378965763000,"source":"_posts/hibernate0.md","_id":"2xhpodbssxnoz6b8"},{"content":"title: 如何禁用禁用uwebiview 的反弹功能(bounces)\ndate: 2013-09-02 08:23:19\ntags: [技术]\ncategories: ios\n---\nUIWebView默认允许当网页内容处于最顶端时，用户可以用手指往下拖动，露出空白的背景\n如何禁用呢\n// iOS 5之前\n\n\tfor (id subview in webView.subviews)\n\t  if ([[subview class] isSubclassOfClass: [UIScrollView class]])\n\t    ((UIScrollView *)subview).bounces = NO;\n \n// iOS 5+\n\n\twebView.scrollView.bounces = NO;","mtime":1378965763000,"source":"_posts/ios15.md","_id":"j2cedspzwd5lpbvo"},{"content":"title: hibernate 笔记之 session\ndate: 2013-08-14 10:36:16\ntags: [技术]\ncategories: hibernate\n---\n## session 的概述\n<!-- more -->\n\n1. session 接口是hibernate 向应用程序提供操作数据库最主要的接口，他提供了基本的保存，更新，删除和加载java对象的方法\n\n2. session 具有一个缓存对象，位于缓存中的对象成为持久化对象，它和数据库中的相关记录对应，session能够在某些时间点，按照缓存中的对象变化来执行相关的sql语句。来同步更新数据库，这一过程被称为清理缓存\n\n3. 站在持久化的角度，hibernate 把对象分成四种状态：持久化状态，临界状态，游流状态 删除状态 session的特定方法能使对象从一个状态转换成另一个状态\n\n---\n## Session 接口\nSession 是应用程序与数据库之间交互操作的一个单线程对象,是 Hibernate 运作的中心,所有持久化对象必须在 session 的管理下才可以进 行持久化操作。此对象的生命周期很短。Session 对象有一个一级缓存,显 式执行 flush 之前,所有的持久层操作的数据都缓存在 session 对象处。相 当于 JDBC 中的 Connection。\n\n• 持久化类与 Session 关联起来后就具有了持久化的能力。\n\n• Session 类的方法:\n\n* 取得持久化对象的方法: get() load()\n\n* 持久化对象都得保存,更新和删除: save(),update(),saveOrUpdate(),delete()\n\n* 开启事务: beginTransaction().\n\n* 管理 Session 的方法:isOpen(),flush(), clear(), evict(), close()等\n\n\n\n```\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.hibernate.Hibernate;\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\n\nimport com.vince.entity.User;\nimport com.vince.util.HibernateUtil;\n\n\npublic class Test {\n\t\n\t\n\tpublic static void evict(){\n\t\t\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n\t\tUser user = new User(\"test-7\",17,new Date());\n\t\tsession.save(user);\n\t\t\n\t\tsession.evict(user);//把对象从session中清除,在批量处理时，避免session中缓存的对象太多，会导致内存溢出\n//\t\tsession.clear();//清除session中所有的缓存对象\n\t\tUser user2 = (User)session.load(User.class, user.getId());\n\t\tSystem.out.println(user2);\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t\n\t\n\t/**\n\t * merge方法：合并,保存或更新\n\t * \n\t * \n\t */\n\tpublic static void merge(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n\t\t//情况一：临时对象(新创建的对象)\n\t\t//1)user1 的状态是瞬时对象时，创建一个新的对象user2,把user1对象的属性拷贝到新建的user2对象中,持久化这个user2对象,执行insert语句\n//\t\tUser user1 = new User();\n//\t\tuser1.setAge(22);\n//\t\tuser1.setName(\"test--3\");\n//\t\tuser1.setCreateDate(new Date());\n//\t\t\n//\t\t\n//\t\tUser user2 = (User)session.merge(user1);\n//\t\t\n//\t\tSystem.out.println(user1==user2);\n\t\t\n\t\t//情况二：user1 的状态是游离对象时，Session缓存中是否存在ID为与user1相同的持久化对象\n\t\t//(1)如果有\n//\t\tUser user2 = (User)session.load(User.class, 1);\n//\t\tUser user1 = new User();\n//\t\tuser1.setAge(20);\n//\t\tuser1.setCreateDate(new Date());\n//\t\tuser1.setId(1);\n//\t\tuser1.setName(\"test---4\");\n//\t\tsession.merge(user1);\n\t\t\n\t\t\n\t\t\n\t\t//情况三：如果session中不存在该对象，那么去数据库中查询是否存在该ID的记录，\n\t\t//如果存在，那么就加载这条记录到session中(user2)，比较两个对象属性是否一致，\n\t\t//如果不一致，就把user1的属性拷贝到user2中，执行update语句\n\t\t//如果一致，就不执行任何操作\n//\t\tUser user1 = new User();\n//\t\tuser1.setAge(22);\n////\t\tuser1.setCreateDate(new Date());\n//\t\tuser1.setId(5);\n//\t\tuser1.setName(\"aaa\");\n//\t\tsession.merge(user1);\n\t\t\n\t\t//情况四：如果session中不存在该对象，那么去数据库中查询是否存在该ID的记录，\n\t\t//如果不存在，创建一个新的对象user2,把user1对象的属性拷贝到新建的user2对象中,\n\t\t//持久化这个user2对象,执行insert语句\n\t\tUser user1 = new User();\n\t\tuser1.setAge(22);\n\t\tuser1.setCreateDate(new Date());\n\t\tuser1.setId(6);\n\t\tuser1.setName(\"bbb\");\n\t\tUser user2 = (User)session.merge(user1);\n\t\t\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t\t\n\t}\n\t\n\t/**\n\t * saveOrUpdate 方法：执行保存或更新\n\t * 1、如果实体对象是临时状态（没有ID），那么该方法将执行保存操作\n\t * 2、如果实体对象是游离状态（有ID），那么该方法以将执行更新操作\n\t * \t如果数据库不存在该ID，那么更新将抛出异常\n\t * 3、判断ID是否为空（整型ID 0 空），根据映射文件中的unsaved-value\n\t * \t属性值来判断\n\t */\n\tpublic static void saveOrUpdate(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n\t\tUser user = new User();\n\t\tuser.setAge(21);\n\t\tuser.setName(\"test--1\");\n\t\tuser.setCreateDate(new Date());\n\t\tuser.setId(3);\n\t\t\n\t\tsession.saveOrUpdate(user);\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t\n\tpublic static void delete(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n//\t\tUser user = new User();\n//\t\tuser.setId(6);\n//\t\tuser.setName(\"xxx\");\n\t\t\n\t\tUser user = (User)session.load(User.class, 3);\n\t\t\n\t\tsession.delete(user);\n\t\t\n\t\tSystem.out.println(user.getId());\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t/**\n\t * 更新对象:通过update方法\n\t * 1、如果数据库中不存在ID的记录，抛出异常\n\t * 2、默认生成的SQL语句会根据ID为条件更新所有字段，\n\t * 如果只更新发生变化的字段，那么在映射文件的class配置中添加 dynamic-update=true\n\t * \n\t */\n\tpublic static void update2(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n//\t\tUser user = new User(\"Tom-1\",23,new Date());\n\t\tUser user = (User)session.get(User.class, 1);\n\t\t\n\t\tuser.setName(\"888\");\n\t\tsession.update(user);\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t/**\n\t * 更新对象\n\t * 通过session 的脏数据机制\n\t */\n\tpublic static void update1(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\tUser user = (User)session.load(User.class, 1);\n\t\tuser.setName(\"xxx\");\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t/**\n\t * load方法：\n\t * 1、如果数据库不存在记录，那么将抛出异常\n\t * 2、load方法先执行延迟加载，返回代理对象，在真正使用到该对象时才会\n\t * 从数据库中查询\n\t * 3、初始化代理对象的方法：\n\t * （1）调用代理对象的非主键属性\n\t * （2）Hibernate.initialize()方法初始化代理对象\n\t */\n\tpublic static User load(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\tUser user = (User)session.load(User.class, 5);\n\t\t\n//\t\tSystem.out.println(user.getName());\n\t\tHibernate.initialize(user);//初始化代理对象\n\t\ttx.commit();\n\t\tsession.close();\n\t\t\n\t\treturn user;\n\t}\n\t\n\t/**\n\t * get方法：\n\t * 1、立即从数据库中查询数据\n\t * 2、如果数据库不存在记录，那么将返回null\n\t */\n\tpublic static void get(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\tClass c = User.class;\n\t\tUser user = (User)session.get(c, 1);\n\t\tif(user!=null){\n\t\t//修改时间\n\t\tuser.setCreateDate(new Date());\n\t\t}\n\t\tSystem.out.println(user);\n\t\t\n//\t\tsession.flush();//刷新缓冲\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t/**\n\t * save()方法以会立即为持久化对象设置主键，所有在任何时候会执行insert语句\n\t * persist()，如果在事务内部那么与save()一样，如果在事务外部，不会立即执行\n\t * insert语句\n\t */\n\tpublic static void save(){\n//\t\tUser user = new User(\"jack\",22,new Date());\n\t\tUser user = new User();\n\t\tuser.setName(\"jack\");\n\t\tSession session = HibernateUtil.getSession();\n//\t\tTransaction tx = session.beginTransaction();\n\t\tsession.save(user);\n//\t\tsession.persist(user);\n\t\t\n//\t\ttx.commit();\n\t\t\n\t\tsession.close();\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n//\t\tsave();\n//\t\tget();\n//\t\tUser user = load();\n//\t\tSystem.out.println(user);\n\t\t\n//\t\tupdate1();\n//\t\tupdate2();\n\t\t\n//\t\tdelete();\n//\t\tsaveOrUpdate();\n//\t\tmerge();\n//\t\tevict();\n\t\t\n//\t\tSystem.out.println(UUID.randomUUID().toString());\n\t}\n\n}\n\n\n```","mtime":1378965763000,"source":"_posts/hibernate1.md","_id":"j75qeu0z4gkragvb"},{"content":"title: 善用 NSAutoreleasePool 节约宝贵内存\ndate: 2013-09-02 08:26:20\ntags: [技术]\ncategories: ios\n---\nautorelease自动释放内存，并不会立即把内存释放掉，而是要等到下一个事件周期才会释放掉。问题是一些资源我们不得不使用autorelease类型，比如作为函数的返回值，而且系统api及项目是的大部分也都是这么做的，如果全都依靠我们手动释放很容易造成内存泄漏。\n<!-- more -->\n\n\t \tfor (int i = 0; i <= 10000; i ++) {\n\t  \n\t        //创建一个自动释放池\n\t  \n\t         NSAutoreleasePool *pool = [NSAutoreleasePool new];\n\t  \n\t         NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"hf\" ofType:@\"PNG\"];\n\t  \n\t         UIImage *image = [[UIImage alloc] initWithContentsOfFile:filePath];\n\t  \n\t         UIImage *scalimage = [image imageByScalingAndCroppingForSize:CGSizeMake(320, 640)];\n\t  \n\t         [image release];\n\t  \n\t        //将自动释放池内存释放，它会同时释放掉上面代码中产生的临时变量image2\n\t  \n\t         [pool drain];\n\t  \n\t     }","mtime":1378965763000,"source":"_posts/ios16.md","_id":"7cdigmkid2rcscvl"},{"content":"title: ios 开发之 序列化\ndate: 2013-08-31 22:26:47\ntags: [技术]\ncategories: hexo\n---\n\n序列化\n\n参考原始文档：\n\nhttps://github.com/mystcolor/JTObjectMapping\n\n<!-- more -->\n使用方法\n\n========\n\n\n绝大多数情况下，需要用到的就是一个方法：\n\n[NSObject objectFromJSONObject:stateObject mapping:nil];\n\n其中，把NSObject换成我们想映射成的类的名字。\n\n\n稍微复杂一点，假设类的属性和JSON里的key名字不是一一对应的，那么就要写一个映射关系表作为mapping参数：\n\n    NSDictionary *mapping = [NSDictionary dictionaryWithObjectsAndKeys:\n\n                             @\"myState\", @\"state\",\n\n                             @\"movieList\", @\"movie\",\n\n                             nil];\n\n    [NSObject objectFromJSONObject:stateObject mapping:mapping];\n\n\n如果再复杂一点，我们需要映射一个数组，数组的每个元素映射到一个对象，那么就用到第2个方法：\n\n[NSObject mappingWithKey:@\"responseState\" mapping:nil]\n\n同样，把NSObject换成数组元素对应的类，key是用来存放整个数组的那个属性。\n\n\n\n注意\n\n====\n\nJSON里的字符串，是能自动映射成NSNumber或者int型的，不需要特别写代码。如果想把一个字符串日期，映射成NSDate型，请参考原始文档。\n\n\n\n具体举个例子\n\n===========\n\n\n假设我们有这样一段JSON：\n\n\n {\n\n \"state\":[\n\n {\n\n \"respCode\":\"0000\",\n\n \"respMsg\":\"1\"\n\n }\n\n ],\n\n \"movie\":[\n\n {\n\n \"body\":\"    一开始，这只是叶问的故事他生于佛山\",\n\n \"pics\":\"/images/jz/4779-1-20121225133147.jpg,/images/jz/4779-2-20121225133147.jpg\",\n\n \"name\":\"一代宗师\",\n\n \"movid\":\"4779\",\n\n \"length\":\"120\",\n\n \"hasplan\":\"1\",\n\n \"trailor\":\"/4779.m4v\",\n\n \"director\":\"梁朝伟 章子怡 张震 \",\n\n \"type\":\"动作/传记/剧情/IMAX\",\n\n \"url\":\"http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&w=140\",\n\n \"popularity\":\"6\"\n\n },\n\n {\n\n ...\n\n }\n\n ]\n\n }\n\n \n\n现在，想把它映射到自定义的对象中去。有几种情况：\n\n\n第一种情况，简单地把state数组里面的第一个元素映射成一个FGStateModel类\n\n那么就是，取出这个节点：\n\n    NSDictionary *stateObject = [[self.json objectForKey:@\"state\"] objectAtIndex:0];\n\n然后，执行映射：\n\n    self.state = [FGStateModel objectFromJSONObject:stateObject mapping:nil];\n\n\n第二种情况，把movie这个字典数组映射成一个数组，数组的每个元素是FGMovieModel\n\n    NSArray *movieObject = [self.json objectForKey:@\"movie\"];\n\n    self.movieList = [FGMovieModel objectFromJSONObject:movieObject mapping:nil];\n\n\n第三种情况，如果对象的属性和JSON名字不一样，可以使用映射表，例如我们想把上面整个json对象映射成一个 FGResponseModel 对象，其中，state数组映射成 responseState 属性，movie 数组映射成 movieList 属性。那么，我们需要告诉映射器这个数组里的元素要映射成什么对象。\n\n\n所以，通过 mapping 这个参数告诉它：“请把 JSON 里的 state 数组里的每个元素映射成一个 FGStateModel 对象，并且把最终的数组放到responseState这个属性里。另外，把 movie 这个数组映射成一个 FGMovieModel 数组，并且保存到 movieList 这个属性中。“\n\n\n    NSDictionary *mapping = [NSDictionary dictionaryWithObjectsAndKeys:\n\n                             [FGStateModel mappingWithKey:@\"responseState\" mapping:nil], @\"state\",\n\n                             [FGMovieModel mappingWithKey:@\"movieList\" mapping:nil], @\"movie\",\n\n                             nil];\n\n    self.response = [FGResponseModel objectFromJSONObject:self.json mapping:mapping];\n\n\n```\n#import <Foundation/Foundation.h>\n\n\n@interface FGMovieModel : NSObject\n\n\n@property (nonatomic, retain) NSString *body;\n\n@property (nonatomic, retain) NSString *pics;\n\n@property (nonatomic, retain) NSString *name;\n\n@property (nonatomic, assign) NSInteger movid;\n\n@property (nonatomic, retain) NSNumber *length;\n\n\n@end\n```\n\n\n```\n#import <Foundation/Foundation.h>\n\n\n@interface FGResponseModel : NSObject\n\n@property (nonatomic, retain) NSArray *responseState;\n\n@property (nonatomic, retain) NSArray *movieList;\n\n@end\n\n \n#import <Foundation/Foundation.h>\n\n\n@interface FGStateModel : NSObject\n\n\n@property (nonatomic, retain) NSString *respCode;\n\n@property (nonatomic, retain) NSString *respMsg;\n\n\n@end\n```","mtime":1378965763000,"source":"_posts/ios12.md","_id":"qqohcprj52xqxla6"},{"content":"title:  (NSDate) 时间 (time )比较\ndate: 2013-09-02 08:31:25\ntags: [技术]\ncategories: ios\n---\n做订餐app时对下单时间的时间判断\n下面是规则\n\n*   9:00-14:00 可以订餐\n*   14:00以后掌上餐厅仅接收晚餐订餐\n*   21:00以后掌上餐厅不接收订餐\n  \n{%img left http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87ve4c3ynj208q0abt9n.jpg 截图 300 400%}\n   \n<!-- more -->\n---\n##转换函数\n 将传入的小时和分钟 转换成当日的date\n\n 例如传入 8：00 的str 返回 2013-01-01 08：00 的nsdate\n\n```\n-(NSDate *)CurrentDayTime:(NSString *)dataStr\n\n{\n\n    //设置转换的format\n\n    NSDateFormatter *dateFormatter = [[[NSDateFormatteralloc]init]autorelease];\n\n    [dateFormatter setLocale:[NSLocalecurrentLocale]];\n\n    \n\n    [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm\"];\n\n    //获取当前年月日 \n\n    NSDate *currentdate = [NSDatedate];\n\n    NSCalendar *calendar = [NSCalendarcurrentCalendar];\n\n    NSDateComponents *components = [calendarcomponents:(\n\n                                                         NSYearCalendarUnit  |\n\n                                                         NSMonthCalendarUnit |\n\n                                                         NSDayCalendarUnit |\n\n                                                         NSHourCalendarUnit |\n\n                                                         NSMinuteCalendarUnit\n\n                                                         ) fromDate:currentdate];\n\n   NSInteger year = [components year];\n\n   NSInteger month = [components month];\n\n   NSInteger day = [components day];\n\n   NSString *strDate = [NSString stringWithFormat:@\"%d-%d-%d %@\",year,month,day,dataStr];\n\n   NSDate *date = [dateFormatter dateFromString:strDate];\n\n   return date;\n\n}\n```\n---\n##比较算法\n\n```\nNSLog(@\"%@\\n%@\",[selfCurrentDayTime:@\"18:00\"] ,[NSDatedate]);\n\n    NSDate *date = [NSDatedate];\n\n    if ([datecompare:[selfCurrentDayTime:@\"18:00\"]] ==NSOrderedDescending)\n\n    {\n\n        NSLog(@\"date1 is later than date2\");\n\n        \n\n    } else if ([datecompare:[selfCurrentDayTime:@\"18:00\"]] ==NSOrderedAscending)\n\n    {\n\n        NSLog(@\"date1 is earlier than date2\");\n\n        \n\n    } else\n\n    {\n\n        NSLog(@\"dates are the same\");\n\n        \n\n    }\n```\n##用法如下\n```\n-(BOOL)checkCanDinner\n\n{\n\n    NSDate *currentDate = [NSDatedate];\n\n    if ([currentDate compare:[selfCurrentDayTime:@\"08:59\"]] == NSOrderedDescending //late\n\n        && [currentDate compare:[selfCurrentDayTime:@\"13:59\"]] == NSOrderedAscending //early\n\n        )\n\n    {\n\n        //9:00-14:00 可以订餐\n\n        return YES;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"09:00\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"00:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        HFAlert(@\"因较多餐厅休息,9:00之前掌上餐厅不接收订餐，为您带来的不便请谅解。\");\n\n        return NO;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"17:59\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"14:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        HFAlert(@\"因较多餐厅休息,14:00以后掌上餐厅仅接收晚餐订餐,为您带来的不便请谅解。\");\n\n        return YES;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"21:00\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"18:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        //接受晚上的订单\n\n        return YES;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"23:59\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"21:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        HFAlert(@\"因较多餐厅休息,21:00以后掌上餐厅不接收订餐,为您带来的不便请谅解。\");\n\n        return NO;\n\n    }\n\n    return YES;\n\n}\n```\n\n","mtime":1378965763000,"source":"_posts/ios17.md","_id":"1r4ug3grpwu15upm"},{"content":"title: 父View禁用touch 如何让子view还能获取touch event\ndate: 2013-09-02 09:14:30\ntags: [技术]\ncategories: ios\n---\n{%img left http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87vwh4ocsj20a70dcjrp.jpg 300 400%}\n<!-- more -->\n如上图 当view2 包含在view1中,默认清空下 view1 的touch事件被禁用掉侯view2 肯定是接收不到touch事件的,那有没有什么办法能够让view2接收到touch事件呢?\n其实很简单hitTest 可以帮我们实现这个需求\n```\nuiview addition\n-(id)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    id hitView = [super hitTest:point withEvent:event];\n    if (hitView == self) return nil;\n    else return hitView;\n}\n```","mtime":1378965763000,"source":"_posts/ios18.md","_id":"akzrvk0ps5a520rp"},{"content":"title: 如何得到中英文混合下的NSString的长度?\ndate: 2013-09-02 09:21:21\ntags: [技术]\ncategories: ios\n---\n这个貌似很简单但却是把我跟招行的兄弟难为了好久,为毛?还不是因为招行信用卡中心的网络无法连接外网无法谷歌度娘最后我们只能查看文档写test\n下面是最后我们得到的两个方法\n<!-- more -->\n##方法一:\n\t- (int)getStringLength:(NSString*)strtemp\n\t{\n\n\tNSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);\n\n\t    NSData* da = [strtemp dataUsingEncoding:enc];\n\n\t    return [da length];\n\n\t}\n##方法二:\n\t- (int)convertToInt:(NSString*)strtemp\n\n\t{\n\n\t    int strlength = 0;\n\n\t    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];\n\n\t    for (int i=0 ; i<[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++) {\n\n\t        if (*p) {\n\n\t            p++;\n\n\t            strlength++;\n\n\t        }\n\n\t        else {\n\n\t            p++;\n\n\t        }\n\n\t        \n\n\t    }\n\n\t    return strlength;\n\n\t}\n\n","mtime":1378965763000,"source":"_posts/ios19.md","_id":"61btk27ez6olqzv5"},{"content":"title: Block 定时器 让我们解放了\ndate: 2013-09-02 09:28:52\ntags: [技术]\ncategories: ios\n---\nBlock 没有出现前 ios写个定时器太麻烦了,好在Block的让我们小爽了一把,以后写timer 简单的要命了\n<!-- more -->\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.5 * NSEC_PER_SEC), dispatch_get_current_queue(), ^{\n\n\t     [bgColorView removeFromSuperview];\n\n\t});\n\n\n或者\n\n\tdouble delayInSeconds = 2.0;\n\tdispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);\n\tdispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n\t    <#code to be executed on the main queue after delay#>\n\t});","mtime":1378965763000,"source":"_posts/ios20.md","_id":"cj1b4ehy0rm43v2w"},{"content":"title:  在Finder标题栏上显示完整路径\ndate: 2013-09-02 09:57:17\ntags: [技术]\ncategories: [ios, mac]\n---\n打开终端，输入以下命令并回车：\n\n\tdefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\n\n然后再把finder关了再打开，你会发现路径栏变成这个样子了：\n","mtime":1378965763000,"source":"_posts/ios21.md","_id":"u5zzjdva86purey9"},{"content":"title: ios 清理工程中没有用到的图片\ndate: 2013-08-29 16:43:14\ntags: [技术]\ncategories: \n- ios\n- mac\n---\n>发布前往往需要清理工程中没有用到的图片，这些图片可能是测试图片也可能是以往版本中替换遗留下来的图片\n\n<!-- more -->\n\n##使用方法\n1. 将下面代码保存成**.sh 然后chomd 777 使其可执行\n2. 将**.sh 拷贝到工程根目录下\n3. ./执行**.sh \n4.  再同级目录下会生成一个imge.txt 结果文件\n\n 如下图  \n\n{% img http://ww3.sinaimg.cn/mw690/a43af4ffjw1e83pb1zvo7j215q0pq7bz.jpg 300 500 %}\n\n##源码 \n\n```\n#!/bin/sh\n\necho \"删除有风险 下手需谨慎 如需再次确认图片是否被引用到\"\n\necho \"Defult.png 和例如[UIImage imageNamed:@‘img.png'] 可能会误报\"\n\n\nread -n1 -p  \"【Y】查阅如何确认 【N】直接进行图片检索\" \n\ncase $answer in \n\n\"Y\"|\"y\") \n\nopen -a Safari \"http://blog.csdn.net/hufeng825/article/details/8533647\"\n\necho -n \"按任意键开始程序\";\n\nread var\n\n;;\n\n\"N\"|\"n\") \n\necho \"命令执行时终端会输入结果 搜索完毕后 会在当前路径下自动生成imag.txt的结果报告\"\n\n;;\n\n*) \n\n;;\n\nesac\n\n\n\n\nPROJ=`find .  ! -name '*.xib' -o -name '*.[mh]' -o -name '*.storyboard' -o -name '*.mm' -o -name '*.html' `\n\n\necho \"~~~~~~~~~~~~开始搜索~~~~~~~~~~~~\" >>'./image.txt';\n\nfor png in `find . -name '*.png'`\ndo\n\n   name=`basename -s .png $png`\n   name=`basename -s @2x $name`\n   if ! grep -qhs \"$name\" \"$PROJ\"; then\n        echo \"$png 可能没引用\" \n        echo \"$png 可能没引用\"  >>'./image.txt' ;\n   fi\ndone\n\nfor jpg in `find . -name '*.jpg'`\ndo\n   name=`basename -s .jpg $jpg`\n   name=`basename -s @2x $name`\n   if ! grep -qhs \"$name\" \"$PROJ\"; then\n        echo \"$png 可能没引用\" \n        echo \"$jpg 可能没引用\"  >>'./image.txt';\n   fi\ndone\n\necho \"~~~~~~~~~~~~结束搜索~~~~~~~~~~~~\" >>'./image.txt';\n<<EOF\n\n```","mtime":1378965763000,"source":"_posts/ios3.md","_id":"11jgzevmktkcxd6k"},{"content":"title: removeFromSuperview添加动画使其更加高雅美观\ndate: 2013-08-29 18:29:40\ntags: [技术]\ncategories: ios\n---\n>程序中难免使用removeFromSuperview，但是view控件直接从界面突然消失会显得非常不友好，作为一个高端大气上档次的app细节处处应该注意，\n<!-- more -->\n添加一个简单的动画给用户的感觉立刻不一样了。废话不说直接上代码\n```\n   [UIView animateWithDuration:0.2\n\n                     animations:^{_logViewController.view.alpha = 0.0;}\n\n                     completion:^(BOOL finished)\n\n                                { [_logViewController.view removeFromSuperview]; }\n\n     ];\n\n\n\n```\n","mtime":1378965763000,"source":"_posts/ios4.md","_id":"xflvio3t2u3kem1s"},{"content":"title: ios 通过当前view得到所在的viewcontroller\ndate: 2013-08-29 18:35:01\ntags: [技术]\ncategories: ios\n---\nlong long ago ，带过的小弟遇到了一个问题，需要从当前的控件（一般是uiview）获取当前所在的viewcontroller\n<!-- more -->\n当时给出他的解决办法\n```\n@implementation UIView (GetVCAdditions)\n- (UIViewController *)GetiewController {\n    Class vcc = [UIViewController class];\n    UIResponder *responder = self;\n    while ((responder = [responder nextResponder]))\n        if ([responder isKindOfClass: vcc])\n            return (UIViewController *)responder;\n    return nil;\n}\n\n\n```\n","mtime":1378965763000,"source":"_posts/ios5.md","_id":"g4tq2p7r9pty03vs"},{"content":"title: ios iphone5 适配 之 如何使app 适用不通分辨率\ndate: 2013-08-29 18:44:36\ntags: [技术]\ncategories: ios\n---\niphone5适配 有如下集中种思路\n\n<!-- more -->\n\n1：利用自身的autoresize 加上代码实现\n\n2：写两套xib\n\n3：利用ios5+ 以上的autolayout\n\n前两种方式应用比较广泛 ，因为毕竟国内还有部分应用ios4.3的用户\n\n下面给第二种方式应用下的部分代码\n\n```\n- (id)init\n{\n\n    NSString    *clssName = NSStringFromClass([self class]);\n    NSString    *xibName = is4InchScreen() ?[NSString stringWithFormat:@\"%@_4inch\", clssName] : clssName;\n    self = [super initWithNibName:xibName bundle:nil];\n    if (self) {}\n    return self;\n\n}\n\n```\n\n","mtime":1378965763000,"source":"_posts/ios6.md","_id":"om1rosgm5v3xlyud"},{"content":"title: 快速清除subviews之 隐私循环\ndate: 2013-08-29 18:48:47\ntags: [技术]\ncategories: ios\n---\n\n> 问：如何快速把当前view下的所有子view 及其子子view们删除掉\n<!-- more -->\n解答这个问题前先介绍下 NSArray \n\nNSArray 类定义的方法\n\n1.  makeObjectsPerformSelector:@select（aMethod）\n\n简介：让数组中的每个元素 都调用 aMethod \n\n2. makeObjectsPerformSelector:@select（aMethod）\n\n   　　　　              withObject:oneObject\n\n**ps：让数组中的每个元素 都调用 aMethod  并把 withObject 后边的 oneObject 对象做为参数传给方法aMethod**\n\n因此可以利用隐私循环来快速清除subviews\n\n[[self.view subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];","mtime":1378965763000,"source":"_posts/ios7.md","_id":"c5ls4enlj2cz0raw"},{"content":"title: xcode 5.0 的持续继承\ndate: 2013-08-31 20:41:27\ntags: [技术]\ncategories: ios\n---\n>\nXcode的支持持续集成通过Xcode的服务流程。Xcode的服务，可在OS X服务器，自动一体化建设过程中，您的应用程序的分析，测试和归档。<!-- more -->从开发的Mac，您可以创建机器人上运行一个单独的服务器，在那里他们执行这些集成。机器人可以帮助确保您的产品始终处于释放状态，当有故障时，服务会通知你的人或代码变化引起的故障。\n\n{%img left http://img.blog.csdn.net/20130617220248765 400 600%}\n\n---------\n\n##概览\n\n按照本文档中列出的步骤，建立一个持续集成的工作流程，使用Xcode和Xcode服务。\n\t注：持续集成工作流程通常依赖于一个或多个开发Mac上运行Xcode和一个独立的OS X服务器运行Xcode的服务。但是，您可以安装开发的Mac OS X Server的。这样的配置可以有助于评估如何采用持续集成。之后，你会发现它有一个专门的OSX服务器运行Xcode的托管服务，你的资料库，并远程执行集成更多有用的。\n\n---------\n\n##设置和自定义的Xcode服务\n\t即使你从来没有架设一台服务器，你会发现OSX服务器上设立了Xcode服务是简单的过程。后服务运行起来，你可以添加开发设备，配置机器人，并指定发布标准。\n\n[有关章节： “采用持续集成工作流”](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/200-Adopting_a_Continuous_Integration_Workflow/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1)\n\n---------\n\n##创建和运行僵尸\n\t\n\t机器人的自动化工作流程的心脏。机器人构建和测试产品与您选择的方案。随着Xcode的服务能够访问你的项目的源代码库中，您可以创建并安排定期运行或在每个源代码提交的机器人。您也可以设定机器人发送邮件通知其集成的成功或失败。\n\n[有关章节： “配置机器人执行连续集成”](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1)\n\n\n##监控和​​管理集成\n\n\t机器人的自动化工作流程的心脏。机器人构建和测试您的产品，您所选择的计划。Xcode的服务提供了日志管理机器人，查看测试结果，并读取整合日志导航。该服务还提供了通过一个网页，在那里您可以查看bot活动的总结以及集成细节的结果。\n   \n[有关章节： “工作与机器人”](https://daw.apple.com/cgi-bin/WebObjects/DSAuthWeb.woa/wa/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&path=%2F%2Flibrary%2Fprerelease%2Fios%2Fdocumentation%2FIDEs%2FConceptual%2Fxcode_guide-continuous_integration%2F300-Working_with_Bots%2Fview_integration_results%2Ehtml#//apple_ref/doc/uid/TP40013292-CH4-SW1)\n\n\n\n\n\n\n","mtime":1378965763000,"source":"_posts/ios8.md","_id":"fait3a3isdqv646x"},{"content":"title: ios 开发笔记之图片 Image\ndate: 2013-08-20 09:29:39\ntags: [技术]\ncategories: ios\n---\n\n##关于图片资源\nios 程序会把图片资源编译成二进制文件，程序运行时会把这些图片从磁盘加载直接到内存，如果图片很大，加载速度就会很慢。\n<!-- more -->\n为了优化提高性能，需要尽量压缩图片资源。（ps 苹果公司的UIKit 开发者Andy Matuschak指出：使用resizable image是最快的方法。）\n\n\n##关于图片资源的压缩\n如果不需要用半透明的图片 则尽量不要用png 格式的图片。相应的可以用jpg格式的。另外谷歌最新推出的一种格式webp\n  \n###1 WebP是什么\nWebP是Google推出的一种同时提供了有损压缩与无损压缩的图片格式。目前互联网上传输的数据有65%都是图片，WebP就是出于减少数据量、加速网络传输的目的而开发的。WebP希望能够达到和JPEG同水平的图片质量，但是更小的文件，以减少图片的传送时间。\n在有损压缩的状况下，WebP比同样画质的JPEG少了25% ～ 34%的文件大小 。而在无损压缩的情形中，比起用libpng产生的PNG图片，WebP少了34%的文件大小，也比用pngout再处理过的PNG图片少了26%的文件大小。\n###2 WebP的使用\nwebp图片压缩率会比jpeg、png更高，因此下载图片会更省流量，特别适合在mobile app上使用。 比如iOS app上，可以把webp编译生成framework，然后加入引用就可以是使用了。强烈推荐。\n这iOS解析时，可以直接使用 WebPImage。\nNSData *imageData = [NSData dataWithContentsOfURL:url];\nUIImage *tmpImage = [[WebPImage alloc] loadWebPFromData:imageData];\nSDWebImage最近也提供了对webp的支持，起先不支持自己写了一个分类，现在可以直接用他的UIImage+WebP\n\n\n##关于加载方式\n  imageNamed每次都读图片到缓存中，只适合频繁使用的图片，\ninitWithContentsOfFile的方法加载图片后，不缓存，适合加载不常使用的图片。 \n引导图片一般情况下只会启动一次而且图片也一般情况下比较大所以用imageNamed 会非常， 如果用initWithContentsOfFile:，这些图片所占用内存可以很快被释放\n\n>资料参考by wufawei stackoverflow\n\n\n\n","mtime":1378965763000,"source":"_posts/iosimage.md","_id":"xke3clsoyw4w3gvj"},{"content":"title: mac 下 git svn 的代理设置\ndate: 2013-09-02 08:10:34\ntags: [技术]\ncategories: [git, svn]\n---\n所干的工作 因为涉及到金融行业网络安全性比较高 公司的网络设置了代理 这导致了git svn 双双挂了。 \n<!-- more -->\n废话少说 下面介绍如何对git svn 设置代理\n\n1. $HOME 下 我的路径为/Users/jason:\n\n2. 进入$HOME/.subversion \n\n   编辑servers 文件 添加\n\n\t   [global]\n\t    http-proxy-host = XX.XX.XX.XX\n\t    http-proxy-port = XXXX\n\t   [groups]\n\n3. 编辑$HOME/.gitconfig\n\n\t   [http]        \n\n\t        proxy = http://XX.XX.XX.XX:XXXX\n\n\t   [https]\n\t         proxy = http://XX.XX.XX.XX:XXXX\n\n4. 或者直接用命令\n\n\t\tgit config --global http.proxy http://XX.XX.XX.XX:XXXX\n\t\tgit config --global https.proxy http://XX.XX.XX.XX:XXXX\n","mtime":1378965763000,"source":"_posts/mac1.md","_id":"ofnlj2rsooozcidt"},{"content":"title: MAC OS X 下快速切换代理 \ndate: 2013-09-03 13:20:05\ntags: [技术]\ncategories: \n- ios\n- mac\n---\n\n因为行业原因 在公司上网必须通过代理安装，所以每天上下班开电脑第一件事 就是开关代理。于是做了一个软件 利用shell进行切换代理。\n\n{% img left  http://ww2.sinaimg.cn/mw690/a43af4ffjw1e898v6vmwdj20dk06bwep.jpg 300 400 运行效果图 %}\n  \n  <!-- more-->\n    \n{% img left http://ww4.sinaimg.cn/mw690/a43af4ffjw1e898wixkiej207q020dfu.jpg 200 300 软件 %}\n\n    \n\n下面是主要源码\n\n```\ntell application \"System Events\"\n\nset proxy_dialog to display dialog \"代理模块(Ethernet版本):\" buttons {\"打开代理模式1\", \"打开代理模式2\", \"关闭代理\"} default button \"打开代理模式1\" with title \"华夏基金开发环境快速切换代理App\"\n\nset proxy_interface to button returned of proxy_dialog\n\nend tell\n\n\nif proxy_interface is \"打开代理模式1\" then\n\ndo shell script \"networksetup -setwebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setsecurewebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setwebproxystate Ethernet on&&networksetup -setsecurewebproxystate Ethernet on\" with administrator privileges\n\nend if\n\n\nif proxy_interface is \"打开代理模式2\" then\n\ndo shell script \"networksetup -setwebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setsecurewebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setwebproxystate Ethernet on&&networksetup -setsecurewebproxystate Ethernet on\" with administrator privileges\n\nend if\n\n\nif proxy_interface is \"关闭代理\" then\n\ndo shell script \"networksetup -setwebproxystate Ethernet off&&networksetup -setsecurewebproxystate Ethernet off\" with administrator privileges\n\nend if\n\n```\n\n","mtime":1378965763000,"source":"_posts/mac3.md","_id":"k4zw72xxcycvnlox"},{"content":"title: mac 下更新DNS 缓存\ndate: 2013-09-03 17:14:30\ntags: [技术]\ncategories: [ios ,mac]\n---\n\n开始的时候难免遇到修改host的时候，但是host后没有即刻生效，可使用终端命令手动清除DNS缓存：\n\n```\ndscacheutil -flushcache\n```","mtime":1378965763000,"source":"_posts/mac4.md","_id":"w93qur86uyg54zv1"},{"content":"title: 工作四年多了\ndate: 2013-08-08 17:16:03\ntags: [情感]\ncategories: 情感\n---\n##工作好几年了 谈谈自己的一些感想吧\n\n最近几件事情触动挺大的，\n<!--more-->\n\n1：跟侯的差距越来越远了， 不到三年 侯做到了很多我没做到的事情1-)自考了北大计算机系 2-)结识了年薪几十万的漂亮嫂子 3-）拿到了驾照 4-）在燕郊买了房子\n\n虽然彼此间还是隔三差五的聚聚，但是间隔越来越长了，大家都在忙，而我是真的在瞎忙 忙的没有任何意义。\n\n2：家里的压力，家里的压力从催着找女朋友结婚 到现在的赶紧攒首付买房子，之前很天真的甚至有些自私的想 不结婚不要孩子，可是现在觉得真的很对不起两个老人的\n\n3：同事和朋友，现在还记得几年前 sally姐说的那句话 同事永远成不了朋友。 有一次跟周妈谈起旺哥为什么不喜欢带新人，周妈谈了一口气说 旺旺是被现在这个社会伤的太深了了。虽然不太清楚在旺哥身上发生过什么 但是 回想这几年发生在自己身上的事情 也能体会的到写。现在这年头 不要期待着知恩图报 祈求不要恩将仇报就好了。 \n\n4：多一事不如少一事。  自己的经历应该放到有价值的人和事上面。 \n\n5：金钱虽然不是唯一的判断标准 但是却是最有效的衡量一个人的办法。\n\n6：珍惜零散的时间 \n\n7：英语 very important\n\n8：一些事情心里明白就行了 不要说出来\n\n{% img right profile http://img.my.csdn.net/uploads/201101/25/3619941_1295933551y8U4.jpg 300 500 昔日的小伙伴 %} ","mtime":1378965763000,"source":"_posts/mood.md","_id":"r0l16s3bcvzs2dyu"},{"content":"title: MQ 笔记之 mac 下安装环境\ndate: 2013-08-20 17:47:34\ntags: [技术]\ncategories: MQ\n---\n##下载\n[从下载地址中下载包](http://www.apache.org/dyn/closer.cgi?path=/activemq/apache-activemq/5.8.0/apache-activemq-5.8.0-bin.tar.gz)\n解压包然后把包放到一个自己不会手一抖就删掉的位置，此处我放到了本地的document下\n如下图\n<!-- more -->\n{% img left http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7uav8h7lbj20o80gkjtw.jpg 200 300 图片%}\n## 添加环境到path \n把/你的保存路径/apache-activemq-5.8.0/bin/activemq 添加到 PATH 中 \n\n0. cd \n1. 执行 vi .profile \n2. 输入 i \n3. 插入 export MQ=/你的路径/apache-activemq-5.8.0/bin/macosx/activemq\n4. wq\n5. source .profile\n\n## 启动mq\n$Mq start\n输入账号 admin 密码  admin\n\n**注意** 如果用代理上网 请把网络环境设置下 如下图\n{% img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubcv9nx0j20oa08egmc.jpg 200 300 网络配置 %}\n\n##查看启动效果\n{% img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubfs7cg1j21ga0oe0yw.jpg 200 300 启动效果 %}\n\n## 基本配置\nconf/jetty.xml\n```\n<bean id=\"securityConstraint\">\n \n        <property name=\"name\" value=\"BASIC\" />\n \n        <property name=\"roles\" value=\"admin\" />\n \n        <property name=\"authenticate\" value=\"false\" />\n \n</bean>\n\n```\n此处可以配置登陆用户权限\n\n\n```\n <property name=\"connectors\">\n            <list>\n                <bean id=\"Connector\" class=\"org.eclipse.jetty.server.nio.SelectChannelConnector\">\n                    <property name=\"port\" value=\"8161\" />\n                </bean>\n            </list>\n </property>\n\n```\n此处用来修改端口号\n\n\n\n\n\n","mtime":1378965763000,"source":"_posts/mq1.md","_id":"wl8epjlx3enlkdey"},{"content":"title: Xcode的持续集成指南\ndate: 2013-08-31 21:11:39\ntags: [技术]\ncategories: hexo\n---\n\n##采用持续集成工作流\n\n设置MAC作为服务器，在其上运行Xcode的服务。然后确保你的本地项目，发布源代码库。要完成设立一个持续集成的工作流程，配置的机器人，不知疲倦地进行集成和时间表。\n<!-- more -->\n\n##OS X Server的安装和配置的Xcode服务\n要运行的Xcode的服务，您必须先安装运行的是Mac OS X v10.9开发者预览版OS X Server的预览。您还必须在服务器上安装Xcode开发者预览。自动构建，分析，测试，和归档您的产品，您将使用Xcode的服务。\n\n###要安装和运行Xcode的服务\n1. 转到http://developer.apple.com/downloads的，并获得OS X v10.9开发者预览版，OS X Server的预览，和Xcode开发者预览版的预发布版本。\n\n2. 安装OS X v10.9开发者预览版，Mac OS X Server的预览，和Xcode开发者预览版的Mac上，你会运行Xcode的服务。\n\n3. 启动服务器应用程序/应用。\n\n4. 在服务器应用程序边栏中，选择的Xcode的服务。\n\n5. 当您第一次打开Xcode的服务在一个特定的服务器上，该服务会询问您确定的Xcode版本，它应该用来执行其任务。\n\n6. 点击选择的Xcode，并选择使用的Xcode版本。\n\n7. 点击On / Off开关打开服务\n\n接下来，添加你的服务器允许访问Xcode的服务团队，如资产配置的配置文件和签名证书为iOS设备构建产品开发团队。你必须是一个管理员或开发团队的代理，这样才能把服务器加进来。\n\n###要添加您的服务器开发团队\n\n1. 在服务器应用程序边栏中，选择的Xcode的服务。\n\n2. 在“设置”窗格中，单击“添加”按钮，旁边的开发团队标签。\n\n3. 输入您的Apple开发者证书，并选择一个团队。\n\n加入团队后，Xcode的服务，您可以添加iOS开发设备运行单元测试时使用。\n\n###要添加一个iOS开发设备的Xcode服务\n\n1. 在服务器应用程序边栏中，选择的Xcode的服务。\n\n2. 将设备连接到服务器，并等待，直到它出现在设备列表中。\n\n3. 点击“加入队伍”按钮旁边的列表中的设备。\n\n添加帐户资料库和您的服务器配置开发的Mac。你会写你的Mac上的使用Xcode代码，你就会让OS X服务器进行持续集成。您还必须发布或您当地的项目转移到资料库，可通过Xcode的服务。\n\n###你开发的Mac OS X Server的帐户添加到Xcode\n\n1. 在Xcode的开发Mac上，单击“帐户”首选项“窗口。\n\n2. 点击添加按钮（+），并选择“添加服务器”。\n\n3. 从服务器列表中选择服务器，输入服务器地址，然后单击“下一步”按钮。\n\n4. 指定您的连接到服务器的凭据，然后单击“添加”。\n\n您可以添加到您的帐户资料库，加快结帐操作。（你也可以添加库到您的清单后，当您检查的项目）。\n\n###要添加存储库到您的帐户\n\n1. 在Xcode的开发Mac上，单击“帐户”首选项“窗口。\n\n2. 点击添加按钮（+），并选择“添加库。\n\n3. 在文本字段中，输入库添加的地址，然后单击“完成”按钮。\n\n##Xcode的服务和团队成员共享项目\n对于Xcode的服务，您的项目进行集成，它必须包含这些项目的存储库的访问。启用访问托管Git仓库在服务器上运行的Xcode服务或Git或Subversion版本库，包含你的项目添加连接信息。\n\n如果同一个团队开发，持续集成涉及到整个团队。谁的作品在产品上的人都必须能够访问所有产品的资源，使任何人都可以引起谁都可能解决问题。如果你有一个不保持源代码库中的项目或工作区，你必须检查你的文件到存储库，让其他团队成员可以在这些产品上。\n\n**您可以在服务器上创建一个Xcode服务器，托管Git仓库**\n开发团队可以共享更改产品OS X服务器托管在一个Git仓库。创建一个Xcode服务器托管Git仓库之前，你必须：\n\n1. 确保都有谁应该能够访问存储库服务器上的用户帐户。\n\n2. 打开系统偏好设置中的服务器上的远程登录服务。\n\n\n###要创建一个Xcode服务器托管您的服务器上的Git仓库\n\n1. 在服务器应用程序边栏中，选择Xcode的服务，然后单击“存储库”按钮。\n\n2. 点击添加按钮（+），并指定存储库的信息：\n\n\t* 选择“主机一个Git仓库。”\n\t* 名称：输入资料库的名称（例如，项目名称）。\n\t* 访问：确定允许用户访问存储库。\n\n3. 单击“创建”。\n\n\t新的资料库资料库列表中出现。如果你有一个发展的Mac上现有的Git管理的项目，你可以把你的变化，这个新的储存库，将其配置为远程，如未来。\n\n###从发展的Mac，您可以共享现有的Git管理项目\n\n当您共享一个项目，其中包含一个Git仓库，是当地发展的Mac，Xcode的服务可以检查出来进行集成。共享一个项目之前，你必须：\n\n1. 作为OS X服务器运行Xcode的服务的管理员进行身份验证。\n2. 确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。\n\n####要共享项目\n\n1. 打开项目发展的Mac上，并选择源控制> PROJECT_NAME >配置PROJECT_NAME。\n\n2. 按一下远程控制。\n\n3. 点击“添加”按钮（+）。\n\n4. 选择“创建新的远程。\n\n5. 选择一台服务器。\n\n6. 输入远程名称。\n\n7. 单击“创建”。\n\n8. 单击“完成”。\n\n9. 这使得共享资源库的上游库项目存​​储库。\n\n###您可以创建一个新项目开发的Mac OS X服务器和主机守则\n\n当您创建您的开发Mac上的项目，你可以创建一个共享库。创建一个共享的项目之前，你必须：\n\n1. 作为OS X服务器运行Xcode的服务的管理员进行身份验证。\n2. 确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。\n\n####要创建共享项目\n\n1. 选择“文件”>“新建”>“项目。\n\n2. 为您的项目中选择一个模板。\n\n3. 指定项目的选项，并单击“下一步”。\n\n4. 指定的位置。\n\n5. 选择“创建git仓库”选项。\n\n6. 确定服务器。\n\n单击“创建”。\n\n\n您可以使用Git来管理你的开发Mac上的非托管的工作区目录\n当你创建一个Xcode的工作区或项目，你必须包括一个Git仓库中生成的工作区目录的选项。如果您没有选择该选项，您的工作区目录不包括一个Git仓库。与他人使用Git版本控制系统要共享工作区目录，在该目录中，你必须初始化一个Git仓库。\n\n您可以使用Subversion的管理项目\nXcode的服务可以连接你的Subversion版本库，并从它的检查项目。\n\n\n##使用搜索引擎来生成，运行静态分析，测试和存档\n您可以运行一个项目的集成通过三个计划行动：\n\n1. 分析，进行静态分析。\n2. 测试，运行一组测试案例。\n3. 存档，建立一个归档的产品，计划建成。\n\n您可以手动执行这些操作，为您做出更改产品。然而，手动集成可以是乏味且容易出错。例如，你可能会忘记发布一个小的变化，打破你的队友的单元测试之前进行测试操作。Xcode的服务提供了一个具有成本效益的方式自动执行集成：机器人。机器人会自动执行你的集成：\n\n1. 每次更改发布到存储库。\n2. 上定期（比如说，每天进行集成，需要很长的时间才能完成）。\nÂ 机器人运行通过Xcode的服务，以在资源库中的项目的当前版本进行集成，是一个过程。包括一个集成构建，分析，测试，归档产品上。可以是成功的积分（即，所有的整合动作传递没有问题）的或不成功的。计划中定义的集成自动化，您必须共享该方案，并创建一个或多个机器人来执行这些集成。\n\n\n要充分利用您的产品开发流程的持续集成环境中，遵循以下做法：\n\n1. 制定适当的单元测试套件和测试用例，显影单元测试后，包括他们在你的机器人运行计划。要了解关于单元测试的更多信息，请参见Xcode的单元测试指南\n为了帮助确保您所做的更改都破不了您或其他人后，你应​​该配合这些变化与单元测试，确定是否规定一种或一组序列功能的方法。有些球队在它的头把这种方法首先开发测试，通过测试的方法，然后执行。\n\n2. 执行静态分析，你应该在您的集成包括静态分析。\n静态分析是深刻检查你的代码，下面的代码路径，您的应用程序可能不遵循正常的发展过程中。这个过程揭示难以发现的编码错误，还确定了在你的代码不遵循建议的API的用法，比如基金会和AppKit的成语。\n\n3. 确保您的产品建立和正确打包。您您的产品作出了重大变化，特别是结构性的变化，如添加或删除文件后，应归档。让你的机器人自动为您归档。\n当您的产品中包含的结构性问题，Xcode可以创建一个归档它为你的团队成员之间共享或提交到App Store。建立和归档产品的能力是你的代码更改的正确性的主要指标。\n\n\n\n##分享计划\n共享的计划被确定为在一个项目中共享和发布共享资源库，以及与其他共享项目文件。你可以分享计划之前，你必须检查的项目。\n\n \n###要共享计划\n\n1. 开发的Mac上，打开的项目，其中包含共享的计划。\n\n2. 选择产品>计划>管理计划。\n\n3. 分享的计划，选择共享选项，并单击“确定”。\n\n4. 选择源控制>提交。\n\n5. 选择共享的资料夹。\n\n6. 指定你提交的信息：\n\n\t* 在文本字段中输入你的提交信息。\n\t* 选择“推到远程”选项（如果您的项目使用Git管理）。\n\n7. 点击“提交文件”按钮。\n\n\n##创建机器人\n\n共享计划后，你可以创建一个机器人来执行持续集成。\n\n \n要创建一个僵尸\n\n开发的Mac上，打开的项目，其中包含计划，定义的行动，以自动化。\n\n选择产品>创建BOT，指定机器人的标识属性，并单击“下一步”。\n\n与指定库凭据机器人，并单击“下一步”。\n\n指定的整合时间表，行动的机器人来执行，以及是否清洁产品前建设。\n\n附表：指定往往机器人集成。\n\n定期：整合每小时，每天或每周。\n在提交更改时集成发布到存储库。\n手册：机器人不会自动整合。\n操作：选择机器人作为整合的一部分执行的行动。\n\n清洁：指定机器人是否重用以前的版本。\n\n单击“下一步”。\n\n如果您选择创建机器人执行第一次整合，整合的结果，出现在日志中的导航仪。\n\n","mtime":1378965763000,"source":"_posts/ios9.md","_id":"vuhhxkllzw6wfisg"},{"content":"title: Markdown \ndate: 2013-08-14 16:13:21\ntags: [技术]\ncategories: hexo\n---\n本文简单介绍下 Markdown 语法\n<!-- more -->\n\n###什么是Markdown\n\nMarkdown是一个将文本转化为HTML的工具。简单来说，Markdown是一个兼顾可读性与易用性的轻量级标记体系。Markdown并不追求大而全，它只关心HTML里最常用的几个标记，对于一些不常用的标记它允许直接将HTML标记插入文本。\n\n****\n\n##表格\n\n标号  | 面向对象概念 | 面向关系概念 \n--- | --- | ---\n*1* | `对象` | **表的行（即记录）**\n2 | 属性 | 表的列（即字段）\n\n代码如下\n\n```\n标号  | 面向对象概念 | 面向关系概念 \n--- | --- | ---\n*1* | `对象` | **表的行（即记录）**\n2 | 属性 | 表的列（即字段）\n\n```\n\n****\n\n##标题\n\nMarkdown提供了两种方式（Setext和Atx）来显示标题。\n\n代码如下\n\n```\nSetext方式\n标题1\n=================\n\n标题2\n-----------------\n\nAtx方式\n# 标题1\n## 标题2\n###### 标题6\n\n```\n****\n\n##换行\n\n在文字的末尾使用两个或两个以上的空格来表示换行。\n\n代码如下\n\n```\n> 这是一个引用，\n> 这里木有换行，   \n> 在这里换行了。\n> > 内部嵌套\n\n```\n****\n\n##列表\n\n###无序列表使用*、+或-后面加上空格来表示。\n\n代码如下 \n\n```\n* Item 1\n* Item 2\n* Item 3\n\n+ Item 1\n+ Item 2\n+ Item 3\n\n- Item 1\n- Item 2\n- Item 3\n\n```\n\n\n###有序列表使用数字加英文句号加空格表示。\n\n\n代码如下 \n\n```\n1. Item 1\n2. Item 2\n3. Item 3\n\n\n```\n\n****\n\n##代码区域\n\n行内代码使用反斜杠`表示。 \n代码段落则是在每行文字前加4个空格或者1个缩进符表示。\n\n****\n\n\n##强调\n\nMarkdown使用\\*或\\_表示强调。\n\n\n代码如下 \n\n```\n\n单星号 = *斜体*\n单下划线 = _斜体_\n双星号 = **加粗**\n双下划线 = __加粗__\n\n```\n\n链接\n\nMarkdown支持两种风格的链接：Inline和Reference。\n\n语法：\n\nInline：以中括号标记显示的链接文本，后面紧跟用小括号包围的链接。如果链接有title属性，则在链接中使用空格加“title属性”。\nReference：一般应用于多个不同位置使用相同链接。通常分为两个部分，调用部分为[链接文本][ref]；定义部分可以出现在文本中的其他位置，格式为[ref]: http://some/link/address (可选的标题)。 \n注：ref中不区分大小写。\n\n代码如下 \n\n```\n\n这是一个Inline[示例](http://www.baidu.com \"可选的title\")。\n这是一个Reference[示例][ref]。\n[ref]: http://www.baidu.com \n\n```\n\n****\n\n## 图片\n\n图片的使用方法基本上和链接类似，只是在中括号前加叹号。 \n注：Markdown不能设置图片大小，如果必须设置则应使用HTML标记<img>。\n\n代码如下 \n\n```\n{% img right http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg 300 400 可选的title %}\nInline示例：![替代文本](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\")\nReference示例：![替代文本][pic]\n[pic]: http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\"\nHTML示例：<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" alt=\"替代文本\" title=\"标题文本\" width=\"200\" />\n\n```\n效果\n\n{% img right http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg 300 400 可选的title %}\nInline示例：![替代文本](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\")\nReference示例：![替代文本][http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg]\n[pic]: /assets/images/ship.jpg \"可选的title\"\nHTML示例：<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" alt=\"替代文本\" title=\"标题文本\" width=\"200\" />\n\n****\n\n\n## 自动链接\n\n使用尖括号，可以为输入的URL或者邮箱自动创建链接。如test@test.com。\n\n## 分隔线\n\n在一行中使用三个或三个以上的*、-或_可以添加分隔线，其中可以有空白，但是不能有其他字符。\n\n## 转义字符\n\nMarkdown中的转义字符为\\，可以转义的有：\n```\n\\\\ 反斜杠\n\\` 反引号\n\\* 星号\n\\_ 下划线\n\\{\\} 大括号\n\\[\\] 中括号\n\\(\\) 小括号\n\\# 井号\n\\+ 加号\n\\- 减号\n\\. 英文句号\n\\! 感叹号\n\n```\n\n\n\n","mtime":1378965763000,"source":"_posts/markdown.md","_id":"qsjzwze60k3fxnj4"},{"content":"title: MQ 笔记之 JMS 简介 （什么是JMS）\ndate: 2013-08-21 21:22:00\ntags: [技术]\ncategories: MQ\n---\n##一：JMS基本概念\n\n###1.      JMS的目标\n\n为企业级的应用提供一种智能的消息系统，JMS定义了一整套的企业级的消息概念与工具，\n<!-- more -->\n\n尽可能最小化的Java语言概念去构建最大化企业消息应用。统一已经存在的企业级消息系\n\n统功能。\n\n###2.      JMS提供者\n\nJMS提供者是指那些完全完成JMS功能与管理功能的JMS消息厂商，理论上JMS提供者完成 \n\nJMS消息产品必须是100%的纯Java语言实现，可以运行在跨平台的架构与操作系统上，当前\n\n一些JMS厂商包括IBM,Oracle, JBoss社区 (JBoss Community), Apache 社区(ApacheCommunity)。\n\n###3.      JMS应用程序, 一个完整的JMS应用应该实现以下功能：\n\n* JMS 客户端 – Java语言开发的接受与发送消息的程序\n\n* 非JMS客户端 – 基于消息系统的本地API实现而不是JMS\n\n* 消息 – 应用程序用来相互交流信息的载体\n\n* 被管理对象–预先配置的JMS对象，JMS管理员创建，被客户端运用。如链接工厂，主题等\n\n* JMS提供者–完成JMS功能与管理功能的消息系统\n\n##二: JMS 规范\n\n\n### 连接工厂\n连接工厂是GUST用来创建连接的对象，例如ActiveMQ提供的ActiveMQConnectionFactory。\n\n### 连接\nJMS Connection封装了客户与JMS提供者之间的一个虚拟的连接。\n\n### 会话\nMS Session是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。\n\n### 目的地\n目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2 规范中定义了两种消息传递域\n\n####点对点的消息模式(Point to Point Messaging)\n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7umekfemwj20is06o0tb.jpg  300  200 点对点 %}\n\n***\n\n下面的JMS对象在点对点消息模式中是必须的：\n\n* 队列(Queue) – 一个提供者命名的队列对象，客户端将会使用这个命名的队列对象\n\n* 队列链接工厂(QueueConnectionFactory) – 客户端使用队列链接工厂创建链接队列ConnectionQueue来取得与JMS点对点消息提供者的链接。\n\n* 链接队列(ConnectionQueue) – 一个活动的链接队列存在在客户端与点对点消息提供者之间，客户用它创建一个或者多个JMS队列会话(QueueSession)\n\n* 队列会话(QueueSession) – 用来创建队列消息的发送者与接受者(QueueSenderandQueueReceiver)\n\n* 消息发送者(QueueSender 或者MessageProducer)– 发送消息到已经声明的队列\n\n* 消息接受者(QueueReceiver或者MessageConsumer) – 接受已经被发送到指定队列的消息\n\n**注意如下：**\n\n* 每个消息只能有一个消费者。\n* 消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。\n\n#### 发布订阅模式(publish – subscribe Mode)\n\n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7umpp9onwj20is0ayjsk.jpg  200  300 发布者 %}\n***\n* 主题Topic(Destination) – 一个提供者命名的主题对象，客户端将会使用这个命名的主题对象\n\n* 主题链接工厂(TopciConnectionFactory) – 客户端使用主题链接工厂创建链接主题 ConnectionTopic来取得与JMS消息Pub/Sub提供者的链接\n\n* 链接主题(ConnectionTopic) – 一个活动的链接主题存在发布者与订阅者之间\n\n* 会话(TopicSession) – 用来创建主题消息的发布者与订阅者 (TopicPublisher  and TopicSubscribers)\n\n* 消息发送者MessageProducer) – 发送消息到已经声明的主题\n\n* 消息接受者(MessageConsumer) – 接受已经被发送到指定主题的消息\n\n**注意如下：**\n\n* 每个消息可以有多个消费者。\n* 生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。\n\n****\n>本系列博文参考自whitesock  淮少吧 贾志刚\n\n","mtime":1378965763000,"source":"_posts/mq2.md","_id":"t3l5ioij91snj269"},{"content":"title: MQ 笔记之 消息持久化\ndate: 2013-08-21 23:43:37\ntags: [技术]\ncategories: MQ\n---\n>在broker中设置属性persistent=”true”(默认是true)，同时发送的消息也应该是persitent类型的。ActiveMQ消息持久化有三种方式：AMQ、KahaDB、JDBC。\n配置文件在config/jetty.xml\n<!-- more -->\n\n##一、AMQ\nAMQ是一种文件存储形式，它具有写入速度快和容易恢复的特点。消息存储在一个个文件中，文件的默认大小为32兆，如果一条消息的大小超过了32兆，那么这个值必须设置大点。当一个存储文件中的消息已经全部被消费，那么这个文件将被标识为可删除，在下一个清除阶段，这个文件被删除。默认配置如下：\n\n```   \n<persistenceAdapter>\n  <amqPersistenceAdapter directory=\"activemq-data\" maxFileLength=\"32mb\"/>\n</persistenceAdapter>\n\n```\n\n属性名称\t| 默认值\t| 描述\n--- | --- | ---\ndirectory\t| activemq-data\t | 消息文件和日志的存储目录\nuseNIO\t| true\t| 使用NIO协议存储消息\nsyncOnWrite |\tfalse |\t同步写到磁盘，这个选项对性能影响非常大\nmaxFileLength\t| 32mb\t| 一个消息文件的大小\npersistentIndex\t| true\t| 消息索引的持久化，如果为false，那么索引保存在内存中\nmaxCheckpointMessageAddSize\t| 4kb\t| 一个事务允许的最大消息量\ncleanupInterval\t| 30000\t| 清除操作周期，单位ms\nindexBinSize\t| 1024\t| 索引文件缓存页面数，缺省为1024，当amq扩充或者缩减存储时，会锁定整个broker，导致一定时间的阻塞，所以这个值应该调整到比较大，但是代码中实现会动态伸缩，调整效果并不理想。\nindexKeySize\t| 96\t| 索引key的大小，key是消息ID\nindexPageSize\t| 16kb\t| 索引的页大小\ndirectoryArchive\t| archive |\t存储被归档的消息文件目录\narchiveDataLogs\t| false\t| 当为true时，归档的消息文件被移到directoryArchive,而不是直接删除\n\n--------\n\n##二、 KahaDB\n\nKahaDB是基于文件的本地数据库储存形式，虽然没有AMQ的速度快，但是它具有强扩展性，恢复的时间比AMQ短，从5.4版本之后KahaDB做为默认的持久化方式。默认配置如下\n\n```\n <persistenceAdapter>\n        <kahaDB directory=\"activemq-data\" journalMaxFileLength=\"32mb\"/>\n </persistenceAdapter>\n\n```\nKahaDB的属性：\n\nproperty name\t| default value\t| Comments\n--- | --- | ---\ndirectory\t| activemq-data\t| 消息文件和日志的存储目录\nindexWriteBatchSize\t| 1000\t| 一批索引的大小，当要更新的索引量到达这个值时，更新到消息文件中\nindexCacheSize\t| 10000\t| 内存中，索引的页大小\nenableIndexWriteAsync |\tfalse |\t索引是否异步写到消息文件中\njournalMaxFileLength\t| 32mb\t| 一个消息文件的大小\nenableJournalDiskSyncs\t| true\t| 是否讲非事务的消息同步写入到磁盘\ncleanupInterval\t| 30000\t| 清除操作周期，单位ms\ncheckpointInterval\t| 5000\t| 索引写入到消息文件的周期，单位ms\nignoreMissingJournalfiles\t| false | \t忽略丢失的消息文件，false，当丢失了消息文件，启动异常\ncheckForCorruptJournalFiles\t| false\t|检查消息文件是否损坏，true，检查发现损坏会尝试修复\nchecksumJournalFiles\t| false |\t产生一个checksum，以便能够检测journal文件是否损坏。\n`5.4版本之后有效的属性:`\t | |\t\narchiveDataLogs\t| false\t| 当为true时，归档的消息文件被移到directoryArchive,而不是直接删除\ndirectoryArchive\t| null\t| 存储被归档的消息文件目录\ndatabaseLockedWaitDelay\t| 10000\t| 在使用负载时，等待获得文件锁的延迟时间，单位ms\nmaxAsyncJobs\t| 10000 |\t同个生产者产生等待写入的异步消息最大量\nconcurrentStoreAndDispatchTopics |\tfalse\t| 当写入消息的时候，是否转发主题消息\nconcurrentStoreAndDispatchQueues | true\t| 当写入消息的时候，是否转发队列消息\n5.6版本之后有效的属性:\t | |\t\narchiveCorruptedIndex\t| false |\t是否归档错误的索引\n\n从5.6版本之后，有可能发布通过多个kahadb持久适配器来实现分布式目标队列存储。什么时候用呢？如果有一个快速的生产者和消费者，当某一个时刻生产者发生了不规范的消费，那么有可能产生一条消息被存储在两个消息文件中，同时，有些目标队列是危险的并且要求访问磁盘。在这种情况下，你应该用通配符来使用mKahaDB。如果目标队列是分布的，事务是可以跨越多个消息文件的。\n\n每个KahaDB的实例都可以配置单独的适配器，如果没有目标队列提交给filteredKahaDB，那么意味着对所有的队列有效。如果一个队列没有对应的适配器，那么将会抛出一个异常。配置如下：\n\n```\n<persistenceAdapter>\n  <mKahaDB directory=\"${activemq.base}/data/kahadb\">\n    <filteredPersistenceAdapters>\n      <!-- match all queues -->\n      <filteredKahaDB queue=\">\">\n        <persistenceAdapter>\n          <kahaDB journalMaxFileLength=\"32mb\"/>\n        </persistenceAdapter>\n      </filteredKahaDB>\n      \n      <!-- match all destinations -->\n      <filteredKahaDB>\n        <persistenceAdapter>\n          <kahaDB enableJournalDiskSyncs=\"false\"/>\n        </persistenceAdapter>\n      </filteredKahaDB>\n    </filteredPersistenceAdapters>\n  </mKahaDB>\n </persistenceAdapter>\n\n```\n如果filteredKahaDB的perDestination属性设置为true，那么匹配的目标队列将会得到自己对应的KahaDB实例。配置如下\n\n```\n<persistenceAdapter>\n  <mKahaDB directory=\"${activemq.base}/data/kahadb\">\n    <filteredPersistenceAdapters>\n      <!-- kahaDB per destinations -->\n      <filteredKahaDB perDestination=\"true\" >\n        <persistenceAdapter>\n          <kahaDB journalMaxFileLength=\"32mb\" />\n        </persistenceAdapter>\n      </filteredKahaDB>\n    </filteredPersistenceAdapters>\n  </mKahaDB>\n </persistenceAdapter>\n\n```\n\n##三、 JDBC\n\n配置JDBC适配器\n\n```\n<persistenceAdapter>\n        <jdbcPersistenceAdapter dataSource=\"#mysql-ds\" createTablesOnStartup=\"false\" />\n</persistenceAdapter>\n\n```\ndataSource指定持久化数据库的bean，createTablesOnStartup是否在启动的时候创建数据表，默认值是true，这样每次启动都会去创建数据表了，一般是第一次启动的时候设置为true，之后改成false。\n\nMYSQL持久化bean\n\n```\n<bean id=\"mysql-ds\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n    <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n    <property name=\"url\" value=\"jdbc:mysql://localhost/activemq?relaxAutoCommit=true\"/>\n    <property name=\"username\" value=\"activemq\"/>\n    <property name=\"password\" value=\"activemq\"/>\n    <property name=\"poolPreparedStatements\" value=\"true\"/>\n</bean>\n\n```\nSQL Server持久化bean\n\n```\n <bean id=\"mssql-ds\" class=\"net.sourceforge.jtds.jdbcx.JtdsDataSource\" destroy-method=\"close\">\n   <property name=\"serverName\" value=\"SERVERNAME\"/>\n   <property name=\"portNumber\" value=\"PORTNUMBER\"/>\n   <property name=\"databaseName\" value=\"DATABASENAME\"/>\n   <property name=\"user\" value=\"USER\"/>\n   <property name=\"password\" value=\"PASSWORD\"/>\n </bean>\n\n```\nOracle持久化bean\n\n```\n<bean id=\"oracle-ds\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n\t<property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/>\n\t<property name=\"url\" value=\"jdbc:oracle:thin:@10.53.132.47:1521:activemq\"/>\n\t<property name=\"username\" value=\"activemq\"/>\n\t<property name=\"password\" value=\"activemq\"/>\n\t<property name=\"maxActive\" value=\"200\"/>\n\t<property name=\"poolPreparedStatements\" value=\"true\"/>\n</bean>\n\n```\nDB2持久化bean\n\n```\n<bean id=\"db2-ds\" class=\"org.apache.commons.dbcp.BasicDataSource\"  destroy-method=\"close\">\n      <property name=\"driverClassName\" value=\"com.ibm.db2.jcc.DB2Driver\"/>\n      <property name=\"url\" value=\"jdbc:db2://hndb02.bf.ctc.com:50002/activemq\"/>\n      <property name=\"username\" value=\"activemq\"/>\n      <property name=\"password\" value=\"activemq\"/>\n      <property name=\"maxActive\" value=\"200\"/>\n      <property name=\"poolPreparedStatements\" value=\"true\"/>\n</bean>\n\n```\n\n\n-----\n>本博文from 淮少吧 \n\n\n","mtime":1378965763000,"source":"_posts/mq3.md","_id":"wwmg4jsqtm40usd7"},{"content":"title: svn错误：SVN remains in conflict?\ndate: 2013-09-03 13:49:56\ntags: [技术]\ncategories: \n- svn\n---\n\n解决如下:\n\n```\nsvn remove --force yourfilename\nsvn resolve --accept=working  yourfilename\nsvn commit -m \"\"\n\n```","mtime":1378965763000,"source":"_posts/svn3.md","_id":"40onsvqu5n7aryx3"},{"content":"title: svn 版本恢复命令行操作（转）\ndate: 2013-09-03 13:51:18\ntags: [技术]\ncategories: \n- svn\n---\n\nsvn没有恢复旧版本的直接功能，不过可以使用svn merge命令恢复。\n比如说当前HEAD为14，而我要恢复成10版本，怎么做？用svn merge：\n<!-- more -->\n```\nsvn update\nsvn merge --revision 14:10\nsvn commit -m \"restore to revision 10\"\n\n```\n可能会很奇怪，因为不理解为什么合并能恢复旧版本。\n\n这里要理解一个关键点，就是svn merge的原理。merge是比较指定版本的差异，然后把这些差异应用到本地工作副本，而-r后的14:10，是指相对于版本14来说版本10的变化（注意，这个版本的次序很重要。），也就是相对版本14，我版本10添加了哪些文件或目录，以及哪些文件添加了哪些行删除了哪些行。\n\n由于在客户端提交应用程序时的误操作，导致修改了基线版本，此处利用两个命令来进行恢复：\n\n1. 将客户端恢复合并到指定版本：\n\n```\nsvn merge -r 112:111 svn://192.168.0.119/UBoot/trunk/u-boot-1.3.3\n\n```\n此步骤将下位机由112恢复到111版本：\n\n2. 重新修订基线版本\n\n```\nsvn commit -m \"Undoing change committed in r111.\"\n\n```\n此步骤将恢复后的111版本提交，但是此时的版本号为113","mtime":1378965763000,"source":"_posts/svn4.md","_id":"7wqi7ofl4pp586uc"},{"content":"title: svn  临时 切换用户 命令\ndate: 2013-09-03 13:56:11\ntags: [技术]\ncategories: \n- svn\n---\n作为team leader  有时候需要帮别人解决技术问题，尝尝再别人的电脑上改了某些代码，提交的时候遇到了问题，就是怎样临时用自己的账户提交，提交完后 用不影响同事的电脑原有的svn账号\n<!-- more -->\n\n下面的可以解决这个问题\n\n在所有命令下强制加上--username 和--password选项。 \n\n例如：\n\nl```\nsvn ci --username hufeng --password ####\n\n```\n","mtime":1378965763000,"source":"_posts/svn5.md","_id":"mwc9rel9n40prio6"},{"content":"title: svn 回退版本\ndate: 2013-09-03 14:02:35\ntags: [技术]\ncategories: \n- svn\n---\n```\nsvn merge -r rHEAD:4367 http://svnserver/svn/pingan/client/iPhone2/trunk/\n\n```\n本地回退\n\n```\nsvn ci -m \"提交\"\n\n```","mtime":1378965763000,"source":"_posts/svn6.md","_id":"nh58yq8wgeic5vts"},{"content":"title: 读 林锐博士的项目管理 笔记1\ndate: 2013-09-09 16:07:57\ntags: [技术]\ncategories: 项目管理\n---\n##软件挣钱难的问题\n\n<!-- more -->\n###一、承接合同项目，为甲方开发软件系统。\n\n1. 市场上能够承接到的合同项目，利润很小。而高利润的项目则被有权势的人或机构掌控。 \n\n2. 项目需求和验收受制于客户。开发过程中，客户会不断变更需求，导致开发方不断修改软件，项目验收被不断地延后，开发方成本（包括机会成本）越来越高。\n\n3. 缺乏规模复制效益。由于合同项目都是针对特定客户（甲方）的特定需求而签订的，即使做成功了一个合同项目，也很难“复制这个项目”直接卖给下一个客户。\n\n###二、开发并销售通用软件产品\n\n1. 凡是面向个人的通用软件产品，由于盗版原因，几乎无法靠卖软件来挣钱。\n\n2. 只有企业级软件产品不容易被大量盗版，可以走“通用软件产品盈利模式”，难度非常高。开发方必须把自己打造成为“企业级应用的领导者”，否则客户不信任你的方法和产品，产品就无法通用。于是客户提出的个性化需求越来越多，回到了“合同项目盈利模式”。 \n\n###三、运营模式\n\n1. 互联网公司的业务太容易被模仿，同质化竞争严重。每个领域都死掉了成千上万的相同业务的互联网公司，最终只有少数几家可以活下来，极大地浪费社会财富。\n\n2. 互联网公司的另一个大缺点是太浮躁，过分追求快而导致根基不扎实，国内绝大多数互联网公司的软件研发管理，要比传统软件公司混乱得多。\n\n---\n\n>软件企业要想多挣钱，靠“开源节流”。“开源”主要靠优化盈利模式，使得现有的技术和资源产生更高的效益。“节流”主要靠改进管理，使企业的所有经营环节更加合理，减少不必要的成本，省下来的钱也就成了利润","mtime":1378965763000,"source":"_posts/project0.md","_id":"svxhf755jhdy8lj1"},{"content":"title: MQ 笔记之 游标 及其游标优化\ndate: 2013-08-22 09:38:51\ntags: [技术]\ncategories: MQ\n---\n\n##概观 \n>在ActiveMQ的Broker中，光标用来持有一批在内存等待发送目标地址的消息。默认情况下这小消息被从存储器取出只想一个cursor(存储光标)  \n<!-- more -->\n5.0.0版本后，Activemq实现了一种新的内存模型来防止慢消费者阻塞快速生产者。通常消息在未消费或者发送后未收到消费者的确认信息时都会持久保存消息到存储中。当有消费者来消费消息时，broker会分页一批一批的从存储中取出消息，放入消息处理队列。游标就是指向下次批量获取消息时的存储位置。   \n\nctiveMQ有另一种游标实现，VM cursor，在某些情境下非常快。VM cursor是，进入的消息直接关联cursor，同时存储到消息存储器中。（关联cursor的同时存储到消息存储器中）。如果消费者（consumer）非常快，可以跟的上消息流的话，VM cursor会工作的非常好。但是，对于慢消费者，这个策略就不是那么有效了。VMcursor被积压的消息填满，同时它可能会去调用流控制去抑制producer生产message。\n\n##根据游标的保存方式不同，可分为三种类型：\n\n###Store-based cursors \nbroker默认采用的游标。它将游标信息保存在存储中。针对速度不同的消费者，这种游标机制采取的方式不同。对于快速消费者，因为消费速度很快，存储中 的消息数量会很少，所以不需要游标。这时，消息发送到broker时，先保存在持久存储中，然后直接发送给了消费者。而对于慢消费者，消息的持久存储中会 保存大量的消息，所以需要使用游标来指定下一次批量读取消息的位置。  \n\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v81y31hnj20ip04qaaj.jpg  Store-based实现原理图 300 200 %}\n **图一：**\n\n \t消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedHashMap，如果没有可用内存，则走路径2，当需要消息的时候，直接从消息存储的介质里每次读取一批消息，然后存入LinkedHashMap。\n\n### VM cursors \n若消费者能跟上生产者生产的速度，这时持久存储中消息虽然不是很多，但是若能也能在内存中保存一些游标，对获取存储中的消息的性能会有很大的提升。 \n那么VM Cursors在ActiveMQ4.x中是如何工作的呢？发送消息保存在内存中，并在需要的时候传递给调度队列。这可以是非常快的，但也有不利的一面，不能够处理非常缓慢的消费者或消费者已经很长一段时间处于非活动状态：   \n{%img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v878r0ahj20iu04tjrr.jpg  file实现原理图 300 200%}\n  **图二：**\n\n\t消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedList，如果没有可用内存，则走路径2，把消息写入临时文件中，当需要消息的时候，直接从临时文件中读写一批，然后送入LinkedList。\n\n\n### File-based cursors \n对VM cursors 的一种改进。当内存中的游标达到一定限额后，就会将一些游标存储到磁盘上的临时文件中。使用这种类型的游标时，消息储存可能会变慢，但消费者处理一般都会更快。通过缓冲到磁盘，它可以让消息代理来处理不受内存限制的大量消息，而生产者发送消息的速度会受到影响：\n **图三**\n\n {%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7v8airx6dj20it04sjrl.jpg vm 实现原理 300 200%}\n \t消息接收后，首先完成消息存储的工作，如(1)所示，然后直接把消息存放在内存中的LinkedList。\n\n\n###Paging for Non-Persistent Messages（非持久性的消息分页调度）\nStore based cursor也可以处理非持久性的消息，也就是没有存储在磁盘中的消息，非持久性消息被直接传递给游标，所以Store based cursor也只是嵌入了File based cursor的功能。\n\n\n## 3种消息cursor的比较\n消息cursor类型 | 性能 |稳定性 | 最佳使用场景\n---| --- | --- | --- |\nStore-based | 当内存不够时，需要进行1次消息存储操作，性能在3种方式中居中 | 最好 | activeMQ默认使用该cursor，因为它能满足大部分场景需要\nFile | 当内存不够时，需要进行2次消息存储操作，并且在删除消息的时候也就相应的要删除2次，性能在3种方式中最差 | 居中 | 主要用在当消息存储慢(如消息是放在数据库里)，并且消费者相对快的情况下\nVM | 在内存够的情况下，3种message cursor性能一样 | 最容易出现内存溢出的问题 | 很快，但不能处理慢消息消费者\n \n###基于存储的消息指针_测试结果\n\n测试方法 | 结果说明 | 是否通过 | 备注\n--- | --- | --- | --- |\n开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送,不接收，因为是默认的，所以不用在服务器端配置。 | 1．对于非持久化消息，一定数量之后，也会产生临时文件。 2．对于持久化的消息，则适用该方式的消息指针，直到达到磁盘空间的设置上限。 |  是 | \n\n###VM消息指针_测试结果\n\n测试方法 | 结果说明 | 是否通过 | 备注 \n--- | --- | --- | --- |\n开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：cursore 队列中存储到一定量消息的时候，broker不再接收生产者发送过来的消息，56W左右，broker也不报错，客户端也不报错。 |  是  | 若设置producerflowControl=false，则消息数量持续增长，直到broker报错：WARN  AMQMessageStore  - Message could not be added to long term store: Java heap space java.lang.OutOfMemoryError: Java heap space \n\n\n###基于文件的消息指针_测试结果\n\n测试方法 | 结果说明 | 是否通过 | 备注\n--- | --- | --- | --- |\n开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：fileQueueCursor | 一段时间之后，broker打印出一信息：INFO MonetStore - Monet Store using data directory \"C:\\Activemq 5.1\\bin\\..  \\data\\localhost\\tmp_storage\"  临时文件被放置在tmp_storage目录下 | 是 |\n \n \n \n\n \n \n \n \n\n\n-----------\n\n##Configuring Cursors\nActivemq默认使用store-based游标。当然也可为不同的Destination修改游标策略。通过修改destinationPolicy节点来更改默认配置。  \ndestinationPolicy节点包含多ge policyMap节点。  \npolicyMap包含一个policyEntries节点，policyEntries节点包含多个policyEntry 节点。policyEntry就是具体的一个游标策略了。  \nTopics的消费者分为持久订阅者和临时订阅者，所以有两套配置。Queues只有一类消费者，所以只有一套配置。\n对于持久订阅者可以使用PendingDurableSubscriberMessageStoragePolicy来指定游标策略。可配置的策略有vmDurableCursor和fileDurableSubscriberCursor. \n\n\n**对于临时订阅者可以使用pendingSubscriberPolicy 来指定。可配置的策略有vmCursor和fileCursor。下面是关于Topics的一些xml配置：**\n\n```\n<beans ... >\n<broker ...>\n    ...\n<destinationPolicy>\n<policyMap>\n<policyEntries>\n<policyEntrytopic=\"com.iona.>\">\n            ...\n<pendingSubscriberPolicy>\n<vmCursor/>\n</pendingSubscriberPolicy>\n<PendingDurableSubscriberMessageStoragePolicy>\n<fileDurableSubscriberPolicy/>\n</PendingDurableSubscriberMessageStoragePolicy>\n            ...\n</policyEntry>\n          ...\n</policyEntries>\n</policyMap>\n</destinationPolicy>\n    ...\n</broker>\n  ...\n</beans>\n\n```\n\n**Queues 同样也有vm和file两种类型的游标存储策略。pendingQueuePolicy 节点的可配置子节点有vmQueueCursor和fileQueueCursor**\n\n```\n<beans ... >\n<broker ...>\n        ...   \n<destinationPolicy>\n<policyMap>\n<policyEntries>\n<policyEntryqueue=\"com.iona.>\">  \n                ...   \n<pendingQueuePolicy>\n<vmQueueCursor/>\n</pendingQueuePolicy>\n                ...   \n</policyEntry>\n              ...   \n</policyEntries>\n</policyMap>\n</destinationPolicy>\n        ...   \n</broker>\n      ...   \n</beans>\n\n```\n\n\n### 配置vmcursor：\n下面配置了一个borker的所有topic和queue都使用了vmCursor\n\n```\n<broker ... >\n  ...\n  <destinationPolicy>\n    <policyMap>\n      <policyEntries>\n        <policyEntry topic=\">\">\n          <pendingSubscriberPolicy>\n            <vmCursor />\n          </pendingSubscriberPolicy>\n        </policyEntry>\n        <policyEntry queue=\">\">\n          <pendingSubscriberPolicy>\n            <vmCursor />\n          </pendingSubscriberPolicy>\n        </policyEntry>\n      </policyEntries>\n    </policyMap>\n  </destinationPolicy>\n  ...\n</broker>\n\n```\ntopic和queue都使用了通配符【>】,这个匹配所有的目标名称。你可以根据情况指定一些选择目标的模式。但是VM Cursor仅仅适用于那些消费者可以跟得上目标消息节奏的这种情况。\n\n\n-------\nhttp://www.cnblogs.com/kaka/archive/2012/07/24/2606699.html\nhttp://netcomm.iteye.com/blog/470585\n","mtime":1378965763000,"source":"_posts/mq4.md","_id":"t3xgdi0ote2opsja"},{"content":"title: MQ 笔记之 发送接受实例\ndate: 2013-08-23 10:27:45\ntags: [技术]\ncategories: MQ\n---\n> mq 支持多种发送格式  BytesMessage  MapMessage ObjectMessage TextMessage StreamMessage等\n<!-- more -->\n\n本文章以 MapMessage 和 ObjectMessage 为例\n\n**注意 发送ObjectMessage时  接受实例必须相同类名**\n\n\n##发送实例\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n\npublic class Send {\n\n\n public static void main(String[] args) throws Exception {\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n\n        Connection connection = connectionFactory.createConnection();\n        connection.start();\n\n        Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);\n        Destination destination = session.createQueue(\"hf\");\n\n        MessageProducer producer = session.createProducer(destination);\n       for(int i=0; i<3; i++) {\n//            MapMessage message = session.createMapMessage();\n//           message.setLong(\"count\", new Date().getTime());\n//            message.setObject(\"hf\",new SendData());\n      ObjectMessage message = session.createObjectMessage();\n      message.setObject(new SendData());\n//           message.setBytes(\"count\", getTestData(1));\n            Thread.sleep(1);\n            //通过消息生产者发出消息\n            producer.send(message);\n        }\n        session.commit();\n        session.close();\n        connection.close();\n    }\n}\n\n\n##接收实例\n\n```\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\npublic class Recive {\n\npublic static void main(String[] args) throws Exception {\n    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n\n    Connection connection = connectionFactory.createConnection();\n    connection.start();\n\n    final Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);\n    Destination destination = session.createQueue(\"hf\");\n\n    MessageConsumer consumer = session.createConsumer(destination);\n/*//listener 方式\nconsumer.setMessageListener(new MessageListener() {\n\n    public void onMessage(Message msg) {\n        MapMessage message = (MapMessage) msg;\n        //TODO something....\n        System.out.println(\"收到消息：\" + new Date(message.getLong(\"count\")));\n        session.commit();\n    }\n\n});\nThread.sleep(30000);\n\t*/\n\tint i=0;\n\twhile(i<100) {\n\ti++;\n\t//            MapMessage message = (MapMessage) consumer.receive();\n\tObjectMessage message = (ObjectMessage) consumer.receive();\n\n\tsession.commit();\n\n\t//TODO something....\n\t//             System.out.println(\"收到消息：\" + arrayToString(message.getBytes(\"count\")));\n\n\tSystem.out.println(\"收到消息：\" + ((SendData) message.getObject()).getDateStr());\n\t}\n\n\tsession.close();\n\tconnection.close();\n}\n\n//    public static final String arrayToString(byte[] bytes)\n//    {\n//        StringBuffer buff = new StringBuffer();\n//        for (int i = 0; i < bytes.length; i++)\n//        {\n//            buff.append(bytes[i] + \" \");\n//        }\n//        return buff.toString();\n//    }\n}\n\n```\n\n##传递参数\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * Created with IntelliJ IDEA.\n * User: jason\n * Date: 13-8-22\n * Time: 下午5:21\n * To change this template use File | Settings | File Templates.\n */\npublic class SendData  implements Serializable {\n\n//    private  static  final  long serialVersionUID = -23235245213533L;\n\n    private  byte[] buffer;\n\n    private String dateStr;\n\n    public SendData() {\n        setBuffer(null);\n        setDateStr(null);\n    }\n\n    public byte[] getBuffer() {\n        return buffer;\n    }\n\n    public String getDateStr() {\n        return dateStr;\n    }\n\n    public void setDateStr(String dateStr) {\n        this.dateStr = String.valueOf(new Date().getTime());\n    }\n\n    public void setBuffer(byte[] buffer) {\n        System.out.print(\"begin \\n\");\n        byte [ ] buffers = new byte[1024*1];\n        for (int i=0 ;  i< buffers.length ;i++)\n            buffers[i] = Byte.parseByte(\"2\");\n        System.out.print(\"end \\n\");\n        this.buffer = buffers;\n    }\n\n\n}\n\n","mtime":1378965763000,"source":"_posts/mq5.md","_id":"2bj90fc0fhepzr1l"},{"content":"title: svn 打 tag\ndate: 2013-09-03 14:04:29\ntags: [技术]\ncategories: \n- svn\n---\n```\nsvn cp . http://svnserver/svn/pingan/client/iPhone2/tags/appstore_v1.010_rc01  -m \"1.010\"\n\n```","mtime":1378965763000,"source":"_posts/svn7.md","_id":"r5gm92xzgjq3tuvm"},{"content":"title: svn错误local add incoming add upon merge\ndate: 2013-09-03 14:06:15\ntags: [技术]\ncategories: \n- svn\n---\n\n在svn命令行merge之后文件经常会出现local add, incoming add upon merge问题，导致无法提交，可以通过以下命令解决冲突 \nSummarizing to resolve the tree conflict committing your working dir with svn client 1.6.x you can use: \n<!-- more -->\n```\nsvn resolve --accept working -R . \n\n```\nwhere . is the directory in conflict.\n","mtime":1378965763000,"source":"_posts/svn8.md","_id":"lircvgtrd5vbhen7"},{"content":"title: 散文\ndate: 2013-08-08 10:29:16\ntags: 情感 \n---\n##浮华过后，心若沉浮浅笑安然\n生活或许是一件艺术品，需懂得欣赏，意中细品，学会经受。<!--more-->人生似一场追梦，那就是无数个美丽的梦而创造。人生常在繁华中等待，只不过每个人都在等待一个自己想要的未来。人生的迁徙，沉重着你的步履，有些感怀让你沉浸。曾让你迷失了方向，繁华落幕后，空山流水静其身，花开似无情，花落去留意，放眼望去，世间的喜悲离合聚散相依，匆匆如尘埃里的一颗沙粒，生命的深度，靠心去我体悟，生命的宽度，需魅力去赞颂。\n\n浮华沉寂陌生的城市，穿越年华的酸楚，风停了，雨骤了，心倦了，等待与思念的相互侵蚀，生命的前行，梦的边缘，思绪舞动一隅的嗔怨。行走的日光倾城，常伴有风的抚慰，雨的湿浸，山水的同路，莲的独隅，红尘碾转，自断不了纷争，待过忘川时，不过淡似轻风，花开催人老，纵马须恣意，清浅仲夏煮一壶清茶，待坐而品茗，静看花开花落，笑看云卷亦舒。\n\n今夕何夕，尘缘路上的回眸一笑，注定了浅笑安然。流年似水，生命的时光中，因为有缘相识，荒草丛生的原野上，没有早一步，晚一步，这就是缘。夏雨微凉，一袭雨过，岁月氤氲了一帘幽梦，芬芳轻盈着一执而念的光阴，生活缱绻起了风景，流年浮华过后，\"此情可待成追忆，只是当时已惘然\".\n\n心最柔软的地方，穿过了心刺的屏障，曾为一朵玫瑰而绽放，蜿蜒寂寞的藤，月光隐约着浪漫的惆怅，穿越横亘的流浪，时间煮雨，回忆终究会让年华淡泊，活着也许是一种修行，时光静好，品一茗清茶，落花无言，人淡如菊，润一份心境，携一缕阳光，让芳华依旧绽放。字里行间的缠绵，泪痕迭起了四季的轮回，愿得一个人，白守不分离，铺满诗意的路径，夜如此静谧，带伤的诗句常娇嗔着粉饰，步伐太急，却忘了缓缓停下来让心安祥。\n\n山与水的缠绵，任流音乐的浮想，清寂时常敲碎夜的散漫，凄迷的烟雨里，水滴的顺势而滑，水声伴风雨的飘渺芳飞，无垠的夜空，静静的聆听，繁琐打搅，细密的疏雨，意境的恰入，飘散的雨滴，透过肌肤直抵心深处，奈何雨的朦胧，相思成林泪千行。无情的冷风常拔弄着心弦，溅湿的思愁，陌路的不在相见，这个季，风儿依柔，雨儿心醉，满目的寒殇，素色时光的轻狂，喧哗背后的沉静，简单的真谛，心若沉浮，此事不关山与月。\n\n浮华掠影后，静静的听雨，感风的倾诉，世界太喧闹，已至于背离了自己，沉静中的超脱，不常泛滥，无意的碰触，深知心里的冬天时常接伴，甚至盛夏炎炎，那份落韵的雪，也会勾画着伤感的景致。卑微轻触着虚无，平淡晕染着凄冷。如若没有那么多牵扯，也不会有那么多眷念，不用去刻意与深究，这个世界本就复杂，盼一份温暖，守一份静染，只愿在高山流水间吟诵，世间最难识是情，最难诉的是痴。\n\n生命总有尽头，心灵总需要出口，每个人身上都有一把锁，有人说寂寞是种狂欢，但真正的寂寞是无法用热闹来填埋，只有你为心灵找到了决口，上锁的心慢慢绽放，才能真正的释怀，人之所以挣扎与纠结，是把钥匙丢了，但希望总在远方起航心若沉浮，浅笑安然。\n\n\n<!-- ![](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg)-->\n<!-- {% img http://placekitten.com/890/280 %}-->\n{% img right http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg 300 400 壮壮 %}\n<!-- {% img right http://placekitten.com/300/500 150 250 Place Kitten #3 %}\n{% img right http://placekitten.com/300/500 150 250 'Place Kitten #4' 'An image of a very cute kitten' %} -->\n\n\n","mtime":1378965763000,"source":"_posts/散文.md","_id":"jowvh7q2lp3ghipn"},{"content":"title: svn命令总结\ndate: 2013-09-03 14:08:30\ntags: [技术]\ncategories: \n- svn\n---\n\n##1. 创建分支\nsvn cp http://svn.trunk/ http://svn.branches/  –m “create a branch”\n<!-- more -->\n##2. 合并分支\n\n###1、在某个branch里合并trunk上的修改，\n进入分支目录，然后执行：\n\n```\nsvn merge http://svn/repo/trunk\n\n```\n###2、在trunk上合并branch的修改。\n进入trunk目录，然后执行\n\n```\nsvn merge --reintegrate http://svn/repo/branches/branch1\n\n```\n##3. 将文件checkout到本地目录\n\nsvn checkout path（path是服务器上的目录）\n```\n例如：svn checkout svn://192.168.1.1/pro/domain\n简写：svn co\n\n```\n\n##4. 往版本库中添加新的文件\n\nsvn add file\n```\n例如：svn addtest.php(添加test.php)\nsvn add *.php(添加当前目录下所有的php文件)\n```\n\n##5. 将改动的文件提交到版本库\nsvn commit -m “LogMessage“ [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)\n\n```\n例如：svn commit -m “add test file for my test“ test.php\n简写：svn ci\n```\n\n##6. 加锁/解锁\n\nsvn lock -m “LockMessage“ [--force] PATH\n\n```\n例如：svn lock -m “lock test file“ test.php\nsvn unlock PATH\n```\n\n##7. 更新到某个版本\n\nsvn update -r m path\n\n例如：\n```\nsvn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。\nsvn update -r 200 test.php(将版本库中的文件test.php还原到版本200)\nsvn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)\n```\n\n简写：svn up\n\n##8.查看文件或者目录状态\n\n1. svn status path（目录下的文件和子目录的状态，正常状态不显示）\n\n【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】\n\n2. svn status -v path(显示文件和子目录状态)\n第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。  \n**注：** svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。\n简写：svn st\n\n##9.删除文件\n\nsvn delete path -m “delete test fle“\n\n例如：\n```\nsvn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”\n或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，\n```\n\n推荐使用这种简写：svn (del, remove, rm)\n\n##10.查看日志\n\nsvn log path\n例如：\n```\nsvn log test.php 显示这个文件的所有修改记录，及其版本号的变化\n```\n\n##11.查看文件详细信息\n\nsvn info path\n\n例如：\n```\nsvn info test.php\n```\n\n##12.比较差异\nsvn diff path(将修改的文件与基础版本比较)\n\n例如：\n```\nsvn diff test.php\n```\nsvn diff -r m:n path(对版本m和版本n比较差异)\n\n例如：\n```\nsvn diff -r 200:201 test.php\n```\n简写：svn di\n\n##13.将两个版本之间的差异合并到当前文件\nsvn merge -r m:n path\n例如：\n```\nsvn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）\n```\n##14.SVN 帮助\nsvn help  \nsvn help ci  \n\n##15.版本库下的文件和目录列表\n\nsvn list path\n显示path目录下的所有属于版本库的文件和目录  \n简写：svn ls\n        \n##16.创建纳入版本控制下的新目录\nsvn mkdir: 创建纳入版本控制下的新目录。\n\n用法: \n\n1. mkdir PATH…\n2. mkdir URL…\n\n创建版本控制的目录。\n\n1. 每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。\n2. 每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。\n\n##17.恢复本地修改\nsvn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:  \n用法: revert PATH…  \n注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录\n        \n##18.代码库URL变更\n\nsvn switch (sw): 更新工作副本至不同的URL。\n\n用法: \n\n1. switch URL [PATH]\n2. switch –relocate FROM TO [PATH...]\n\n  * 更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。\n\n  * 改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。\n \n##19.解决冲突\n\nsvn resolved: 移除工作副本的目录或文件的“冲突”状态。 \n\n用法: resolved PATH…\n\n**注意:** 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的\n相关文件，然后让 PATH 可以再次提交。\n         \n##20.输出指定文件或URL的内容。\n\nsvn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。  \n\nsvn cat -r PREV filename > filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)  \n\n\n","mtime":1378965763000,"source":"_posts/svn9.md","_id":"rnk6ucw6rn5o7oig"},{"content":"title: New Page\ndate: 2013-08-04 18:24:33\n---\n","mtime":1378965763000,"source":"new-page/index.md","_id":"0eunuqrq0h8018hh"},{"content":"title: ios开发--block应该知道的那几件事\ndate: 2013-09-11 23:32:18\ntags: [技术]\ncategories: ios\n---\nblock 现在已经基本上已经使用非常普遍了,在引用中也又很多坑,下面把block开发中应该知道的那几件事总结下.\n<!-- more -->\n##:内联(inline)Block\n>内联block 说白了就是block被嵌入到一个函数中 \n例如:\n\n**typedef void (^HelloBlock)(void);**\n```\n- (void) BlockTest{\nHelloBlock myBlock= ^(void){\nNSLog(@\"Hello Block\");\n};\nmyBlock();\n}\n\n```\n\n##注意事项\n\n###1.内联的block中内部定义的变量 自己本身有读写权限\n\n###2.block内部要修改外部变量 需要将外部变量声明__block\n\n###3.Block retain是无效的，要想保留block生命周期，可以通过copy来实现，记得release\n\n###4.被block的应用的对象，retainCount会自动加一，为了打破这种 retain circle，可以在对象前加__block，这样block块就不会维护这个对象了\n\n 下面的写法如果不加上_block a无法dealloc\n\n```\n\n__block A  a =[ [[A alloc] init] withBlock:^{\n\n [a action];\n\n [ a release];\n\n}]; //这样A的dealloc方法就会调用\n\n```\n\n```\n\n@interface ViewController ： UIViewViewController \n {\n        NSString *_string;\n }\n\n __block ViewController *controller = self;   \n    _block = ^{\n         NSLog(@\"string %@\",controller->_string);\n    };\n\n```\n###5.在独立的block中不能引用self，如果需要访问可以使用参数传递的方法(可以把其考虑成c+中参数传入函数指针对应copy)**\n\n###6.不要随便用.语法\n\n```\n#import <UIKit/UIKit.h>   \n@interface AppDelegate : NSObject <UIApplicationDelegate>\n@property (nonatomic, strong) NSString *stringProperty;  \n@end  \n\n```\n\n```\n#import \"GCDAppDelegate.h\" \n@implementation AppDelegate \n@synthesize stringProperty;  \n- (void) BlockTestError{\nHelloBlock myBlock= ^(void){\n\tself.stringProperty = @\"Block Objects\"; \n\tNSLog(@\"String property = %@\", self.stringProperty);//运行错误\n};\nmyBlock();\n}}  \n\n- (void) BlockTestCorrect{\n\tHelloBlock myBlock= ^(void){\n\t\t[self setStringProperty:@\"Block Objects\"];\n\t    NSLog(@\"self.stringProperty = %@\", [self stringProperty]); //运行ok\n\t};\nmyBlock();\n}}  \n@end  \n```\n\n\n\n\n\n","mtime":1378965763000,"source":"_posts/ios22.md","_id":"oo4ci6l59l2xswfy"}],"posts":{"1":{"id":0,"title":"How to get the color of a pixel in an UIView?","date":"2013-09-03T08:33:35.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>记得一年前做招行掌上生活M+的时候 其中有个需求是画一画功能，就是在地图上用手指画个圈 然后得到这个圈里面所有指定商户。\n当时为了精度 除了利用 </p>\n<figure class=\"highlight\"><pre><span class=\"built_in\">BOOL</span> mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView<span class=\"variable\">.path</span>, <span class=\"literal\">NULL</span>, polygonViewPoint, <span class=\"literal\">NO</span>);\n</pre></figure>\n\n<p>来验证此点是否在画的区域内 同时为了精度 还用到了点位的颜色色值进行校验。</p>\n<p>无法把全部代码给出 下面把 如何得到uiview 某点的函数给出</p>\n<p> UIView+ColorOfPoint.h</p>\n<figure class=\"highlight\"><pre>@<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UIView</span> (<span class=\"title\">ColorOfPoint</span>)\n- (<span class=\"title\">UIColor</span> *) <span class=\"title\">colorOfPoint</span>:(<span class=\"title\">CGPoint</span>)<span class=\"title\">point</span>;\n@<span class=\"title\">end</span>\n</pre></figure>\n\n<p> UIView+ColorOfPoint.m</p>\n<figure class=\"highlight\"><pre><span class=\"preprocessor\">#import <span class=\"title\">\"UIView+ColorOfPoint.h\"</span></span>\n<span class=\"preprocessor\">#import <span class=\"title\">&lt;QuartzCore/QuartzCore.h&gt;</span></span>\n\n@<span class=\"class\"><span class=\"keyword\">implementation</span> <span class=\"id\">UIView</span> (<span class=\"id\">ColorOfPoint</span>)</span>\n\n- (<span class=\"built_in\">UIColor</span> *) colorOfPoint:(<span class=\"built_in\">CGPoint</span>)point\n{\n    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> pixel[<span class=\"number\">4</span>] = {<span class=\"number\">0</span>};\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    CGContextRef context = CGBitmapContextCreate(pixel, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>, <span class=\"number\">4</span>, colorSpace, kCGImageAlphaPremultipliedLast);\n\n    CGContextTranslateCTM(context, -point<span class=\"variable\">.x</span>, -point<span class=\"variable\">.y</span>);\n\n    [<span class=\"keyword\">self</span><span class=\"variable\">.layer</span> renderInContext:context];\n\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n\n    <span class=\"comment\">//NSLog(@\"pixel: %d %d %d %d\", pixel[0], pixel[1], pixel[2], pixel[3]);</span>\n\n    <span class=\"built_in\">UIColor</span> *color = [<span class=\"built_in\">UIColor</span> colorWithRed:pixel[<span class=\"number\">0</span>]/<span class=\"number\">255.0</span> green:pixel[<span class=\"number\">1</span>]/<span class=\"number\">255.0</span> blue:pixel[<span class=\"number\">2</span>]/<span class=\"number\">255.0</span> alpha:pixel[<span class=\"number\">3</span>]/<span class=\"number\">255.0</span>];\n\n    <span class=\"keyword\">return</span> color;\n}\n</pre></figure>\n\n<p>@end</p>\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg\" class=\"center\" width=\"300\" height=\"600\" title=\"模拟器\">\n","excerpt":0,"source":"_posts/22.md","slug":"22","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"2":{"id":0,"title":"判断地图坐标是否在区域内","date":"2013-09-03T08:51:48.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>此方法与前一篇文章中的得到UIView某点的色值达到的效果一直，通常为了保持精度 两个方法一起使用。</p>\n</blockquote>\n<p><a name=\"more\"></a></p>\n<figure class=\"highlight\"><pre>-(<span class=\"keyword\">IBAction</span>)foundTap:(UITapGestureRecognizer *)recognizer\n{\n    <span class=\"built_in\">CGPoint</span> point = [recognizer locationInView:<span class=\"keyword\">self</span><span class=\"variable\">.mapView</span>];\n\n    CLLocationCoordinate2D tapPoint = [<span class=\"keyword\">self</span><span class=\"variable\">.mapView</span> convertPoint:point toCoordinateFromView:<span class=\"keyword\">self</span><span class=\"variable\">.view</span>];\n\n    [<span class=\"keyword\">self</span> pointInsideOverlay:tapPoint];\n\n    <span class=\"keyword\">if</span> (isInside) \n     {\n       ....\n     }\n}\n</pre></figure>\n\n<p>Here is a method to call from the previous to check if the point is inside the overlay:</p>\n<figure class=\"highlight\"><pre>-(<span class=\"keyword\">void</span>)pointInsideOverlay:(CLLocationCoordinate2D )tapPoint \n{\n    isInside = <span class=\"literal\">FALSE</span>; \n\n    MKPolygonView *polygonView = (MKPolygonView *)[mapView viewForOverlay:polygonOverlay];\n\n    MKMapPoint mapPoint = MKMapPointForCoordinate(tapPoint);\n\n    <span class=\"built_in\">CGPoint</span> polygonViewPoint = [polygonView pointForMapPoint:mapPoint];\n\n    <span class=\"built_in\">BOOL</span> mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView<span class=\"variable\">.path</span>, <span class=\"literal\">NULL</span>, polygonViewPoint, <span class=\"literal\">NO</span>);\n\n        <span class=\"keyword\">if</span> ( !mapCoordinateIsInPolygon )\n\n            <span class=\"comment\">//we are finding points that are inside the overlay</span>\n        {\n            isInside = <span class=\"literal\">TRUE</span>;\n        }\n}\n</pre></figure>\n\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg\" class=\"center\" width=\"300\" height=\"600\">\n","excerpt":88,"source":"_posts/23.md","slug":"23","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"3":{"id":0,"title":"git系类教程之 找出最懒的程序员","date":"2013-09-03T03:19:34.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>场景假设:⼀一个开发⼩小组有10个程序员,他们⽤用 Git 做版本控制,某⼀一天程序员A push了当天的⼏几个 commit之后,突然在想“我在这个项⺫⽬目到底⼀一共进⾏行过多少次commit?谁⽐比我commit更多?多多少?谁是 组⾥里⾯面进⾏行最多commit的?谁是最少的?”\n<a name=\"more\"></a></p>\n</blockquote>\n<p>Git ⾮非常⼈人性化地⽀支持这样⼀一个命令:$ git shortlog\n这个命令会返回这个 git repository 底下每个⽤用户进⾏行 commit 的次数,以及每次 commit 的注释。 -s 参数省略每次 commit 的注释,仅仅返回⼀一个简单的统计。\n-n 参数按照 commit 数量从多到少的顺利对⽤用户进⾏行排序</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">shortlog</span> <span class=\"literal\">-</span><span class=\"comment\">s</span> <span class=\"literal\">-</span><span class=\"comment\">n</span>\n  <span class=\"comment\">135</span>  <span class=\"comment\">Tom</span> <span class=\"comment\">Preston</span>-<span class=\"comment\">Werner</span>\n  <span class=\"comment\">6</span>  <span class=\"comment\">remi</span>\n  <span class=\"comment\">3</span>  <span class=\"comment\">Mikael</span> <span class=\"comment\">Lind</span>\n  <span class=\"comment\">3</span>  <span class=\"comment\">Toby</span> <span class=\"comment\">DiPasquale</span>\n  <span class=\"comment\">2</span>  <span class=\"comment\">Aristotle</span> <span class=\"comment\">Pagaltzis</span>\n  <span class=\"comment\">2</span>  <span class=\"comment\">Basil</span> <span class=\"comment\">Shkara</span>\n  <span class=\"comment\">1</span>  <span class=\"comment\">Marc</span> <span class=\"comment\">Chung</span>\n  <span class=\"comment\">1</span>  <span class=\"comment\">Nick</span> <span class=\"comment\">Gerakines\n</pre></figure>\n\n","excerpt":160,"source":"_posts/git10.md","slug":"git10","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"4":{"id":0,"title":"ios 笔记之 内购","date":"2013-08-21T01:18:13.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>昨晚同事拿了一个app 发现其app 内部页面打开了appstore  并没有唤起手机自带的appstore， 刚开始以为是用webview 加载的\n<a name=\"more\"></a> ，可是自己些了一个demo 发现并不是那样一回事 用webview 加载appstore 地址 会被js 自动吊起本地的appstore，\n下面是我的发给同事的邮件 直接贴下来</p>\n</blockquote>\n<p>我们都绕了弯路 一直以为是用webview 加载的。 我下班做了测试 发现用webview 加载appstore的地址 ，ios 会根据User-Agent 自动判断 唤起本地的app store，其效果跟用[[UIApplicationsharedApplication] openURL:[NSURL URLWithString:@&quot;&quot;]];是一样的。</p>\n<p>后来我尝试改写User-Agent  发现打开的页面是电脑打开的页面一样的 并不是我们通过手机 打开app store 看到的页面。</p>\n<p>后来我看苹果的文档 发现 他们提供了一个类SKStoreProductViewController专门来干这个事情的</p>\n<p><a href=\"https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html\"><a href=\"https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html\">https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html</a></a></p>\n<p>实现效果如下图</p>\n<img src=\"http://ww4.sinaimg.cn/mw690/a43af4ffjw1e7u10xs9nwj20m015c0x9.jpg\" class=\"center\" width=\"250\" height=\"600\">\n\n\n<h2>下面是关键代码</h2>\n<figure class=\"highlight\"><pre>需要引入的\n<span class=\"preprocessor\">#import &lt;StoreKit/StoreKit.h&gt;</span>\n<span class=\"class\"><span class=\"keyword\">delegate</span> 为<span class=\"title\">SKStoreProductViewControllerDelegate</span>\n\n\n调用方式\n    [<span class=\"title\">self</span> <span class=\"title\">openAppWithIdentifier</span>:@\"592043421\"];\n\n\n\n#<span class=\"title\">pragma</span> <span class=\"title\">mark</span> - <span class=\"title\">SKStoreProductViewControllerDelegate</span>\n- (<span class=\"title\">void</span>)<span class=\"title\">productViewControllerDidFinish</span>:(<span class=\"title\">SKStoreProductViewController</span> *)<span class=\"title\">viewController</span> {</span>\n    [viewController dismissViewControllerAnimated:YES completion:^{\n    }];\n}\n\n\n\n\n\n\n- (<span class=\"keyword\">void</span>)openAppWithIdentifier:(NSString *)appId {\n    SKStoreProductViewController *storeProductVC = [[SKStoreProductViewController alloc] init];\n    storeProductVC.<span class=\"class\"><span class=\"keyword\">delegate</span> = <span class=\"title\">self</span>;\n    \n    <span class=\"title\">NSDictionary</span> *<span class=\"title\">dict</span> = [<span class=\"title\">NSDictionary</span> <span class=\"title\">dictionaryWithObject</span>:<span class=\"title\">appId</span> <span class=\"title\">forKey</span>:<span class=\"title\">SKStoreProductParameterITunesItemIdentifier</span>];\n    [<span class=\"title\">storeProductVC</span> <span class=\"title\">loadProductWithParameters</span>:<span class=\"title\">dict</span> <span class=\"title\">completionBlock</span>:^(<span class=\"title\">BOOL</span> <span class=\"title\">result</span>, <span class=\"title\">NSError</span> *<span class=\"title\">error</span>) {</span>\n        if (result) {\n            [self presentViewController:storeProductVC animated:YES completion:nil];\n        }\n    }];\n}\n</pre></figure>\n\n","excerpt":91,"source":"_posts/appstore.md","slug":"appstore","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"5":{"id":0,"title":"git错误 fatal: remote origin already exists.","date":"2013-09-03T05:37:59.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>当执行 git remote addorigin git@github.com:hufeng825/test.git</p>\n</blockquote>\n<p>错误提示：fatal: remote origin already exists.\n<a name=\"more\"></a>\n解决办法</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git remote rm origin\n</pre></figure>\n\n","excerpt":138,"source":"_posts/git11.md","slug":"git11","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"6":{"id":0,"title":"git错误 git rebase master First, rewinding head to replay your work on top of it... error: The following unt","date":"2013-09-03T05:39:50.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>git rebase master\nFirst, rewinding head to replay your work on top of it...\nerror: The following untracked working tree files would be overwritten by checkout:\n<a name=\"more\"></a>\nHFFrame.xcodeproj/project.xcworkspace/xcuserdata/apple.xcuserdatad/UserInterfaceState.xcuserstate\nPlease move or remove them before you can switch branches.\nAborting\ncould not detach HEAD</p>\n<p>执行</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">~/Desktop/HFFrame(example)</span> <span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">clean</span> <span class=\"literal\">-</span><span class=\"comment\">d</span> <span class=\"literal\">-</span><span class=\"comment\">fx</span> <span class=\"comment\">\"\"\n</pre></figure>\n\n","excerpt":163,"source":"_posts/git12.md","slug":"git12","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"7":{"id":0,"title":"mac 开发 git svn 应该添加那些忽略列表","date":"2013-09-03T05:45:11.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2,3],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>如题，git svn 应该添加那些忽略列表?\n<a name=\"more\"></a></p>\n</blockquote>\n<ol>\n<li>.DS_Store</li>\n<li>build</li>\n<li>*~.nib</li>\n<li>*.so</li>\n<li>*.pbxuser</li>\n<li>*.mode</li>\n<li><em>.perspective</em></li>\n</ol>\n","excerpt":39,"source":"_posts/git13.md","slug":"git13","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"8":{"id":0,"title":"git 系类教程之 log显示","date":"2013-09-02T09:59:59.000Z","updated":"2013-09-09T15:47:36.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>查看log是程序员常用的操作之一,不要以为一个git log了事,下面介绍下git log 的高级操作.\n<a name=\"more\"></a></p>\n<ol>\n<li><p>显示所有提交记录的包括提交时间 提交人员联系方式等等: git log</p>\n</li>\n<li><p>显示所有提交记录 只显示提交信息: git shortlog</p>\n</li>\n<li><p>显⽰示版本历史,以及版本间的内容差异:git log -p</p>\n</li>\n<li><p>只显⽰示最近⼀一次提交:git log -1</p>\n</li>\n<li><p>显⽰示最近的20个提交:以及版本间的内容差异:git log -20 -p</p>\n</li>\n<li><p>显⽰示最近6⼩小时的提交:git log --since=&quot;6 hours&quot;</p>\n</li>\n<li><p>显⽰示两天之前的提交:git log --before=&quot;2 days&quot;</p>\n</li>\n</ol>\n","excerpt":56,"source":"_posts/git2.md","slug":"git2","ctime":"2013-09-09T15:47:36.000Z","mtime":"2013-09-09T15:47:36.000Z"},"9":{"id":0,"title":"git 系列教程之 提交信息的后悔药 修改提交信息","date":"2013-09-02T10:06:42.000Z","updated":"2013-09-09T14:28:08.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>有没有提交过&quot;修改bug&quot; &quot;上传代码&quot; 等等类似脑残的提交信息. code review 时看到这样的提交信息 每个team leader 肯定不会容忍的. 下面要介绍的是如何修改之前提交的历史信息\n<a name=\"more\"></a></p>\n<h2>方法一 可以修改最后一次 commit</h2>\n<pre><code><figure class=\"highlight\"><pre> <span class=\"comment\">git</span> <span class=\"comment\">commit</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">amend</span> \n</pre></figure></code></pre>\n<hr>\n<h2>方法二 交互式修改</h2>\n<h3>步骤一</h3>\n<pre><code><figure class=\"highlight\"><pre>git rebase -i master~<span class=\"number\">1</span> <span class=\"comment\">//最</span>\ngit rebase -i master~<span class=\"number\">5</span> <span class=\"comment\">//最后五次</span>\n</pre></figure></code></pre>\n<h3>步骤二</h3>\n<p> // 显示结果如下，修改 pick 为 edit ，并 :wq 保存退出\n     pick 91b495b 2012-01-08: &quot;提交信息内容&quot;</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"preprocessor\"># Rebase 9ef2b1f..91b495b onto 9ef2b1f</span>\n<span class=\"preprocessor\">#</span>\n<span class=\"preprocessor\"># Commands:</span>\n<span class=\"preprocessor\">#  pick = use commit</span>\n<span class=\"preprocessor\">#  edit = use commit, but stop for amending //改上面的 pick 为 edit</span>\n<span class=\"preprocessor\">#  squash = use commit, but meld into previous commit</span>\n<span class=\"preprocessor\">#</span>\n<span class=\"preprocessor\"># If you remove a line here THAT COMMIT WILL BE LOST.</span>\n<span class=\"preprocessor\"># However, if you remove everything, the rebase will be aborted.</span>\n<span class=\"preprocessor\">#</span>\n</pre></figure></code></pre>\n<h3>步骤三</h3>\n<p> 使用</p>\n<pre><code><figure class=\"highlight\"><pre>git rebase --<span class=\"keyword\">continue</span> <span class=\"comment\">//完成操作</span>\n</pre></figure></code></pre>\n","excerpt":124,"source":"_posts/git3.md","slug":"git3","ctime":"2013-09-09T14:28:08.000Z","mtime":"2013-09-09T14:28:08.000Z"},"10":{"id":0,"title":"git 系类教程之 懂的这些配置能让git 更好用","date":"2013-09-02T10:16:59.000Z","updated":"2013-09-09T14:36:47.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>是不是抱怨git操作太过于复杂,是不是想要让log 更加漂亮 是不是想要让git 跟svn 一样支持st ci 等等这样的缩写命令……\n<a name=\"more\"></a>\n下面的这些配置能够满足你.</p>\n<p>打开终端 执行</p>\n<figure class=\"highlight\"><pre><span class=\"title\">cd</span>\n<span class=\"title\">vi</span> .git/.gitconfig\n</pre></figure>\n\n<p>然后修改gitconfig</p>\n<figure class=\"highlight\"><pre><span class=\"title\">[</span><span class=\"comment\">alias</span>]\n  <span class=\"comment\">logs</span> <span class=\"comment\">=</span> <span class=\"comment\">log</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">color</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">graph</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">pretty=format:'%Cred%h%Creset</span> <span class=\"literal\">-</span><span class=\"comment\">%C(yellow)%d%Creset</span> <span class=\"comment\">%s</span> <span class=\"comment\">%Cgreen(%cr)</span> <span class=\"comment\">%C(bold</span> <span class=\"comment\">blue)</span>&lt;<span class=\"comment\">%an</span>&gt;<span class=\"comment\">%Creset'</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">abbrev</span>-<span class=\"comment\">commit</span>\n  <span class=\"comment\">st</span> <span class=\"comment\">=</span> <span class=\"comment\">status</span>\n  <span class=\"comment\">ci</span> <span class=\"comment\">=</span> <span class=\"comment\">commit</span>\n  <span class=\"comment\">br</span> <span class=\"comment\">=</span> <span class=\"comment\">branch</span>\n  <span class=\"comment\">co</span> <span class=\"comment\">=</span> <span class=\"comment\">checkout</span>\n  <span class=\"comment\">df</span> <span class=\"comment\">=</span> <span class=\"comment\">diff</span>\n  <span class=\"comment\">lg</span> <span class=\"comment\">=</span> <span class=\"comment\">log</span> <span class=\"literal\">-</span><span class=\"comment\">p\n</pre></figure>\n\n<p>如果想要把 rebase 當做 git pull 的預設值，可以在專在 .gitconfig 加上</p>\n<figure class=\"highlight\"><pre>\n[branch <span class=\"string\">\"master\"</span>]\n  remote = origin\n  merge = refs<span class=\"regexp\">/heads/m</span>aster\n  rebase = <span class=\"literal\">true</span>\n</pre></figure>\n\n<p>也可以直接加到 ~/.gitconfig 讓所有的 tracked branches 都自動套用這個設定：</p>\n<figure class=\"highlight\"><pre><span class=\"matrix\">[branch]</span>  \n\tautosetuprebase = always\n</pre></figure>\n\n","excerpt":71,"source":"_posts/git4.md","slug":"git4","ctime":"2013-09-09T14:36:47.000Z","mtime":"2013-09-09T14:36:47.000Z"},"11":{"id":0,"title":"git系列教程之 修改远程仓库地址 modify remote url","date":"2013-09-03T01:50:37.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>某天突然IT部门告之服务器要换地址了，本地有clone出来的git厍，则需要修改一下origin的地址，以便能继续push和pull，方法是，在命令行项目所在目录下执行：\n<a name=\"more\"></a>\n    git remote set-url origin 新地址</p>\n","excerpt":89,"source":"_posts/git5.md","slug":"git5","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"12":{"id":0,"title":"git系类教程之 获取指定分支指定文件的更新","date":"2013-09-03T02:03:50.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>多分支并行时，主干A 想要获取某分支上的某个文件的更新，但是并不像merge 这个分支，如图</p>\n<img src=\"http://ww4.sinaimg.cn/mw690/a43af4ffjw1e89338drs8j20ib0g4abh.jpg\" class=\"center\" width=\"150\" height=\"200\">\n\n<a name=\"more\"></a>\n\n<figure class=\"highlight\"><pre><span class=\"title\">git</span> checkout 指定分支 指定文件\n\n<span class=\"title\">git</span> checkout breanchA <span class=\"type\">HFFrame</span>/<span class=\"type\">Global</span>/<span class=\"type\">Global_macro</span>.h\n</pre></figure>\n\n","excerpt":172,"source":"_posts/git6.md","slug":"git6","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"13":{"id":0,"title":"git系类教程之 指定公钥","date":"2013-09-03T02:13:04.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>如果本地有多个公钥 如何对git 进行指定用哪个公钥呢？\n<a name=\"more\"></a></p>\n<figure class=\"highlight\"><pre>vi .git/config \n\n\n[core]\n\n       repositoryformatversion = <span class=\"number\">0</span>\n\n       filemode = <span class=\"literal\">true</span>\n\n       bare = <span class=\"literal\">false</span>\n\n       logallrefupdates = <span class=\"literal\">true</span>\n\n       ignorecase = <span class=\"literal\">true</span>\n\n[remote <span class=\"string\">\"origin\"</span>]\n\n       fetch = +refs<span class=\"regexp\">/heads/*:refs/remotes/origin/</span>*\n\n       url = ssh:<span class=\"regexp\">//</span>dev<span class=\"property\">@nav</span>.fun-guide.mobi:<span class=\"number\">6521</span><span class=\"regexp\">/home/dev/git/</span>cmb.git\n\n[branch <span class=\"string\">\"master\"</span>]\n\n       remote = origin\n\n       merge = refs<span class=\"regexp\">/heads/m</span>aster\n\n[branch <span class=\"string\">\"cmb-dingcan\"</span>]\n\n       remote = origin\n\n       merge = refs<span class=\"regexp\">/heads/</span>cmb-dingcan\n\n~                                                                               \n\n\n\nHost git.magus-soft.com\n\nHostName git.magus-soft.com\n\nPort <span class=\"number\">6521</span>\n\nUser git\n\nIdentityFile ~<span class=\"regexp\">/.ssh/i</span>phone_git\n\n~                                                                                 \n\n\n\n／.ssh/config\n</pre></figure>\n\n","excerpt":32,"source":"_posts/git7.md","slug":"git7","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"14":{"id":0,"title":"git系类教程之 综合篇","date":"2013-09-03T02:18:19.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2],"tags":[1],"comments":true,"layout":"post","content":"<p>不敢说这是git常用操作最全的教程，这是本人再前人的基础上加上应用了三年多git总结的，应该是比较全的，后续我还会把git 常见的错误总结出来。\n<a name=\"more\"></a></p>\n<h2>git基本工作流程</h2>\n<p>git支持很多种不同的工作流程，我们采用的是与SVN接近的模拟中央服务器流程。即，有一个公用的代码库放在服务器上，开发者从这个共享的服务器克隆后，在本地开发，然后提交到服务器，并且从服务器获取其他用户提交的内容。</p>\n<p><strong>注意</strong> git是分布式的代码控制系统，所以每个代码库都是平等的，这里只是在逻辑上划分了一个中央服务器而已，在物理结构上，中央代码库与本地代码库没有什么不同。\n[编辑]创建帐号\ngit可以使用多种协议在代码库之间通信。我们目前采用ssh协议，需要用户在服务器上有一个ssh帐号才能访问代码库。用户需要在本机创建一个ssh密钥对，把公钥发给管理员，密钥保存在自己本机。这样，就可以使用密钥连接服务器。</p>\n<h2>开始工作</h2>\n<p>开始工作之前，需要复制一套中央服务器的代码库：</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git clone /server/repo/project\n</pre></figure>\n\n<h3>本地修改和提交</h3>\n<p>git的提交操作是在本地完成的，不需要网络连接。</p>\n<figure class=\"highlight\"><pre>$ git checkout branch\n--- 编辑现有文件或者添加新文件 <span class=\"keyword\">...</span>\n</pre></figure>\n\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">add</span> <span class=\"comment\">newfile</span>\n<span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">commit</span> <span class=\"literal\">-</span><span class=\"comment\">a</span>\n<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">填写此次提交的备注\n</pre></figure>\n\n<h3>从中央服务器获取其他人的更新</h3>\n<p>这个操作实际是执行了获取更新，并且与本地代码合并两个操作。因为有可能2人改了同一个地方，所以这里有可能会出现冲突的情况。出现冲突时，需要手工合并代码。</p>\n<figure class=\"highlight\"><pre>$ git pull\n向中央服务器发送本地的修改\n这个操作是把本地的所有新的<span class=\"operator\"><span class=\"keyword\">commit</span>历史都提交到服务器\n</pre></figure>\n\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git push\n</pre></figure>\n\n<h2>一：版本控制守则</h2>\n<ol>\n<li><p>不要提交垃圾文件。包括临时文件，编译产生的二进制文件，个人设置文件，系统cache，与项目无关的文件等等。使用.gitignore文件来告诉git哪些文件应该忽略掉。  </p>\n</li>\n<li><p>不要提交不能编译运行的代码到master分支。平时创建临时分支来工作，可以随时提交，当告一段落之后再合并到master分支。保证master分支的代码是可运行的，这样不会给团队中的其他人带来不必要的影响。 </p>\n</li>\n<li><p>善用分支。可以每开始一个新功能时就创建一个新分支，改完后合并到master。每个新版本也要用一个新分支，这样如果需要改老版本的bug，那么可以很轻松地切换到老分支，改完后再切回新分支。 </p>\n</li>\n<li><p>多提交，及时提交。每当改动达到可以用一句话描述的时候，就提交。 </p>\n</li>\n<li><p>一定要写清楚提交注释，写明做了哪些修改，不要用笼统的一句话例如“改bug”，而是要写具体的说明例如，“按钮文字从转发改成分享”。\n每个准备提交上线的版本要打tag，命名成v1.0.0_rc1这种格式，第一次提交就是rc1，第二次提交就是rc2等等 </p>\n</li>\n</ol>\n<hr>\n<h2>二：git仓库</h2>\n<h3>请求代码</h3>\n<figure class=\"highlight\"><pre>$ git clone ssh:<span class=\"regexp\">//</span><span class=\"variable\">%%</span><span class=\"variable\">%%</span>.git\n$ git clone ssh:<span class=\"regexp\">//</span><span class=\"variable\">%%</span><span class=\"variable\">%%</span><span class=\"variable\">%%</span>.git\n</pre></figure>\n\n<h2>三： 本地代码库管理</h2>\n<h3>1.让git使用你的用户名来标记每次commit</h3>\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">config</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">global</span> <span class=\"comment\">user</span>.<span class=\"comment\">name</span> <span class=\"comment\">\"hufeng\"</span>\n<span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">config</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">global</span> <span class=\"comment\">user</span>.<span class=\"comment\">email</span> <span class=\"comment\">hufeng@hufengvip</span>.<span class=\"comment\">cn\n</pre></figure>\n\n<h3>2.在当前目录初始化一个代码库</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git init\n</pre></figure>\n\n<h3>3.把所有文件加入版本控制</h3>\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">add</span> <span class=\"string\">.</span>\n</pre></figure>\n\n<h3>4.commit所有修改过的文件</h3>\n<figure class=\"highlight\"><pre>$ git <span class=\"operator\"><span class=\"keyword\">commit</span> -a\n</pre></figure>\n\n<h3>5.扔掉对代码库所做的修改，恢复到HEAD版本</h3>\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">checkout</span> <span class=\"literal\">-</span><span class=\"comment\">f</span>\n<span class=\"comment\">或</span>\n<span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">reset</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">hard\n</pre></figure>\n\n<h3>6.优化log显示</h3>\n<figure class=\"highlight\"><pre><span class=\"comment\">git</span> <span class=\"comment\">log</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">color</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">graph</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">pretty=format:'%Cred%h%Creset</span> <span class=\"literal\">-</span><span class=\"comment\">%C(yellow)%d%Creset</span> <span class=\"comment\">%s</span> <span class=\"comment\">%Cgreen(%cr)</span> <span class=\"comment\">%C(bold</span> <span class=\"comment\">blue)</span>&lt;<span class=\"comment\">%an</span>&gt;<span class=\"comment\">%Creset'</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">abbrev</span>-<span class=\"comment\">commit\n</pre></figure>\n\n<h3>7.创建一个分支</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git branch test\n</pre></figure>\n\n<h3>8.切换到一个分支</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git checkout test\n</pre></figure>\n\n<h3>9.切换回主分支</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git checkout master\n</pre></figure>\n\n<h3>10.命令行提示符脚本</h3>\n<p><em>把下面的脚本放到 ~/.profile 或者 ~/.bashrc 里，命令行的提示符即会显示出当前的git分支名称。例如：~/Projects/cmb (master) $</em></p>\n<figure class=\"highlight\"><pre><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parse_git_branch</span> {</span>\n      ref=$(git symbolic-ref HEAD <span class=\"number\">2</span>&gt; /dev/<span class=\"keyword\">null</span>) || <span class=\"keyword\">return</span>\n        <span class=\"keyword\">echo</span> <span class=\"string\">\"(\"</span>${ref<span class=\"comment\">#refs/heads/}\")\"</span>\n}\n\nPS1=<span class=\"string\">\"\\w \\$(parse_git_branch)\\$ \"</span>\n</pre></figure>\n\n<hr>\n<h2>三. 操作远程代码库</h2>\n<h3>1.使用git协议共享本地代码库</h3>\n<p>git本身带了一个服务器命令，启动后，其他机器可以用git协议访问本机的代码库</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">daemon</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">export</span>-<span class=\"comment\">all</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">base</span>-<span class=\"comment\">path=/home/pub/projects/</span> <span class=\"comment\">test</span>.<span class=\"comment\">git\n</pre></figure>\n\n<p><strong>注意：</strong></p>\n<ul>\n<li>如果返回&quot;fatal: no matching remote head&quot;，说明代码库里没有文件或者没有commit过。</li>\n<li>在.git目录下应该有git-daemon-export-ok这个文件，否则必须使用export-all参数来强制共享</li>\n<li>如果允许远程提交代码，需要加上 --enable=receive-pack 参数</li>\n</ul>\n<h3>2.从版本库中删除文件</h3>\n<figure class=\"highlight\"><pre><span class=\"comment\">在git</span> <span class=\"comment\">rm</span> <span class=\"literal\">-</span><span class=\"comment\">rf</span>  <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">cached</span>  <span class=\"comment\">CCB</span>.<span class=\"comment\">xcodeproj/project</span>.<span class=\"comment\">xcworkspace/xcuserdata/</span>  \n\n<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">cached</span> <span class=\"comment\">本地保留服务器删除\n</pre></figure>\n\n<h3>3.远程仓库的重命名</h3>\n<p>在新版 Git 中可以用 git remote rename 命令修改某个远程仓库的简短名称，比如想把 pb 改成 paul，可以这么运行：</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git remote rename pb paul\n<span class=\"variable\">$ </span>git remote origin pau\n</pre></figure>\n\n<p><strong>注意</strong>\n对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了paul/master。</p>\n<h3>4.远程仓库的删除</h3>\n<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git remote rm branchA\n</pre></figure>\n\n<p>或者使用    </p>\n<figure class=\"highlight\"><pre> $ git push origin :xx <span class=\"comment\">//删除远程</span>\n \n $ git branch -d xx <span class=\"comment\">//删除本地</span>\n</pre></figure>\n\n<h3>5.更新指定分支指定文件</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git checkout 指定分支 指定文件\n\n<span class=\"variable\">$ </span>git checkout master <span class=\"constant\">HFFrame</span>/<span class=\"constant\">Global</span>/<span class=\"constant\">Global_macro</span>.h\n</pre></figure>\n\n<h3>6.复制一个远程代码库</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git clone <span class=\"symbol\">git:</span>/<span class=\"regexp\">/10.150.150.136/test</span>.git test\n</pre></figure>\n\n<h3>7.从远程代码库上的主分支获取最新的代码</h3>\n<p>第一次：</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git pull <span class=\"symbol\">git:</span>/<span class=\"regexp\">/10.150.###.###/test</span>.git master\n或\n<span class=\"variable\">$ </span>git pull <span class=\"symbol\">ssh:</span>/<span class=\"regexp\">/10.150.###.###/test</span>.git master\n</pre></figure>\n\n<p>以后：</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$git</span> pull origin master\n\n指定好配置文件后可以直接执行pull push 不用跟后面的分支 骨干\n\n具体方法是 仓库跟目录 .git/config \n\n [core]\n           repositoryformatversion = <span class=\"number\">0</span>\n           filemode = <span class=\"keyword\">true</span>\n           bare = <span class=\"keyword\">false</span>\n           logallrefupdates = <span class=\"keyword\">true</span>\n           ignorecase = <span class=\"keyword\">true</span>\n   [remote <span class=\"string\">\"origin\"</span>]\n           fetch = +refs/heads/*<span class=\"symbol\">:refs/remotes/orig</span>    <span class=\"keyword\">in</span>/*\n           url = <span class=\"symbol\">ssh:</span>/<span class=\"regexp\">/git@git.huaxia.com:6521    /cmblife</span>.git\n   [branch <span class=\"string\">\"master\"</span>]\n          remote = origin\n          merge = refs/heads/master\n   [branch <span class=\"string\">\"hufeng\"</span>]\n          remote = origin\n          merge = refs/heads/hufeng\n</pre></figure>\n\n<h3>8.将本地代码库的修改传给远程代码库</h3>\n<p>如果是提交到master分支：</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git push origin master\n</pre></figure>\n\n<p><strong>警告</strong> 远程代码库应该是一个空的bare库，否则会搞乱working copy！！如果working copy是干净的，可以使用git checkout -f来同步代码库。如果已经做了修改，则就没有很好的办法恢复同步状态了！</p>\n<h3>9. 在远程代码库创建一个分支</h3>\n<p>有时候在本地创建的分支希望分享到远程代码库的分支里，下面命令会在远程创建一个名为branch的分支，并且和本地的branch分支关联起来</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git push origin branch\n</pre></figure>\n\n<p>以后，即可使用 git push 来分享代码到远程库。</p>\n<h3>10.在本地关联一个远程库的分支</h3>\n<p>有时候需要在本地获取一个远程分支，使用这个命令：</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">branch</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">track</span> <span class=\"comment\">origin/branch\n</pre></figure>\n\n<p>以后即可使用 git pull 来获取远程的更新</p>\n","excerpt":76,"source":"_posts/git8.md","slug":"git8","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"15":{"id":0,"title":"git与SVN协同的工作流程","date":"2013-09-03T03:00:12.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[2,3],"tags":[1],"comments":true,"layout":"post","content":"<p>git可以和SVN服务器一起使用，即，中央服务器采用svn，本地代码库使用git。这样的好处是，可以兼容以前的项目，同时本地有一套完整的版本控制系统，可以随时查看代码修改历史，随时提交，不需要网络。合适的时候再提交到SVN服务器。git-svn的工作流程也有很多，我们推荐使用下面这种方式。</p>\n<a name=\"more\"></a>\n\n\n<h2>一.git-svn初始化</h2>\n<figure class=\"highlight\"><pre><span class=\"title\">git</span> svn init SVNREMOTEURL\n</pre></figure>\n\n<p>-s 参数是表面使用的是svn标准命名方法,即 trunk,tags,branches,这个参数有时很重要,建议使用,命 令后面还可以加个文件夹名字作为clone后的目录</p>\n<figure class=\"highlight\"><pre><span class=\"title\">git</span> svn fetch\n</pre></figure>\n\n<p>可能碰到只想从某个版本开始进行fetch,那么请需要 –r 参数。 例如:</p>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git svn fetch -r <span class=\"number\">1342</span><span class=\"symbol\">:HEAD</span>\n\n<span class=\"variable\">$ </span>git remote add origin <span class=\"constant\">GITREMOTEURL</span> 初始化远程git 地址 \n\n这⼀一步可以省略 如果没必要提交到远程git 服务器中\n</pre></figure>\n\n<h2>二.git-svn基本⽤用法</h2>\n<h3>本地修改代码后提交</h3>\n<figure class=\"highlight\"><pre><span class=\"comment\">git</span> <span class=\"comment\">commit</span> <span class=\"literal\">-</span><span class=\"comment\">a</span> <span class=\"literal\">-</span><span class=\"comment\">m</span> <span class=\"comment\">“”\n</pre></figure>\n\n<h3>同步远程svn 服务器</h3>\n<figure class=\"highlight\"><pre><span class=\"title\">git</span> svn rebase\n</pre></figure>\n\n<h3>推送到远程svn服务器</h3>\n<figure class=\"highlight\"><pre>git svn d<span class=\"operator\"><span class=\"keyword\">commit</span>\n</pre></figure>\n\n<h3>推送到远程git 服务器</h3>\n<figure class=\"highlight\"><pre><span class=\"title\">git</span> push\n</pre></figure>\n\n<h3>从SVN服务器获取代码</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git svn clone <span class=\"symbol\">http:</span>/<span class=\"regexp\">/svnserver/project</span><span class=\"regexp\">/trunk\n</pre></figure>\n\n<h3>创建一个本地分支</h3>\n<figure class=\"highlight\"><pre>为了方便合并，减少不必要的麻烦，最好保持主分支master不变，在一个新的分支进行日常工作\n\n<span class=\"title\">git</span> branch workA\n</pre></figure>\n\n<h3>日常修改和提交</h3>\n<p>与git的工作流程完全一样</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">checkout</span> <span class=\"literal\">-</span><span class=\"comment\">b</span> <span class=\"comment\">work</span>\n<span class=\"comment\">$</span> <span class=\"comment\">git</span> <span class=\"comment\">commit</span> <span class=\"literal\">-</span><span class=\"comment\">a\n</pre></figure>\n\n<h3>切回master从SVN获取最新代码</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git checkout master\n<span class=\"variable\">$ </span>git svn rebase\n</pre></figure>\n\n<h3>master同步后，与工作分支合并</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git checkout work\n<span class=\"variable\">$ </span>git rebase master     <span class=\"comment\">## 手工解决可能的冲突</span>\n</pre></figure>\n\n<h3>合并主分支</h3>\n<figure class=\"highlight\"><pre><span class=\"variable\">$ </span>git checkout master <span class=\"variable\">$ </span>git merge work\n</pre></figure>\n\n<h3>git-svn 解决冲突</h3>\n<ul>\n<li><p>⼿动打开冲突的⽂文件 找到冲突的地⽅方修改完成后保存</p>\n</li>\n<li><p>执⾏行 git add 冲突⽂文件</p>\n</li>\n<li><p>git rebase --continue </p>\n</li>\n<li><p>git svn dcommit</p>\n</li>\n</ul>\n","excerpt":153,"source":"_posts/git9.md","slug":"git9","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"16":{"id":0,"title":"hibernate 笔记之 基础概念和配置","date":"2013-08-14T07:56:58.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[4],"tags":[1],"comments":true,"layout":"post","content":"<h2>ORM 概念</h2>\n<blockquote>\n<p>ORM 解决主要的问题是对象-- 关系映射， 域模型是面向对象的，而关系模型数据是面向关系的，一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录。</p>\n</blockquote>\n<a name=\"more\"></a>\n\n<h3>对象的持久化</h3>\n<p>• 狭义的理解,“持久化”仅仅指把对象永久保存到数据库中</p>\n<p>• 广义的理解,“持久化”包括和数据库相关的各种操作:</p>\n<ul>\n<li><p>保存:把对象永久保存到数据库中。</p>\n</li>\n<li><p>更新:更新数据库中对象(记录)的状态。</p>\n</li>\n<li><p>删除:从数据库中删除一个对象。</p>\n</li>\n<li><p>查询:根据特定的查询条件,把符合查询条件的一个或多个对象从数据 库加载到内存中。</p>\n</li>\n<li><p>加载:根据特定的OID,把一个对象从数据库加载到内 </p>\n<blockquote>\n<p>&#39; OID ---&gt;为了在系统中能够找到所需对象,需要为每一个对象分配一个唯一的标识号。 在关系数据库中称之为主键,而在对象术语中,则叫做对象标识(Object identifier-OID). &#39;</p>\n</blockquote>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>标号</th>\n<th>面向对象概念</th>\n<th>面向关系概念 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>1</em></td>\n<td><code>对象</code></td>\n<td><strong>表的行（即记录）</strong></td>\n</tr>\n<tr>\n<td>2</td>\n<td>属性</td>\n<td>表的列（即字段）</td>\n</tr>\n</tbody>\n</table>\n<h2>注意事项</h2>\n<ol>\n<li>有一个无参的构造器  反射时需要</li>\n<li>类不能声明为final  如果声明就不能实现延迟加载了</li>\n</ol>\n<h2>hibernate 配置文件</h2>\n<blockquote>\n<p>hibernate.cfg.xml</p>\n</blockquote>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">hibernate-configuration</span>&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">session-factory</span>&gt;</span>\n\t\t<span class=\"comment\">&lt;!-- 数据连接相关的配置 --&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hibernate.connection.driver_class\"</span>&gt;</span>com.mysql.jdbc.Driver<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hibernate.connection.url\"</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hibernate.connection.username\"</span>&gt;</span>root<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\t\t\t\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hibernate.connection.password\"</span>&gt;</span>1234<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t\t\n\t\t<span class=\"comment\">&lt;!-- 执行操作时显示SQL语句 --&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"show_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\n\t\t<span class=\"comment\">&lt;!-- 格式化输出的SQL语句 --&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"format_sql\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t\n\t\t<span class=\"comment\">&lt;!-- 配置数据库方言 --&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hibernate.dialect\"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\t\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"hibernate.hbm2ddl.auto\"</span>&gt;</span>update<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t\t\n\t\t<span class=\"comment\">&lt;!-- 配置映射文件 --&gt;</span>\t\t\t\n\t\t<span class=\"tag\">&lt;<span class=\"title\">mapping</span> <span class=\"attribute\">resource</span>=<span class=\"value\">\"com/vince/entity/User.hbm.xml\"</span>/&gt;</span>\t\n\t\t<span class=\"tag\">&lt;/<span class=\"title\">session-factory</span>&gt;</span>\t\n<span class=\"tag\">&lt;/<span class=\"title\">hibernate-configuration</span>&gt;</span>\n</pre></figure>\n\n<p>hbm2ddl.auto:该属性可帮助程序员实现正向工程, 即由 java 代码生成数据库脚本, 进而生成具体的表结构. 。取值 create | update | create-drop | validate</p>\n<p>– create : 会根据 .hbm.xml 文件来生成数据表, 但是每次运行都会删 除上一次的表 ,重新生成表, 哪怕二次没有任何改变</p>\n<p>– create-drop:会根据.hbm.xml文件生成表,但是SessionFactory一关 闭, 表就自动删除</p>\n<p>– update:最常用的属性值,也会根据.hbm.xml文件生成表,但 若 .hbm.xml 文件和数据库中对应的数据表的表结构不同, Hiberante 将更新数据表结构,但不会删除已有的行和列</p>\n<p>– validate : 会和数据库中的表进行比较, 若 .hbm.xml 文件中的列在数 据表中不存在,则抛出异常</p>\n<ul>\n<li>format_sql:是否将 SQL 转化为格式良好的 SQL . 取值 true | false</li>\n</ul>\n<hr>\n<h2>hibernate 映射文件</h2>\n<blockquote>\n<p>User.hbm.xml</p>\n</blockquote>\n<figure class=\"highlight\"><pre><span class=\"pi\">&lt;?xml version=\"1.0\"?&gt;</span>\n<span class=\"doctype\">&lt;!DOCTYPE hibernate-mapping PUBLIC\n\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;</span>\n\n<span class=\"tag\">&lt;<span class=\"title\">hibernate-mapping</span> <span class=\"attribute\">package</span>=<span class=\"value\">\"com.vince.entity\"</span>&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">class</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"User\"</span> <span class=\"attribute\">table</span>=<span class=\"value\">\"USER_TABLE\"</span> <span class=\"attribute\">dynamic-update</span>=<span class=\"value\">\"true\"</span> <span class=\"attribute\">dynamic-insert</span>=<span class=\"value\">\"true\"</span>&gt;</span>\n\t\t<span class=\"comment\">&lt;!-- 配置主键 --&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">id</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"id\"</span> <span class=\"attribute\">column</span>=<span class=\"value\">\"ID\"</span>&gt;</span>\n\t\t\t<span class=\"comment\">&lt;!-- native表示使用本地数据库生成主键的方式 --&gt;</span>\n\t\t\t<span class=\"tag\">&lt;<span class=\"title\">generator</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"native\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">generator</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;/<span class=\"title\">id</span>&gt;</span>\n\t\t<span class=\"comment\">&lt;!-- 其它属性的配置 --&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"name\"</span> <span class=\"attribute\">column</span>=<span class=\"value\">\"NAME\"</span> <span class=\"attribute\">not-null</span>=<span class=\"value\">\"true\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"age\"</span> <span class=\"attribute\">column</span>=<span class=\"value\">\"AGE\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"createDate\"</span> <span class=\"attribute\">column</span>=<span class=\"value\">\"CREATE_DATE\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t<span class=\"tag\">&lt;/<span class=\"title\">class</span>&gt;</span>\n\n<span class=\"tag\">&lt;/<span class=\"title\">hibernate-mapping</span>&gt;</span>\n\n\n-------\n\n<span class=\"tag\">&lt;<span class=\"title\">hibernate-mapping</span> <span class=\"attribute\">package</span>=<span class=\"value\">\"com.vince.entity\"</span>&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">class</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"Emp\"</span> <span class=\"attribute\">table</span>=<span class=\"value\">\"EMP\"</span> <span class=\"attribute\">dynamic-insert</span>=<span class=\"value\">\"true\"</span>\n\t\t<span class=\"attribute\">dynamic-update</span>=<span class=\"value\">\"true\"</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">id</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"id\"</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"int\"</span>&gt;</span>\n\t\t\t<span class=\"tag\">&lt;<span class=\"title\">column</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"ID\"</span> /&gt;</span>\n\t\t\t<span class=\"tag\">&lt;<span class=\"title\">generator</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"native\"</span> /&gt;</span>\n\t\t<span class=\"tag\">&lt;/<span class=\"title\">id</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"name\"</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"java.lang.String\"</span>&gt;</span>\n\t\t\t<span class=\"tag\">&lt;<span class=\"title\">column</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"NAME\"</span> /&gt;</span>\n\t\t<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"salary\"</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"float\"</span>&gt;</span>\n\t\t\t<span class=\"tag\">&lt;<span class=\"title\">column</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"SALARY\"</span> /&gt;</span>\n\t\t<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"age\"</span> <span class=\"attribute\">type</span>=<span class=\"value\">\"int\"</span>&gt;</span>\n\t\t\t<span class=\"tag\">&lt;<span class=\"title\">column</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"AGE\"</span> /&gt;</span>\n\t\t<span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n\t<span class=\"tag\">&lt;/<span class=\"title\">class</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">hibernate-mapping</span>&gt;</span>\n</pre></figure>\n\n<h3>主键生成策略</h3>\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7n5a834npj20x00lajw6.jpg\n\" class=\"center\" title=\"hiberate 主键生成策略\">\n\n\n<hr>\n<h2>SessionFactory 接口</h2>\n<p>• 针对单个数据库映射关系经过编译后的内存镜像,是线程安 全的。</p>\n<p>• Configuration 对象根据当前的配置信息生成 SessionFactory 对象。SessionFactory 对象一旦构造完毕,即被赋予特定的 配置信息</p>\n<ul>\n<li><p>Configuration cfg = new Configuration().configure();</p>\n</li>\n<li><p>SessionFactory sf = cfg.buildSessionFactory();</p>\n</li>\n</ul>\n<p>• SessionFactory是生成Session的工厂:</p>\n<ul>\n<li>Session session = sf.openSession();</li>\n</ul>\n<p>• 构造 SessionFactory 很消耗资源</p>\n<h2>hibernate.hbm2ddl.auto</h2>\n<ol>\n<li>create-drop   每次启动重新创建 结束后删除</li>\n<li>create 每次启动都重新创建</li>\n<li>update 不一样就更新</li>\n<li>validate 仅仅验证</li>\n</ol>\n<h2>如何使用</h2>\n<h3>使用范例</h3>\n<figure class=\"highlight\"><pre><span class=\"package\"><span class=\"keyword\">package</span> <span class=\"title\">hufeng</span>.<span class=\"title\">test</span> ;\n\n<span class=\"title\">import</span> <span class=\"title\">org</span>.<span class=\"title\">hibernate</span>.<span class=\"title\">Session</span> ;\n<span class=\"title\">import</span> <span class=\"title\">org</span>.<span class=\"title\">hibernate</span>.<span class=\"title\">SessionFactory</span> ;\n<span class=\"title\">import</span> <span class=\"title\">org</span>.<span class=\"title\">hibernate</span>.<span class=\"title\">cfg</span>.<span class=\"title\">Configuration</span> ;\n\n<span class=\"title\">public</span> <span class=\"title\">class</span>  <span class=\"title\">Test</span>{</span>\n\tpublick <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args){\n\t<span class=\"comment\">// 加载hibernate 配置文件 （默认加载classpath 下的hibernate.cfg.xml）</span>\n\tConfiguration cfg = <span class=\"keyword\">new</span> Configuration().config();\n\t\n\t<span class=\"comment\">// 通过Configulation 对象创建SessionFactory 工厂</span>\n\tSessionFactory factory = cfg.buildSessionFactory();\n \t\n \t<span class=\"comment\">//Session操作数据库的一次会话</span>\n \t<span class=\"comment\">//线程不安全</span>\n \tSession session = factory.openSession();\n\n\n \t<span class=\"comment\">//开启事务 --&gt; 把很多操作组合成一个整体 让事物具有原子性</span>\n \tTransaction tx =  session.beginTransation();\n\n\n \tCustomUser user = <span class=\"keyword\">new</span> CustomUser(<span class=\"string\">\"jason\"</span>,<span class=\"number\">20</span>,<span class=\"keyword\">new</span> Date());\n\n \t<span class=\"comment\">//保存数据</span>\n \tsession.save(user);\n\n \t<span class=\"comment\">//提交事物</span>\n \ttx.commit();\n\n \t<span class=\"comment\">//关闭</span>\n \tsession.close();\n \tfactory.close();\n }\n}\n</pre></figure>\n\n<h3>创建Hibernate 工具类</h3>\n<figure class=\"highlight\"><pre><span class=\"keyword\">public</span> final <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"id\">HibernateUtil</span>{</span>\n\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SessionFactory sessionFactory;\n\t<span class=\"keyword\">private</span> HibernateUtil(){}\n\n\t<span class=\"keyword\">static</span> {\n\t\tConfiguration cfg  = new Configuration()<span class=\"variable\">.configure</span>();\n\t\tsessionFactory = cfg<span class=\"variable\">.buildSessionFactory</span>();\n\t}\n\n\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SessionFactory  getSesstionFactory()\n\t {\n\t \t<span class=\"keyword\">return</span> sessionFactory;\n\t }\n\n\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Session getSession()\n\t {\n\t \t<span class=\"keyword\">return</span> sessionFactory<span class=\"variable\">.openSession</span>();\n\t }\n\n\t <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> save(Object obj)\n\t {\n\t \tSession session = getSession();\n\t \tTransaction tx = session<span class=\"variable\">.benginTransaction</span>();\n\t \tsession<span class=\"variable\">.save</span>(obj);\n\t \tsession<span class=\"variable\">.evict</span>(obj);<span class=\"comment\">//把对象清理出esssion 避免批处理时session中的缓存过多 导致内存溢出</span>\n\t \t<span class=\"comment\">//session.clear()；清楚session中所有的对象</span>\n\t \ttx<span class=\"variable\">.commit</span>();\n\t \tsession<span class=\"variable\">.close</span>();\n\t }\n}\n</pre></figure>\n\n<h3>应用工具类后的代码</h3>\n<figure class=\"highlight\"><pre><span class=\"package\"><span class=\"keyword\">package</span> <span class=\"title\">hufeng</span>.<span class=\"title\">test</span> ;\n\n<span class=\"title\">import</span> <span class=\"title\">org</span>.<span class=\"title\">hibernate</span>.<span class=\"title\">Session</span> ;\n<span class=\"title\">import</span> <span class=\"title\">org</span>.<span class=\"title\">hibernate</span>.<span class=\"title\">SessionFactory</span> ;\n<span class=\"title\">import</span> <span class=\"title\">org</span>.<span class=\"title\">hibernate</span>.<span class=\"title\">cfg</span>.<span class=\"title\">Configuration</span> ;\n<span class=\"title\">import</span> <span class=\"title\">org</span>.<span class=\"title\">util</span>.<span class=\"title\">HibernateUtil</span>;\n\n<span class=\"title\">public</span> <span class=\"title\">class</span> <span class=\"title\">Test</span> {</span>\n\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> save()\n\t{\n\t\tUser user =<span class=\"keyword\">new</span> User(<span class=\"string\">\"jack\"</span>,<span class=\"number\">22</span>,<span class=\"keyword\">new</span> Date()));\n\t\tHibernateUtil.save(user);\n\t}\n}\n\npublick <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args)\n{\n\tsave();\n}\n</pre></figure>\n\n<h3>更加规范应用HQL的代码</h3>\n<figure class=\"highlight\"><pre>public final class HibernateUtil {\n\n\tprivate static SessionFactory sessionFactory<span class=\"comment\">;</span>\n\n\tprivate HibernateUtil() {\n\t}\n\n\tstatic {\n\t\tConfiguration cfg = new Configuration()<span class=\"preprocessor\">.configure</span>()<span class=\"comment\">;</span>\n\t\tsessionFactory = cfg<span class=\"preprocessor\">.buildSessionFactory</span>()<span class=\"comment\">;</span>\n\t}\n\n\tpublic static SessionFactory getSessionFactory() {\n\t\treturn sessionFactory<span class=\"comment\">;</span>\n\t}\n\n\tpublic static Session getSession() {\n\t\treturn sessionFactory<span class=\"preprocessor\">.openSession</span>()<span class=\"comment\">;</span>\n\t}\n\n\tpublic static void save(Object obj) {\n\t\tSession session = null<span class=\"comment\">;</span>\n\t\ttry {\n\t\t\tsession = getSession()<span class=\"comment\">;</span>\n\t\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\tsession<span class=\"preprocessor\">.save</span>(obj)<span class=\"comment\">;</span>\n\t\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\t} catch (HibernateException e) {\n\t\t\te<span class=\"preprocessor\">.printStackTrace</span>()<span class=\"comment\">;</span>\n\t\t} finally {\n\t\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\t}\n\t}\n\tpublic static void update(Object obj) {\n\t\tSession session = null<span class=\"comment\">;</span>\n\t\ttry {\n\t\t\tsession = getSession()<span class=\"comment\">;</span>\n\t\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\tsession<span class=\"preprocessor\">.update</span>(obj)<span class=\"comment\">;</span>\n\t\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\t} catch (HibernateException e) {\n\t\t\te<span class=\"preprocessor\">.printStackTrace</span>()<span class=\"comment\">;</span>\n\t\t} finally {\n\t\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\t}\n\t}\n\t\n\tpublic static void delete(Object obj) {\n\t\tSession session = null<span class=\"comment\">;</span>\n\t\ttry {\n\t\t\tsession = getSession()<span class=\"comment\">;</span>\n\t\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\tsession<span class=\"preprocessor\">.delete</span>(obj)<span class=\"comment\">;</span>\n\t\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\t} catch (HibernateException e) {\n\t\t\te<span class=\"preprocessor\">.printStackTrace</span>()<span class=\"comment\">;</span>\n\t\t} finally {\n\t\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\t}\n\t}\n\t\n\tpublic static Object get(Class clazz,Serializable id) {\n\t\tSession session = null<span class=\"comment\">;</span>\n\t\ttry {\n\t\t\tsession = getSession()<span class=\"comment\">;</span>\n\t\t\treturn session<span class=\"preprocessor\">.get</span>(clazz, id)<span class=\"comment\">;</span>\n\t\t} catch (HibernateException e) {\n\t\t\te<span class=\"preprocessor\">.printStackTrace</span>()<span class=\"comment\">;</span>\n\t\t} finally {\n\t\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\t}\n\t\treturn null<span class=\"comment\">;</span>\n\t}\n\n}\n\n--------\n@Override\n\tpublic List&lt;Emp&gt; list() throws Exception {\n\t\tSession session  = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\t//hql针对对象查询语句\n\t\tString hql = <span class=\"string\">\"from Emp\"</span><span class=\"comment\">;//</span>\n\t\t//创建查询(hql)\n\t\tQuery query = session<span class=\"preprocessor\">.createQuery</span>(hql)<span class=\"comment\">;</span>\n\t\tList&lt;Emp&gt; list = query<span class=\"preprocessor\">.list</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\treturn list<span class=\"comment\">;</span>\n\t}\n\n\t@Override\n\tpublic void <span class=\"keyword\">add</span>(Emp emp) throws Exception {\n\t\tHibernateUtil<span class=\"preprocessor\">.save</span>(emp)<span class=\"comment\">;</span>\n\t\t\n\t}\n\n\t@Override\n\tpublic List&lt;Emp&gt; listByName(String name) throws Exception {\n\t\tSession session  = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tString hql = <span class=\"string\">\"from Emp e where e.name=?\"</span><span class=\"comment\">;</span>\n\t\tQuery query = session<span class=\"preprocessor\">.createQuery</span>(hql)<span class=\"comment\">;</span>\n\t\t//sql ？起始位置从<span class=\"number\">1</span>开始\n\t\t//hql ？起始位置从<span class=\"number\">0</span>开始\n\t\tquery<span class=\"preprocessor\">.setString</span>(<span class=\"number\">0</span>, name)<span class=\"comment\">;</span>\n\t\t\n\t\tList&lt;Emp&gt; list = query<span class=\"preprocessor\">.list</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\treturn list<span class=\"comment\">;</span>\n\t}\n\n\t@Override\n\tpublic List&lt;Emp&gt; listByAge(int age) throws Exception {\n\t\t\n\t\t\n\t\treturn null<span class=\"comment\">;</span>\n\t}\n\n\t//使用别名代替?方式，可以不用考虑设置参数的顺序\n\t@Override\n\tpublic List&lt;Emp&gt; listByNameAge(String name, int age) throws Exception {\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tString hql = <span class=\"string\">\"from Emp e where e.age=:age and e.name=:name\"</span><span class=\"comment\">;</span>\n\t\tQuery query = session<span class=\"preprocessor\">.createQuery</span>(hql)<span class=\"comment\">;</span>\n//\t\tquery<span class=\"preprocessor\">.setString</span>(<span class=\"number\">0</span>, name)<span class=\"comment\">;</span>\n//\t\tquery<span class=\"preprocessor\">.setInteger</span>(<span class=\"number\">1</span>, age)<span class=\"comment\">;</span>\n\t\tquery<span class=\"preprocessor\">.setString</span>(<span class=\"string\">\"name\"</span>, name)<span class=\"comment\">;</span>\n\t\tquery<span class=\"preprocessor\">.setInteger</span>(<span class=\"string\">\"age\"</span>, age)<span class=\"comment\">;</span>\n\t\t\n\t\t//对分页的支持\n\t\tquery<span class=\"preprocessor\">.setFirstResult</span>(<span class=\"number\">0</span>)<span class=\"comment\">;//设置查询的起始位置</span>\n\t\tquery<span class=\"preprocessor\">.setMaxResults</span>(<span class=\"number\">1</span>)<span class=\"comment\">;//设置每页的记录数</span>\n\t\t\n\t\t\n\t\tList&lt;Emp&gt; emps = query<span class=\"preprocessor\">.list</span>()<span class=\"comment\">;</span>\n\t\t\n\t\t\n\t\t\n\t\t//iterate查询会执行 N+<span class=\"number\">1</span>条语句\n//\t\tIterator&lt;Emp&gt; emps = query<span class=\"preprocessor\">.iterate</span>()<span class=\"comment\">;</span>\n\t\t\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\treturn emps<span class=\"comment\">;</span>\n\t}\n\n\t@Override\n\tpublic List&lt;Emp&gt; listLikeName(String name) {\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tString hql = <span class=\"string\">\"from Emp e where e.name like :name\"</span><span class=\"comment\">;</span>\n\t\tQuery query = session<span class=\"preprocessor\">.createQuery</span>(hql)<span class=\"comment\">;</span>\n\t\tquery<span class=\"preprocessor\">.setString</span>(<span class=\"string\">\"name\"</span>, <span class=\"string\">\"%\"</span>+name+<span class=\"string\">\"%\"</span>)<span class=\"comment\">;</span>\n\t\tList&lt;Emp&gt; list = query<span class=\"preprocessor\">.list</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\treturn list<span class=\"comment\">;</span>\n\t}\n\n\t@Override\n\tpublic Emp getByName(String name) {\n\t\tString hql = <span class=\"string\">\"from Emp e where e.name=:name\"</span><span class=\"comment\">;</span>\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tQuery query = session<span class=\"preprocessor\">.createQuery</span>(hql)<span class=\"comment\">;</span>\n\t\tquery<span class=\"preprocessor\">.setString</span>(<span class=\"string\">\"name\"</span>, name)<span class=\"comment\">;</span>\n\t\t//返回唯一的结果\n\t\tEmp emp = (Emp)query<span class=\"preprocessor\">.uniqueResult</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\treturn emp<span class=\"comment\">;</span>\n\t}\n\n\t//QBC检索方式(了解)\n\t@Override\n\tpublic Emp getById(int id) {\n\t\t\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tCriteria criteria = session<span class=\"preprocessor\">.createCriteria</span>(Emp<span class=\"preprocessor\">.class</span>)<span class=\"comment\">;</span>\n\t\t//添加查询条件\n\t\tcriteria<span class=\"preprocessor\">.add</span>(Restrictions<span class=\"preprocessor\">.eq</span>(<span class=\"string\">\"id\"</span>, id))<span class=\"comment\">;</span>\n\t\tEmp emp = (Emp)criteria<span class=\"preprocessor\">.uniqueResult</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\treturn emp<span class=\"comment\">;</span>\n\t}\n\n\t@Override\n\tpublic long countEmp() {\n\t\tString hql = <span class=\"string\">\"select count(id) as id from Emp\"</span><span class=\"comment\">;</span>\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tQuery query = session<span class=\"preprocessor\">.createQuery</span>(hql)<span class=\"comment\">;</span>\n\t\tlong count = (long)query<span class=\"preprocessor\">.uniqueResult</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\treturn count<span class=\"comment\">;</span>\n\t}\n\tpublic void countEmp2() {\n\t\tString hql = <span class=\"string\">\"select count(id),avg(age) as id from Emp\"</span><span class=\"comment\">;</span>\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tQuery query = session<span class=\"preprocessor\">.createQuery</span>(hql)<span class=\"comment\">;</span>\n\t\tList list = query<span class=\"preprocessor\">.list</span>()<span class=\"comment\">;</span>\n\t\tObject[] objs = (Object[])list<span class=\"preprocessor\">.get</span>(<span class=\"number\">0</span>)<span class=\"comment\">;</span>\n\t\tint count = (int)objs[<span class=\"number\">0</span>]<span class=\"comment\">;</span>\n\t\tint avg = (int)objs[<span class=\"number\">1</span>]<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t}\n</pre></figure>\n\n","excerpt":133,"source":"_posts/hibernate0.md","slug":"hibernate0","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"17":{"id":0,"title":"hexo教程1 如何安装hexo","date":"2013-08-08T06:21:33.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[5],"tags":[1],"comments":true,"layout":"post","content":"<p><a name=\"more\"></a></p>\n<h2>前言</h2>\n<blockquote>\n<p>很早之前就想自己搭建一个博客，但是无奈已没有时间 而没有银子购买服务器，把家里的mac 当做服务器搭建wordpress但是不能保证速度和访问时间。偶然间发现了octopress,于是兴冲冲的折腾起来，最后搭建成功了，废了很大的经历，最主要的原因是还是网络原因，octopress 安装需要下载大量的安装依赖非常繁琐，到处是坑。后来偶然间发现了hexo，发现要比octopress 好用的太多了。于是果断废弃octopress 转头hexo</p>\n</blockquote>\n<hr>\n<h2>概念理解</h2>\n<p>hexo 是基于node.js 的 和rails 差不多。再次使用前 需要安装两个插件</p>\n<ul>\n<li>nvm （版本控制）\nnodejs version manager,可以把它理解为 rails里面的rvm  </li>\n<li>npm （包管理机制 ）\n nodejs package manager,可以把它理解为 rails 里面的bundle </li>\n</ul>\n<hr>\n<h3>安装步骤(mac)</h3>\n<blockquote>\n<p>只针对于mac 其他的请到官网查看相应平台的安装方法<a href=\"http://zespia.tw/hexo\">http://zespia.tw/hexo</a> </p>\n</blockquote>\n<hr>\n<h4>npm</h4>\n<hr>\n<p>打开终端 执行一下命令</p>\n<figure class=\"highlight\"><pre><span class=\"title\">git</span> clone <span class=\"url\">git://github.com/creationix/nvm.git</span> ~/nvm\n</pre></figure>\n\n<p>安装完毕后，在~/.bash_profile或~/.bashrc加入以下内容</p>\n<figure class=\"highlight\"><pre>. ~<span class=\"regexp\">/nvm/</span>nvm.sh`<span class=\"javascript\"></span>\n</pre></figure>\n\n<p>执行</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">source</span> <span class=\"string\">.</span><span class=\"comment\">bash_profile</span> <span class=\"comment\">//或者</span> <span class=\"comment\">source</span> <span class=\"string\">.</span><span class=\"comment\">bashrc\n</pre></figure>\n\n<p>之后即可使用 nvm 来安装 Node.js</p>\n<figure class=\"highlight\"><pre>   nvm install v0<span class=\"number\">.8</span><span class=\"number\">.14</span>\n   nvm <span class=\"keyword\">use</span> v0<span class=\"number\">.8</span><span class=\"number\">.14</span>\n   nvm <span class=\"keyword\">alias</span> <span class=\"keyword\">default</span> v0<span class=\"number\">.8</span><span class=\"number\">.14</span>\n</pre></figure>\n\n<hr>\n<h4>hexo</h4>\n<p>安装</p>\n<figure class=\"highlight\"><pre><span class=\"title\">npm</span> install -g hexo\n</pre></figure>\n\n<p>更新</p>\n<figure class=\"highlight\"><pre>npm <span class=\"operator\"><span class=\"keyword\">update</span> -g\n</pre></figure>\n\n<hr>\n<h3>设定</h3>\n<p>编辑 _config.yml</p>\n<p>下面贴出我的配置 大家自行根据各自的配置进行相应修改</p>\n<pre><code><figure class=\"highlight\"><pre>// <span class=\"class\">Site</span>\n<span class=\"method\">title:</span> 阿峰的技术窝窝\n<span class=\"method\">subtitle:</span> 专注于移动互联网\n<span class=\"method\">description:</span> <span class=\"class\">C</span>/<span class=\"class\">C</span>++/<span class=\"class\">Linux</span>/嵌入式/<span class=\"class\">IOS</span>/<span class=\"class\">WEB</span>/\n<span class=\"method\">author:</span> <span class=\"class\">Jason</span> <span class=\"class\">Hu</span>\n<span class=\"method\">email:</span> hufeng@hufengvip.cn\n<span class=\"method\">language:</span> zh-<span class=\"class\">CN</span>\n\n// <span class=\"class\">URL</span>\n// <span class=\"class\">If</span> your site is put in a subdirectory, set url as <span class=\"string\">'http://yoursite.com/child'</span> and root as <span class=\"string\">'/child/'</span>\n<span class=\"method\">url:</span> <span class=\"method\">http:</span>//hufeng825.github.com\n<span class=\"method\">root:</span> /\n<span class=\"method\">permalink:</span> :year/:month/:day/:title/\n<span class=\"method\">tag_dir:</span> tags\n<span class=\"method\">archive_dir:</span> archives\n<span class=\"method\">category_dir:</span> categories\n<span class=\"method\">code_dir:</span> downloads/code\n\n// <span class=\"class\">Writing</span>\n<span class=\"method\">new_post_name:</span> :title.md # <span class=\"class\">File</span> name of new posts\n<span class=\"method\">default_layout:</span> post\n<span class=\"method\">auto_spacing:</span> <span class=\"keyword\">false</span> # <span class=\"class\">Add</span> spaces between asian characters and western characters\n<span class=\"method\">titlecase:</span> <span class=\"keyword\">false</span> # <span class=\"class\">Transform</span> title into titlecase\n<span class=\"method\">max_open_file:</span> <span class=\"number\">100</span>\n<span class=\"method\">filename_case:</span> <span class=\"number\">0</span>\n<span class=\"method\">highlight:</span>\n  <span class=\"method\">enable:</span> <span class=\"keyword\">true</span>\n  <span class=\"method\">line_number:</span> <span class=\"keyword\">true</span>\n  <span class=\"method\">tab_replace:</span>\n\n// <span class=\"class\">Category</span> &amp; <span class=\"class\">Tag</span>\n<span class=\"method\">default_category:</span> <span class=\"class\">IOS</span>\n<span class=\"method\">category_map:</span>\n<span class=\"method\">tag_map:</span>\n\n// <span class=\"class\">Archives</span>\n// <span class=\"number\">2</span>: <span class=\"class\">Enable</span> pagination\n// <span class=\"number\">1</span>: <span class=\"class\">Disable</span> pagination\n// <span class=\"number\">0</span>: <span class=\"class\">Fully</span> <span class=\"class\">Disable</span>\n<span class=\"method\">archive:</span> <span class=\"number\">2</span>\n<span class=\"method\">category:</span> <span class=\"number\">2</span>\n<span class=\"method\">tag:</span> <span class=\"number\">2</span>\n\n// <span class=\"class\">Server</span>\n// <span class=\"class\">Hexo</span> uses <span class=\"class\">Connect</span> as a server\n// <span class=\"class\">You</span> can customize the logger format as defined in\n// <span class=\"method\">http:</span>//www.senchalabs.org/connect/logger.html\n<span class=\"method\">port:</span> <span class=\"number\">4000</span>\n<span class=\"method\">logger:</span> <span class=\"keyword\">false</span>\n<span class=\"method\">logger_format:</span>\n\n// <span class=\"class\">Date</span> / <span class=\"class\">Time</span> format\n// <span class=\"class\">Hexo</span> uses <span class=\"class\">Moment</span>.js to parse and display date\n// <span class=\"class\">You</span> can customize the date format as defined in\n// <span class=\"method\">http:</span>//momentjs.com/docs/#/displaying/format/\n<span class=\"method\">date_format:</span> <span class=\"class\">YYYY</span> <span class=\"class\">MMM</span> <span class=\"class\">D</span>\n<span class=\"method\">time_format:</span> <span class=\"class\">H</span>:<span class=\"method\">mm:</span>ss\n\n// <span class=\"class\">Pagination</span>\n// <span class=\"class\">Set</span> per_page to <span class=\"number\">0</span> to disable pagination\n<span class=\"method\">per_page:</span> <span class=\"number\">10</span>\n<span class=\"method\">pagination_dir:</span> page\n\n// <span class=\"class\">Disqus</span>\n<span class=\"method\">disqus_shortname:</span>\n\n// <span class=\"class\">Extensions</span>\n// <span class=\"class\">Plugins</span>: <span class=\"method\">https:</span>//github.com/tommy351/hexo/wiki/<span class=\"class\">Plugins</span>\n// <span class=\"class\">Themes</span>: <span class=\"method\">https:</span>//github.com/tommy351/hexo/wiki/<span class=\"class\">Themes</span>\n\n<span class=\"method\">plugins:</span>\n- hexo-generator-sitemap\n\n\n<span class=\"method\">theme:</span> bootstrap\n<span class=\"method\">exclude_generator:</span>\n\n// <span class=\"class\">Deployment</span>\n// <span class=\"class\">Docs</span>: <span class=\"method\">http:</span>//zespia.tw/hexo/docs/deploy.html\n<span class=\"method\">deploy:</span> \n  <span class=\"method\">type:</span> github\n  <span class=\"method\">repository:</span> <span class=\"method\">https:</span>//github.com/hufeng825/hufeng825.github.io.git\n  <span class=\"method\">branch:</span> master\n</pre></figure></code></pre>\n","excerpt":3,"source":"_posts/hexo1.md","slug":"hexo1","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"18":{"id":0,"title":"hibernate 笔记之 session","date":"2013-08-14T02:36:16.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[4],"tags":[1],"comments":true,"layout":"post","content":"<h2>session 的概述</h2>\n<a name=\"more\"></a>\n\n<ol>\n<li><p>session 接口是hibernate 向应用程序提供操作数据库最主要的接口，他提供了基本的保存，更新，删除和加载java对象的方法</p>\n</li>\n<li><p>session 具有一个缓存对象，位于缓存中的对象成为持久化对象，它和数据库中的相关记录对应，session能够在某些时间点，按照缓存中的对象变化来执行相关的sql语句。来同步更新数据库，这一过程被称为清理缓存</p>\n</li>\n<li><p>站在持久化的角度，hibernate 把对象分成四种状态：持久化状态，临界状态，游流状态 删除状态 session的特定方法能使对象从一个状态转换成另一个状态</p>\n</li>\n</ol>\n<hr>\n<h2>Session 接口</h2>\n<p>Session 是应用程序与数据库之间交互操作的一个单线程对象,是 Hibernate 运作的中心,所有持久化对象必须在 session 的管理下才可以进 行持久化操作。此对象的生命周期很短。Session 对象有一个一级缓存,显 式执行 flush 之前,所有的持久层操作的数据都缓存在 session 对象处。相 当于 JDBC 中的 Connection。</p>\n<p>• 持久化类与 Session 关联起来后就具有了持久化的能力。</p>\n<p>• Session 类的方法:</p>\n<ul>\n<li><p>取得持久化对象的方法: get() load()</p>\n</li>\n<li><p>持久化对象都得保存,更新和删除: save(),update(),saveOrUpdate(),delete()</p>\n</li>\n<li><p>开启事务: beginTransaction().</p>\n</li>\n<li><p>管理 Session 的方法:isOpen(),flush(), clear(), evict(), close()等</p>\n</li>\n</ul>\n<figure class=\"highlight\"><pre>import java<span class=\"preprocessor\">.util</span><span class=\"preprocessor\">.Date</span><span class=\"comment\">;</span>\nimport java<span class=\"preprocessor\">.util</span><span class=\"preprocessor\">.UUID</span><span class=\"comment\">;</span>\n\nimport org<span class=\"preprocessor\">.hibernate</span><span class=\"preprocessor\">.Hibernate</span><span class=\"comment\">;</span>\nimport org<span class=\"preprocessor\">.hibernate</span><span class=\"preprocessor\">.Session</span><span class=\"comment\">;</span>\nimport org<span class=\"preprocessor\">.hibernate</span><span class=\"preprocessor\">.Transaction</span><span class=\"comment\">;</span>\n\nimport <span class=\"keyword\">com</span><span class=\"preprocessor\">.vince</span><span class=\"preprocessor\">.entity</span><span class=\"preprocessor\">.User</span><span class=\"comment\">;</span>\nimport <span class=\"keyword\">com</span><span class=\"preprocessor\">.vince</span><span class=\"preprocessor\">.util</span><span class=\"preprocessor\">.HibernateUtil</span><span class=\"comment\">;</span>\n\n\npublic class Test {\n\t\n\t\n\tpublic static void evict(){\n\t\t\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\n\t\tUser user = new User(<span class=\"string\">\"test-7\"</span>,<span class=\"number\">17</span>,new Date())<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.save</span>(user)<span class=\"comment\">;</span>\n\t\t\n\t\tsession<span class=\"preprocessor\">.evict</span>(user)<span class=\"comment\">;//把对象从session中清除,在批量处理时，避免session中缓存的对象太多，会导致内存溢出</span>\n//\t\tsession<span class=\"preprocessor\">.clear</span>()<span class=\"comment\">;//清除session中所有的缓存对象</span>\n\t\tUser user2 = (User)session<span class=\"preprocessor\">.load</span>(User<span class=\"preprocessor\">.class</span>, user<span class=\"preprocessor\">.getId</span>())<span class=\"comment\">;</span>\n\t\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(user2)<span class=\"comment\">;</span>\n\t\t\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t}\n\t\n\t\n\t\n\t<span class=\"comment\">/**\n\t * merge方法：合并,保存或更新\n\t * \n\t * \n\t */</span>\n\tpublic static void merge(){\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\n\t\t//情况一：临时对象(新创建的对象)\n\t\t//<span class=\"number\">1</span>)user1 的状态是瞬时对象时，创建一个新的对象user2,把user1对象的属性拷贝到新建的user2对象中,持久化这个user2对象,执行insert语句\n//\t\tUser user1 = new User()<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setAge</span>(<span class=\"number\">22</span>)<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"test--3\"</span>)<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setCreateDate</span>(new Date())<span class=\"comment\">;</span>\n//\t\t\n//\t\t\n//\t\tUser user2 = (User)session<span class=\"preprocessor\">.merge</span>(user1)<span class=\"comment\">;</span>\n//\t\t\n//\t\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(user1==user2)<span class=\"comment\">;</span>\n\t\t\n\t\t//情况二：user1 的状态是游离对象时，Session缓存中是否存在ID为与user1相同的持久化对象\n\t\t//(<span class=\"number\">1</span>)如果有\n//\t\tUser user2 = (User)session<span class=\"preprocessor\">.load</span>(User<span class=\"preprocessor\">.class</span>, <span class=\"number\">1</span>)<span class=\"comment\">;</span>\n//\t\tUser user1 = new User()<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setAge</span>(<span class=\"number\">20</span>)<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setCreateDate</span>(new Date())<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setId</span>(<span class=\"number\">1</span>)<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"test---4\"</span>)<span class=\"comment\">;</span>\n//\t\tsession<span class=\"preprocessor\">.merge</span>(user1)<span class=\"comment\">;</span>\n\t\t\n\t\t\n\t\t\n\t\t//情况三：如果session中不存在该对象，那么去数据库中查询是否存在该ID的记录，\n\t\t//如果存在，那么就加载这条记录到session中(user2)，比较两个对象属性是否一致，\n\t\t//如果不一致，就把user1的属性拷贝到user2中，执行update语句\n\t\t//如果一致，就不执行任何操作\n//\t\tUser user1 = new User()<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setAge</span>(<span class=\"number\">22</span>)<span class=\"comment\">;</span>\n////\t\tuser1<span class=\"preprocessor\">.setCreateDate</span>(new Date())<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setId</span>(<span class=\"number\">5</span>)<span class=\"comment\">;</span>\n//\t\tuser1<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"aaa\"</span>)<span class=\"comment\">;</span>\n//\t\tsession<span class=\"preprocessor\">.merge</span>(user1)<span class=\"comment\">;</span>\n\t\t\n\t\t//情况四：如果session中不存在该对象，那么去数据库中查询是否存在该ID的记录，\n\t\t//如果不存在，创建一个新的对象user2,把user1对象的属性拷贝到新建的user2对象中,\n\t\t//持久化这个user2对象,执行insert语句\n\t\tUser user1 = new User()<span class=\"comment\">;</span>\n\t\tuser1<span class=\"preprocessor\">.setAge</span>(<span class=\"number\">22</span>)<span class=\"comment\">;</span>\n\t\tuser1<span class=\"preprocessor\">.setCreateDate</span>(new Date())<span class=\"comment\">;</span>\n\t\tuser1<span class=\"preprocessor\">.setId</span>(<span class=\"number\">6</span>)<span class=\"comment\">;</span>\n\t\tuser1<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"bbb\"</span>)<span class=\"comment\">;</span>\n\t\tUser user2 = (User)session<span class=\"preprocessor\">.merge</span>(user1)<span class=\"comment\">;</span>\n\t\t\n\t\t\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\t\n\t}\n\t\n\t<span class=\"comment\">/**\n\t * saveOrUpdate 方法：执行保存或更新\n\t * 1、如果实体对象是临时状态（没有ID），那么该方法将执行保存操作\n\t * 2、如果实体对象是游离状态（有ID），那么该方法以将执行更新操作\n\t * \t如果数据库不存在该ID，那么更新将抛出异常\n\t * 3、判断ID是否为空（整型ID 0 空），根据映射文件中的unsaved-value\n\t * \t属性值来判断\n\t */</span>\n\tpublic static void saveOrUpdate(){\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\n\t\tUser user = new User()<span class=\"comment\">;</span>\n\t\tuser<span class=\"preprocessor\">.setAge</span>(<span class=\"number\">21</span>)<span class=\"comment\">;</span>\n\t\tuser<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"test--1\"</span>)<span class=\"comment\">;</span>\n\t\tuser<span class=\"preprocessor\">.setCreateDate</span>(new Date())<span class=\"comment\">;</span>\n\t\tuser<span class=\"preprocessor\">.setId</span>(<span class=\"number\">3</span>)<span class=\"comment\">;</span>\n\t\t\n\t\tsession<span class=\"preprocessor\">.saveOrUpdate</span>(user)<span class=\"comment\">;</span>\n\t\t\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t}\n\t\n\t\n\tpublic static void delete(){\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\n//\t\tUser user = new User()<span class=\"comment\">;</span>\n//\t\tuser<span class=\"preprocessor\">.setId</span>(<span class=\"number\">6</span>)<span class=\"comment\">;</span>\n//\t\tuser<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"xxx\"</span>)<span class=\"comment\">;</span>\n\t\t\n\t\tUser user = (User)session<span class=\"preprocessor\">.load</span>(User<span class=\"preprocessor\">.class</span>, <span class=\"number\">3</span>)<span class=\"comment\">;</span>\n\t\t\n\t\tsession<span class=\"preprocessor\">.delete</span>(user)<span class=\"comment\">;</span>\n\t\t\n\t\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(user<span class=\"preprocessor\">.getId</span>())<span class=\"comment\">;</span>\n\t\t\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t}\n\t\n\t<span class=\"comment\">/**\n\t * 更新对象:通过update方法\n\t * 1、如果数据库中不存在ID的记录，抛出异常\n\t * 2、默认生成的SQL语句会根据ID为条件更新所有字段，\n\t * 如果只更新发生变化的字段，那么在映射文件的class配置中添加 dynamic-update=true\n\t * \n\t */</span>\n\tpublic static void update2(){\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\t\n//\t\tUser user = new User(<span class=\"string\">\"Tom-1\"</span>,<span class=\"number\">23</span>,new Date())<span class=\"comment\">;</span>\n\t\tUser user = (User)session<span class=\"preprocessor\">.get</span>(User<span class=\"preprocessor\">.class</span>, <span class=\"number\">1</span>)<span class=\"comment\">;</span>\n\t\t\n\t\tuser<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"888\"</span>)<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.update</span>(user)<span class=\"comment\">;</span>\n\t\t\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t}\n\t<span class=\"comment\">/**\n\t * 更新对象\n\t * 通过session 的脏数据机制\n\t */</span>\n\tpublic static void update1(){\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\tUser user = (User)session<span class=\"preprocessor\">.load</span>(User<span class=\"preprocessor\">.class</span>, <span class=\"number\">1</span>)<span class=\"comment\">;</span>\n\t\tuser<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"xxx\"</span>)<span class=\"comment\">;</span>\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t}\n\t\n\t<span class=\"comment\">/**\n\t * load方法：\n\t * 1、如果数据库不存在记录，那么将抛出异常\n\t * 2、load方法先执行延迟加载，返回代理对象，在真正使用到该对象时才会\n\t * 从数据库中查询\n\t * 3、初始化代理对象的方法：\n\t * （1）调用代理对象的非主键属性\n\t * （2）Hibernate.initialize()方法初始化代理对象\n\t */</span>\n\tpublic static User load(){\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\tUser user = (User)session<span class=\"preprocessor\">.load</span>(User<span class=\"preprocessor\">.class</span>, <span class=\"number\">5</span>)<span class=\"comment\">;</span>\n\t\t\n//\t\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(user<span class=\"preprocessor\">.getName</span>())<span class=\"comment\">;</span>\n\t\tHibernate<span class=\"preprocessor\">.initialize</span>(user)<span class=\"comment\">;//初始化代理对象</span>\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\t\n\t\treturn user<span class=\"comment\">;</span>\n\t}\n\t\n\t<span class=\"comment\">/**\n\t * get方法：\n\t * 1、立即从数据库中查询数据\n\t * 2、如果数据库不存在记录，那么将返回null\n\t */</span>\n\tpublic static void get(){\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\tClass c = User<span class=\"preprocessor\">.class</span><span class=\"comment\">;</span>\n\t\tUser user = (User)session<span class=\"preprocessor\">.get</span>(c, <span class=\"number\">1</span>)<span class=\"comment\">;</span>\n\t\tif(user!=null){\n\t\t//修改时间\n\t\tuser<span class=\"preprocessor\">.setCreateDate</span>(new Date())<span class=\"comment\">;</span>\n\t\t}\n\t\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(user)<span class=\"comment\">;</span>\n\t\t\n//\t\tsession<span class=\"preprocessor\">.flush</span>()<span class=\"comment\">;//刷新缓冲</span>\n\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t}\n\t\n\t<span class=\"comment\">/**\n\t * save()方法以会立即为持久化对象设置主键，所有在任何时候会执行insert语句\n\t * persist()，如果在事务内部那么与save()一样，如果在事务外部，不会立即执行\n\t * insert语句\n\t */</span>\n\tpublic static void save(){\n//\t\tUser user = new User(<span class=\"string\">\"jack\"</span>,<span class=\"number\">22</span>,new Date())<span class=\"comment\">;</span>\n\t\tUser user = new User()<span class=\"comment\">;</span>\n\t\tuser<span class=\"preprocessor\">.setName</span>(<span class=\"string\">\"jack\"</span>)<span class=\"comment\">;</span>\n\t\tSession session = HibernateUtil<span class=\"preprocessor\">.getSession</span>()<span class=\"comment\">;</span>\n//\t\tTransaction tx = session<span class=\"preprocessor\">.beginTransaction</span>()<span class=\"comment\">;</span>\n\t\tsession<span class=\"preprocessor\">.save</span>(user)<span class=\"comment\">;</span>\n//\t\tsession<span class=\"preprocessor\">.persist</span>(user)<span class=\"comment\">;</span>\n\t\t\n//\t\ttx<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\t\t\n\t\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n//\t\tsave()<span class=\"comment\">;</span>\n//\t\tget()<span class=\"comment\">;</span>\n//\t\tUser user = load()<span class=\"comment\">;</span>\n//\t\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(user)<span class=\"comment\">;</span>\n\t\t\n//\t\tupdate1()<span class=\"comment\">;</span>\n//\t\tupdate2()<span class=\"comment\">;</span>\n\t\t\n//\t\tdelete()<span class=\"comment\">;</span>\n//\t\tsaveOrUpdate()<span class=\"comment\">;</span>\n//\t\tmerge()<span class=\"comment\">;</span>\n//\t\tevict()<span class=\"comment\">;</span>\n\t\t\n//\t\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(UUID<span class=\"preprocessor\">.randomUUID</span>()<span class=\"preprocessor\">.toString</span>())<span class=\"comment\">;</span>\n\t}\n\n}\n</pre></figure>\n\n","excerpt":21,"source":"_posts/hibernate1.md","slug":"hibernate1","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"19":{"id":0,"title":"mac 下的默认配置","date":"2013-08-31T13:45:59.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1,6],"tags":[1],"comments":true,"layout":"post","content":"<p>请几天安装其他的shell 结果把默认的shell更改了  有没有快捷的方法更换会默认配置 <a name=\"more\"></a>其实mac 下 有一个很简单命令可以搞定这些用户默认设置\n打开终端社着敲敲如下的命令</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"attribute\">chsh\n</pre></figure></code></pre>\n<img src=\"http://ww3.sinaimg.cn/mw690/a43af4ffjw1e866tu4f66j20a107sq3i.jpg\" class=\"left\" title=\"运行效果 300  400\">\n","excerpt":49,"source":"_posts/ios10.md","slug":"ios10","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"20":{"id":0,"title":"银行支付控件之 自动随机(shuffle)密码键盘的实现算法","date":"2013-08-31T14:05:28.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>为了广大用户的支付安全,输入密码的页面密码键盘要用随机排序,因为有版权问题无法把自己写的代码全部贴出 所以下面只把关键的洗牌算法贴出来</p>\n<h2>算法一</h2>\n<figure class=\"highlight\"><pre>NSMutableArray *randSequence = <span class=\"string\">[[NSMutableArray alloc] initWithCapacity:8];\nfor (int ii = 0; ii &lt; 10; ++ii)\n    [randSequence addObject:[NSNumber numberWithInt:ii]]</span>;\n\n<span class=\"keyword\">for</span> (int ii = <span class=\"number\">9</span>; ii &gt; -<span class=\"number\">1</span>; <span class=\"comment\">--ii) {</span>\n    int r = arc4random() % <span class=\"number\">9</span>\n    [randSequence exchangeObjectAtIndex:ii withObjectAtIndex:r];\n</pre></figure>\n\n<h2>算法二</h2>\n<figure class=\"highlight\"><pre>\n@<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">NSMutableArray</span> (<span class=\"title\">Shuffling</span>)\n- (<span class=\"title\">void</span>)<span class=\"title\">shuffle</span>;\n@<span class=\"title\">end</span>\n\n\n//  <span class=\"title\">NSMutableArray_Shuffling</span>.<span class=\"title\">m</span>\n\n#<span class=\"title\">import</span> \"<span class=\"title\">NSMutableArray_Shuffling</span>.<span class=\"title\">h</span>\"\n\n@<span class=\"title\">implementation</span> <span class=\"title\">NSMutableArray</span> (<span class=\"title\">Shuffling</span>)\n\n- (<span class=\"title\">void</span>)<span class=\"title\">shuffle</span>\n{</span>\n    NSUInteger <span class=\"keyword\">count</span> = [self <span class=\"keyword\">count</span>];\n    <span class=\"keyword\">for</span> (NSUInteger i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">count</span>; ++i) {\n        <span class=\"comment\">// Select a random element between i and end of array to swap with.</span>\n        NSInteger nElements = <span class=\"keyword\">count</span> - i;\n        NSInteger n = (arc4random() % nElements) + i;\n        [self exchangeObjectAtIndex:i withObjectAtIndex:n];\n    }\n}\n\n@end\n</pre></figure>\n\n","excerpt":0,"source":"_posts/ios11.md","slug":"ios11","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"21":{"id":0,"title":"ios 开发之 序列化","date":"2013-08-31T14:26:47.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[5],"tags":[1],"comments":true,"layout":"post","content":"<p>序列化</p>\n<p>参考原始文档：</p>\n<p><a href=\"https://github.com/mystcolor/JTObjectMapping\">https://github.com/mystcolor/JTObjectMapping</a></p>\n<p><a name=\"more\"></a>\n使用方法</p>\n<p>========</p>\n<p>绝大多数情况下，需要用到的就是一个方法：</p>\n<p>[NSObject objectFromJSONObject:stateObject mapping:nil];</p>\n<p>其中，把NSObject换成我们想映射成的类的名字。</p>\n<p>稍微复杂一点，假设类的属性和JSON里的key名字不是一一对应的，那么就要写一个映射关系表作为mapping参数：</p>\n<pre><code><figure class=\"highlight\"><pre>NSDictionary <span class=\"variable\">*mapping</span> = [NSDictionary dictionaryWithObjectsAndKeys:\n\n                         <span class=\"variable\">@\"</span>myState<span class=\"string\">\", <span class=\"variable\">@\"</span>state\"</span>,\n\n                         <span class=\"variable\">@\"</span>movieList<span class=\"string\">\", <span class=\"variable\">@\"</span>movie\"</span>,\n\n                         nil];\n\n[NSObject objectFromJSONObject:stateObject mapping:mapping];\n</pre></figure></code></pre>\n<p>如果再复杂一点，我们需要映射一个数组，数组的每个元素映射到一个对象，那么就用到第2个方法：</p>\n<p>[NSObject mappingWithKey:@&quot;responseState&quot; mapping:nil]</p>\n<p>同样，把NSObject换成数组元素对应的类，key是用来存放整个数组的那个属性。</p>\n<p>注意</p>\n<p>====</p>\n<p>JSON里的字符串，是能自动映射成NSNumber或者int型的，不需要特别写代码。如果想把一个字符串日期，映射成NSDate型，请参考原始文档。</p>\n<p>具体举个例子</p>\n<p>===========</p>\n<p>假设我们有这样一段JSON：</p>\n<p> {</p>\n<p> &quot;state&quot;:[</p>\n<p> {</p>\n<p> &quot;respCode&quot;:&quot;0000&quot;,</p>\n<p> &quot;respMsg&quot;:&quot;1&quot;</p>\n<p> }</p>\n<p> ],</p>\n<p> &quot;movie&quot;:[</p>\n<p> {</p>\n<p> &quot;body&quot;:&quot;    一开始，这只是叶问的故事他生于佛山&quot;,</p>\n<p> &quot;pics&quot;:&quot;/images/jz/4779-1-20121225133147.jpg,/images/jz/4779-2-20121225133147.jpg&quot;,</p>\n<p> &quot;name&quot;:&quot;一代宗师&quot;,</p>\n<p> &quot;movid&quot;:&quot;4779&quot;,</p>\n<p> &quot;length&quot;:&quot;120&quot;,</p>\n<p> &quot;hasplan&quot;:&quot;1&quot;,</p>\n<p> &quot;trailor&quot;:&quot;/4779.m4v&quot;,</p>\n<p> &quot;director&quot;:&quot;梁朝伟 章子怡 张震 &quot;,</p>\n<p> &quot;type&quot;:&quot;动作/传记/剧情/IMAX&quot;,</p>\n<p> &quot;url&quot;:&quot;<a href=\"http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&amp;w=140\">http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&amp;w=140</a>&quot;,</p>\n<p> &quot;popularity&quot;:&quot;6&quot;</p>\n<p> },</p>\n<p> {</p>\n<p> ...</p>\n<p> }</p>\n<p> ]</p>\n<p> }</p>\n<p>现在，想把它映射到自定义的对象中去。有几种情况：</p>\n<p>第一种情况，简单地把state数组里面的第一个元素映射成一个FGStateModel类</p>\n<p>那么就是，取出这个节点：</p>\n<pre><code><figure class=\"highlight\"><pre>NSDictionary *stateObject = <span class=\"string\">[[self.json objectForKey:@\"state\"] objectAtIndex:0];\n</pre></figure></code></pre>\n<p>然后，执行映射：</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"keyword\">self</span>.state = [<span class=\"class\">FGStateModel</span> <span class=\"method\">objectFromJSONObject:</span>stateObject <span class=\"method\">mapping:</span><span class=\"keyword\">nil</span>];\n</pre></figure></code></pre>\n<p>第二种情况，把movie这个字典数组映射成一个数组，数组的每个元素是FGMovieModel</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"class\">NSArray</span> *movieObject = [<span class=\"keyword\">self</span>.json <span class=\"method\">objectForKey:</span>@<span class=\"comment\">\"movie\"</span>];\n\n<span class=\"keyword\">self</span>.movieList = [<span class=\"class\">FGMovieModel</span> <span class=\"method\">objectFromJSONObject:</span>movieObject <span class=\"method\">mapping:</span><span class=\"keyword\">nil</span>];\n</pre></figure></code></pre>\n<p>第三种情况，如果对象的属性和JSON名字不一样，可以使用映射表，例如我们想把上面整个json对象映射成一个 FGResponseModel 对象，其中，state数组映射成 responseState 属性，movie 数组映射成 movieList 属性。那么，我们需要告诉映射器这个数组里的元素要映射成什么对象。</p>\n<p>所以，通过 mapping 这个参数告诉它：“请把 JSON 里的 state 数组里的每个元素映射成一个 FGStateModel 对象，并且把最终的数组放到responseState这个属性里。另外，把 movie 这个数组映射成一个 FGMovieModel 数组，并且保存到 movieList 这个属性中。“</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"class\">NSDictionary</span> *mapping = [<span class=\"class\">NSDictionary</span> <span class=\"method\">dictionaryWithObjectsAndKeys:</span>\n\n                         [<span class=\"class\">FGStateModel</span> <span class=\"method\">mappingWithKey:</span>@<span class=\"comment\">\"responseState\"</span> <span class=\"method\">mapping:</span><span class=\"keyword\">nil</span>], @<span class=\"comment\">\"state\"</span>,\n\n                         [<span class=\"class\">FGMovieModel</span> <span class=\"method\">mappingWithKey:</span>@<span class=\"comment\">\"movieList\"</span> <span class=\"method\">mapping:</span><span class=\"keyword\">nil</span>], @<span class=\"comment\">\"movie\"</span>,\n\n                         <span class=\"keyword\">nil</span>];\n\n<span class=\"keyword\">self</span>.response = [<span class=\"class\">FGResponseModel</span> <span class=\"method\">objectFromJSONObject:</span><span class=\"keyword\">self</span>.json <span class=\"method\">mapping:</span>mapping];\n</pre></figure></code></pre>\n<figure class=\"highlight\"><pre><span class=\"preprocessor\">#import &lt;Foundation/Foundation.h&gt;</span>\n\n\n@<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FGMovieModel</span> : <span class=\"title\">NSObject</span>\n\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSString</span> *<span class=\"title\">body</span>;\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSString</span> *<span class=\"title\">pics</span>;\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSString</span> *<span class=\"title\">name</span>;\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">assign</span>) <span class=\"title\">NSInteger</span> <span class=\"title\">movid</span>;\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSNumber</span> *<span class=\"title\">length</span>;\n\n\n@<span class=\"title\">end</span>\n</pre></figure>\n\n<figure class=\"highlight\"><pre><span class=\"preprocessor\">#import &lt;Foundation/Foundation.h&gt;</span>\n\n\n@<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FGResponseModel</span> : <span class=\"title\">NSObject</span>\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSArray</span> *<span class=\"title\">responseState</span>;\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSArray</span> *<span class=\"title\">movieList</span>;\n\n@<span class=\"title\">end</span>\n\n \n#<span class=\"title\">import</span> &lt;<span class=\"title\">Foundation</span>/<span class=\"title\">Foundation</span>.<span class=\"title\">h</span>&gt;\n\n\n@<span class=\"title\">interface</span> <span class=\"title\">FGStateModel</span> : <span class=\"title\">NSObject</span>\n\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSString</span> *<span class=\"title\">respCode</span>;\n\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">retain</span>) <span class=\"title\">NSString</span> *<span class=\"title\">respMsg</span>;\n\n\n@<span class=\"title\">end</span>\n</pre></figure>\n\n","excerpt":140,"source":"_posts/ios12.md","slug":"ios12","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"22":{"id":0,"title":"复杂页面消退的一个简单实例","date":"2013-08-31T14:42:52.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>如图</p>\n<img src=\"http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8680v5hirj20df09qglv.jpg\" class=\"left\" height=\"400\" title=\"600\">\n\n\n<p><a name=\"more\"></a>\n实现上面的这个又两种实现方式 </p>\n<ul>\n<li><p>一种是给页面1 发广播通知 </p>\n</li>\n<li><p>另外一种就是我要介绍的</p>\n</li>\n</ul>\n<figure class=\"highlight\"><pre> [(<span class=\"built_in\">UINavigationController</span>*)<span class=\"keyword\">self</span><span class=\"variable\">.parentViewController</span><span class=\"variable\">.presentingViewController</span>\n\n     popToRootViewControllerAnimated:<span class=\"literal\">YES</span>];\n\n    [<span class=\"keyword\">self</span> dismissModalViewControllerAnimated:<span class=\"literal\">YES</span>];\n</pre></figure>\n\n","excerpt":130,"source":"_posts/ios13.md","slug":"ios13","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"23":{"id":0,"title":"如何清空 NSUserDefaults 下所有数据","date":"2013-09-02T00:18:20.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>每个app 难免要在NSUserDefaults中记一些数据,但这些数据某些清空下药全部清空,比如系统版本升级啦,后台存储数据结构变更啦\n<a name=\"more\"></a>\n下面给出的代码端就是清空NSUserDefaults的一个实现</p>\n<figure class=\"highlight\"><pre>  <span class=\"keyword\">if</span> (!<span class=\"string\">[[NSUserDefaults standardUserDefaults] boolForKey:@\"dontClearHXCache\"])\n\n    {\n\n        NSString *appDomainStr = [[NSBundle mainBundle] bundleIdentifier];\n\n        [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomainStr];\n\n        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"dontClearHXCache\"];\n\n       [[NSUserDefaults standardUserDefaults]synchronize];\n\n    }\n\n    else\n\n    {\n\n        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"dontClearHXCache\"];\n\n        [[NSUserDefaults standardUserDefaults]synchronize];\n\n\n\n    }\n</pre></figure>\n\n","excerpt":72,"source":"_posts/ios14.md","slug":"ios14","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"24":{"id":0,"title":"善用 NSAutoreleasePool 节约宝贵内存","date":"2013-09-02T00:26:20.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>autorelease自动释放内存，并不会立即把内存释放掉，而是要等到下一个事件周期才会释放掉。问题是一些资源我们不得不使用autorelease类型，比如作为函数的返回值，而且系统api及项目是的大部分也都是这么做的，如果全都依靠我们手动释放很容易造成内存泄漏。\n<a name=\"more\"></a></p>\n<pre><code><figure class=\"highlight\"><pre>     <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">10000</span>; i ++) {\n\n        //创建一个自动释放池\n\n         NSAutoreleasePool *pool = [NSAutoreleasePool new];\n\n         NSString *filePath = <span class=\"string\">[[NSBundle mainBundle] pathForResource:@\"hf\" ofType:@\"PNG\"];\n\n         UIImage *image = [[UIImage alloc] initWithContentsOfFile:filePath];\n\n         UIImage *scalimage = [image imageByScalingAndCroppingForSize:CGSizeMake(320, 640)];\n\n         [image release];\n\n        //将自动释放池内存释放，它会同时释放掉上面代码中产生的临时变量image2\n\n         [pool drain];\n\n     }\n</pre></figure></code></pre>\n","excerpt":136,"source":"_posts/ios16.md","slug":"ios16","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"25":{"id":0,"title":"如何禁用禁用uwebiview 的反弹功能(bounces)","date":"2013-09-02T00:23:19.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>UIWebView默认允许当网页内容处于最顶端时，用户可以用手指往下拖动，露出空白的背景\n如何禁用呢\n// iOS 5之前</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"keyword\">for</span> (id subview <span class=\"keyword\">in</span> webView.subviews)\n  <span class=\"keyword\">if</span> (<span class=\"string\">[[subview class] isSubclassOfClass: [UIScrollView class]]</span>)\n    ((UIScrollView *)subview).bounces = NO;\n</pre></figure></code></pre>\n<p>// iOS 5+</p>\n<pre><code><figure class=\"highlight\"><pre>webView<span class=\"variable\">.scrollView</span><span class=\"variable\">.bounces</span> = <span class=\"literal\">NO</span>;\n</pre></figure></code></pre>\n","excerpt":0,"source":"_posts/ios15.md","slug":"ios15","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"26":{"id":0,"title":"(NSDate) 时间 (time )比较","date":"2013-09-02T00:31:25.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>做订餐app时对下单时间的时间判断\n下面是规则</p>\n<ul>\n<li>9:00-14:00 可以订餐</li>\n<li>14:00以后掌上餐厅仅接收晚餐订餐</li>\n<li>21:00以后掌上餐厅不接收订餐</li>\n</ul>\n<img src=\"http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87ve4c3ynj208q0abt9n.jpg\" class=\"left\" title=\"截图 300 400\">\n\n\n<h2><a name=\"more\"></a></h2>\n<h2>转换函数</h2>\n<p> 将传入的小时和分钟 转换成当日的date</p>\n<p> 例如传入 8：00 的str 返回 2013-01-01 08：00 的nsdate</p>\n<figure class=\"highlight\"><pre>-(NSDate <span class=\"variable\">*)</span>CurrentDayTime:(NSString <span class=\"variable\">*)</span>dataStr\n\n{\n\n    <span class=\"regexp\">//</span>设置转换的<span class=\"keyword\">format</span>\n\n    NSDateFormatter <span class=\"variable\">*dateFormatter</span> = [[[NSDateFormatteralloc]init]autorelease];\n\n    [dateFormatter setLocale:[NSLocalecurrentLocale]];\n\n    \n\n    [dateFormatter setDateFormat:<span class=\"variable\">@\"</span>yyyy-MM-dd HH:mm<span class=\"string\">\"];\n\n    //获取当前年月日 \n\n    NSDate <span class=\"variable\">*currentdate</span> = [NSDatedate];\n\n    NSCalendar <span class=\"variable\">*calendar</span> = [NSCalendarcurrentCalendar];\n\n    NSDateComponents <span class=\"variable\">*components</span> = [calendarcomponents:(\n\n                                                         NSYearCalendarUnit  |\n\n                                                         NSMonthCalendarUnit |\n\n                                                         NSDayCalendarUnit |\n\n                                                         NSHourCalendarUnit |\n\n                                                         NSMinuteCalendarUnit\n\n                                                         ) fromDate:currentdate];\n\n   NSInteger year = [components year];\n\n   NSInteger month = [components month];\n\n   NSInteger day = [components day];\n\n   NSString <span class=\"variable\">*strDate</span> = [NSString stringWithFormat:<span class=\"variable\">@\"</span><span class=\"variable\">%d</span>-<span class=\"variable\">%d</span>-<span class=\"variable\">%d</span> <span class=\"variable\">%@</span>\"</span>,year,month,day,dataStr];\n\n   NSDate <span class=\"variable\">*date</span> = [dateFormatter dateFromString:strDate];\n\n   <span class=\"keyword\">return</span> date;\n\n}\n</pre></figure>\n\n<hr>\n<h2>比较算法</h2>\n<figure class=\"highlight\"><pre>NSLog(<span class=\"variable\">@\"</span><span class=\"variable\">%@</span>\\n<span class=\"variable\">%@</span><span class=\"string\">\",[selfCurrentDayTime:<span class=\"variable\">@\"</span>18:00\"</span>] ,[NSDatedate]);\n\n    NSDate <span class=\"variable\">*date</span> = [NSDatedate];\n\n    <span class=\"keyword\">if</span> ([datecompare:[selfCurrentDayTime:<span class=\"variable\">@\"</span><span class=\"number\">18</span>:<span class=\"number\">00</span><span class=\"string\">\"]] ==NSOrderedDescending)\n\n    {\n\n        NSLog(<span class=\"variable\">@\"</span>date1 is later than date2\"</span>);\n\n        \n\n    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([datecompare:[selfCurrentDayTime:<span class=\"variable\">@\"</span><span class=\"number\">18</span>:<span class=\"number\">00</span><span class=\"string\">\"]] ==NSOrderedAscending)\n\n    {\n\n        NSLog(<span class=\"variable\">@\"</span>date1 is earlier than date2\"</span>);\n\n        \n\n    } <span class=\"keyword\">else</span>\n\n    {\n\n        NSLog(<span class=\"variable\">@\"</span>dates are the same<span class=\"string\">\");\n\n        \n\n    }\n</pre></figure>\n\n<h2>用法如下</h2>\n<figure class=\"highlight\"><pre>-(BOOL)checkCanDinner\n\n{\n\n    NSDate *currentDate = [NSDatedate];\n\n    <span class=\"keyword\">if</span> ([currentDate compare:[selfCurrentDayTime:<span class=\"string\">@\"08:59\"</span>]] == NSOrderedDescending <span class=\"comment\">//late</span>\n\n        && [currentDate compare:[selfCurrentDayTime:<span class=\"string\">@\"13:59\"</span>]] == NSOrderedAscending <span class=\"comment\">//early</span>\n\n        )\n\n    {\n\n        <span class=\"comment\">//9:00-14:00 可以订餐</span>\n\n        <span class=\"keyword\">return</span> YES;\n\n    }\n\n    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>([currentDatecompare:[self CurrentDayTime:<span class=\"string\">@\"09:00\"</span>]] ==NSOrderedAscending <span class=\"comment\">//early</span>\n\n            && [currentDate compare:[selfCurrentDayTime:<span class=\"string\">@\"00:00\"</span>]] ==  NSOrderedDescending<span class=\"comment\">//late</span>\n\n            )\n\n    {\n\n        HFAlert(<span class=\"string\">@\"因较多餐厅休息,9:00之前掌上餐厅不接收订餐，为您带来的不便请谅解。\"</span>);\n\n        <span class=\"keyword\">return</span> NO;\n\n    }\n\n    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>([currentDatecompare:[self CurrentDayTime:<span class=\"string\">@\"17:59\"</span>]] ==NSOrderedAscending <span class=\"comment\">//early</span>\n\n            && [currentDate compare:[selfCurrentDayTime:<span class=\"string\">@\"14:00\"</span>]] ==  NSOrderedDescending<span class=\"comment\">//late</span>\n\n            )\n\n    {\n\n        HFAlert(<span class=\"string\">@\"因较多餐厅休息,14:00以后掌上餐厅仅接收晚餐订餐,为您带来的不便请谅解。\"</span>);\n\n        <span class=\"keyword\">return</span> YES;\n\n    }\n\n    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>([currentDatecompare:[self CurrentDayTime:<span class=\"string\">@\"21:00\"</span>]] ==NSOrderedAscending <span class=\"comment\">//early</span>\n\n            && [currentDate compare:[selfCurrentDayTime:<span class=\"string\">@\"18:00\"</span>]] ==  NSOrderedDescending<span class=\"comment\">//late</span>\n\n            )\n\n    {\n\n        <span class=\"comment\">//接受晚上的订单</span>\n\n        <span class=\"keyword\">return</span> YES;\n\n    }\n\n    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>([currentDatecompare:[self CurrentDayTime:<span class=\"string\">@\"23:59\"</span>]] ==NSOrderedAscending <span class=\"comment\">//early</span>\n\n            && [currentDate compare:[selfCurrentDayTime:<span class=\"string\">@\"21:00\"</span>]] ==  NSOrderedDescending<span class=\"comment\">//late</span>\n\n            )\n\n    {\n\n        HFAlert(<span class=\"string\">@\"因较多餐厅休息,21:00以后掌上餐厅不接收订餐,为您带来的不便请谅解。\"</span>);\n\n        <span class=\"keyword\">return</span> NO;\n\n    }\n\n    <span class=\"keyword\">return</span> YES;\n\n}\n</pre></figure>\n\n","excerpt":236,"source":"_posts/ios17.md","slug":"ios17","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"27":{"id":0,"title":"父View禁用touch 如何让子view还能获取touch event","date":"2013-09-02T01:14:30.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<img src=\"http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87vwh4ocsj20a70dcjrp.jpg\" class=\"left\" width=\"300\" height=\"400\">\n\n<p><a name=\"more\"></a>\n如上图 当view2 包含在view1中,默认清空下 view1 的touch事件被禁用掉侯view2 肯定是接收不到touch事件的,那有没有什么办法能够让view2接收到touch事件呢?\n其实很简单hitTest 可以帮我们实现这个需求</p>\n<figure class=\"highlight\"><pre>uiview addition\n-(<span class=\"keyword\">id</span>)hitTest:(<span class=\"built_in\">CGPoint</span>)point withEvent:(UIEvent *)event {\n    <span class=\"keyword\">id</span> hitView = [<span class=\"keyword\">super</span> hitTest:point withEvent:event];\n    <span class=\"keyword\">if</span> (hitView == <span class=\"keyword\">self</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;\n    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> hitView;\n}\n</pre></figure>\n\n","excerpt":119,"source":"_posts/ios18.md","slug":"ios18","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"28":{"id":0,"title":"如何得到中英文混合下的NSString的长度?","date":"2013-09-02T01:21:21.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>这个貌似很简单但却是把我跟招行的兄弟难为了好久,为毛?还不是因为招行信用卡中心的网络无法连接外网无法谷歌度娘最后我们只能查看文档写test\n下面是最后我们得到的两个方法\n<a name=\"more\"></a></p>\n<h2>方法一:</h2>\n<pre><code><figure class=\"highlight\"><pre>- (<span class=\"keyword\">int</span>)getStringLength:(NSString<span class=\"variable\">*)</span>strtemp\n{\n\nNSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_200<span class=\"number\">0</span>);\n\n    NSData* da = [strtemp dataUsingEncoding:enc];\n\n    <span class=\"keyword\">return</span> [da <span class=\"keyword\">length</span>];\n\n}\n</pre></figure></code></pre>\n<h2>方法二:</h2>\n<pre><code><figure class=\"highlight\"><pre>- (<span class=\"keyword\">int</span>)convertToInt:(NSString<span class=\"variable\">*)</span>strtemp\n\n{\n\n    <span class=\"keyword\">int</span> strlength = <span class=\"number\">0</span>;\n\n    char* p = (char<span class=\"variable\">*)</span>[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];\n\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span> ; i&lt;[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++) {\n\n        <span class=\"keyword\">if</span> (<span class=\"variable\">*p</span>) {\n\n            p++;\n\n            strlength++;\n\n        }\n\n        <span class=\"keyword\">else</span> {\n\n            p++;\n\n        }\n\n\n\n    }\n\n    <span class=\"keyword\">return</span> strlength;\n\n}\n</pre></figure></code></pre>\n","excerpt":88,"source":"_posts/ios19.md","slug":"ios19","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"29":{"id":0,"title":"Block 定时器 让我们解放了","date":"2013-09-02T01:28:52.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>Block 没有出现前 ios写个定时器太麻烦了,好在Block的让我们小爽了一把,以后写timer 简单的要命了\n<a name=\"more\"></a>\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.5 * NSEC_PER_SEC), dispatch_get_current_queue(), ^{</p>\n<pre><code><figure class=\"highlight\"><pre>     [bgColorView removeFromSuperview]<span class=\"comment\">;</span>\n\n})<span class=\"comment\">;</span>\n</pre></figure></code></pre>\n<p>或者</p>\n<pre><code><figure class=\"highlight\"><pre>double delayInSeconds = <span class=\"number\">2.0</span>;\ndispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);\ndispatch_after(popTime, dispatch_get_main_queue(), ^(<span class=\"keyword\">void</span>){\n    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">#code</span> <span class=\"attribute\">to</span> <span class=\"attribute\">be</span> <span class=\"attribute\">executed</span> <span class=\"attribute\">on</span> <span class=\"attribute\">the</span> <span class=\"attribute\">main</span> <span class=\"attribute\">queue</span> <span class=\"attribute\">after</span> <span class=\"attribute\">delay</span>#&gt;</span>\n});</span>\n</pre></figure></code></pre>\n","excerpt":61,"source":"_posts/ios20.md","slug":"ios20","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"30":{"id":0,"title":"在Finder标题栏上显示完整路径","date":"2013-09-02T01:57:17.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1,6],"tags":[1],"comments":true,"layout":"post","content":"<p>打开终端，输入以下命令并回车：</p>\n<pre><code><figure class=\"highlight\"><pre>defaults write com<span class=\"variable\">.apple</span><span class=\"variable\">.finder</span> _FXShowPosixPathInTitle -<span class=\"keyword\">bool</span> <span class=\"literal\">YES</span>\n</pre></figure></code></pre>\n<p>然后再把finder关了再打开，你会发现路径栏变成这个样子了：</p>\n","excerpt":0,"source":"_posts/ios21.md","slug":"ios21","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"31":{"id":0,"title":"ios笔记-- 多线程应该知道的那几件事 GCD NSThread NSOperation","date":"2013-09-14T05:58:20.000Z","updated":"2013-09-14T08:38:29.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>iphone5s 出来了，CPU 升级到了64位 可以应用到更大的内存了，同时对多线程的处理吞吐能力也教之前提升了十几倍。下面着中总结下ios 下多线程的知识点\n<a name=\"more\"></a></p>\n</blockquote>\n<img src=\"http://image.techweb.com.cn/edit/2013/0911/37841378870639.jpg\" class=\"left\" width=\"400\" height=\"200\">\n\n\n\n<h2>1：现有的几种多线程</h2>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>应用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> NSThread</td>\n<td>苹果公司的Cocoa框架共支持三种多线程机制，分别为NSThread、GCD（Grand Central Dispatch）、Cocoa NSOperatio。NSThree是官方推荐的线程处理方式，它在处理机制上，需要开发者负责手动管理Thread的生命周期，包括子线程与主线程之间的同步等。线程共享同一应用程序的部分内存空间，它们拥有对数据相同的访问权限。你得协调多个线程 对同一数据的访问，一般做法是在访问之前加锁，这会导致一定的性能开销。在 iOS 中我们可以使用多种形式的 thread。 比其他两个轻量级 需要自己管理线程的生命周期，线程同步。 线程同步对数据的加锁会有一定的系统开销</td>\n</tr>\n<tr>\n<td> NSOperation</td>\n<td>如果需要让线程同时并行运行多个，可以将线程加入队列（Queue）中，NSOperationQueue类就是一个线程队列管理类，他提供了线程并行、队列的管理。可以认为NSOperationQueue就是一个线程管理器，通过addOperations方法，我们可以一次性把多个（数组形式）线程添加到队列中。同时，NSOperationQueue允许通过setMaxConcurrentOperationCount方法设置队列的并行（同一时间）运行数量  </td>\n</tr>\n<tr>\n<td> GCD</td>\n<td>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X 10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。</td>\n</tr>\n</tbody>\n</table>\n<p>一般移动平台上系统都会有一个专门的检查机制，看程序有没有很长时间被阻塞住，没有回来检查主消息队列。发现这种情况一般都是把程 序作为“无响应”干掉。iOS一般情况下是10秒为上限。10秒内程序没有回到主消息循环就被干掉。在前台后台切换时更严格，大概是5秒左右。<a href=\"http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html\">注释1</a></p>\n<h2>2:简单的Demo</h2>\n<p>因为GCD 是应用最广的 而且也是苹果现在极力鼓动开发者应用的 所以NSThread NSOperation 只做简单应用</p>\n<h3>1:NSThread</h3>\n<h3>1.1 NSThread 有两种直接创建方式：</h3>\n<p>第一个是实例方法--直接创建线程并且开始运行线程</p>\n<ul>\n<li>(id)initWithTarget:(id)target selector:(SEL)selector object:(id)</li>\n</ul>\n<p>第二个是类方法--先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息</p>\n<ul>\n<li>(void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument</li>\n</ul>\n<p><em>selector</em> :线程执行的方法，这个selector只能有一个参数，而且不能有返回值。<br><em>target</em>  :selector消息发送的对象<br><em>argument</em> :传输给target的唯一参数，也可以是nil    </p>\n<h3>1.2线程间通信</h3>\n<p>a 在应用程序主线程中做事情： </p>\n<figure class=\"highlight\"><pre><span class=\"method\">performSelectorOnMainThread:</span><span class=\"method\">withObject:</span><span class=\"method\">waitUntilDone:</span> <span class=\"method\">performSelectorOnMainThread:</span><span class=\"method\">withObject:</span><span class=\"method\">waitUntilDone:</span><span class=\"method\">modes:</span>\n</pre></figure>\n\n<p>b 在指定线程中做事情：</p>\n<figure class=\"highlight\"><pre><span class=\"method\">performSelector:</span><span class=\"method\">onThread:</span><span class=\"method\">withObject:</span><span class=\"method\">waitUntilDone:</span> <span class=\"method\">performSelector:</span><span class=\"method\">onThread:</span><span class=\"method\">withObject:</span><span class=\"method\">waitUntilDone:</span><span class=\"method\">modes:</span>\n</pre></figure>\n\n<p>c 在当前线程中做事情：</p>\n<figure class=\"highlight\"><pre><span class=\"method\">performSelector:</span><span class=\"method\">withObject:</span><span class=\"method\">afterDelay:</span>\n<span class=\"method\">performSelector:</span><span class=\"method\">withObject:</span><span class=\"method\">afterDelay:</span><span class=\"method\">inModes:</span>\n</pre></figure>\n\n<p>d 取消发送给当前线程的某个消息</p>\n<figure class=\"highlight\"><pre><span class=\"method\">cancelPreviousPerformRequestsWithTarget:</span> \n<span class=\"method\">cancelPreviousPerformRequestsWithTarget:</span><span class=\"method\">selector:</span><span class=\"method\">object:</span>\n</pre></figure>\n\n<h3>2:NSOperation</h3>\n<p>首先是建立NSOperationQueue和NSOperations。NSOperationQueue会建立一个线程管理器，每个加入到线程operation会有序的执行。  </p>\n<figure class=\"highlight\"><pre>\nNSOperationQueue *queue = [NSOperationQueue new];\nNSInvocationOperation *operation = <span class=\"string\">[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doWork:) object:someObject]; \n[queue addObject:operation]; \n[operation release];\n</pre></figure>\n\n<p>使用NSOperationQueue的过程：<br>    1.  建立一个NSOperationQueue的对象<br>    2.  建立一个NSOperation的对象<br>    3.  将operation加入到NSOperationQueue中<br>    4.  release掉operation  </p>\n<p>NSInvocationOperation，NSInvocationOperation是NSOperation的子类，允许运行在operation中的targer和selector</p>\n<h3>3：多线程互斥同步问题</h3>\n<p><a href=\"http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html\">注释2</a></p>\n<p>在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：</p>\n<ul>\n<li>方法一，@synchronized(id anObject),(最简单的方法)\n会自动对参数对象加锁，保证临界区内的代码线程安全</li>\n</ul>\n<figure class=\"highlight\"><pre>@<span class=\"keyword\">synchronized</span>(<span class=\"keyword\">self</span>) {\n        <span class=\"comment\">// 这段代码对其他 @synchronized(self) 都是互斥的</span>\n        <span class=\"comment\">// self 指向同一个对象</span>\n}\n</pre></figure>\n\n<ul>\n<li>方法二，NSLock</li>\n</ul>\n<p>NSLock对象实现了NSLocking protocol，包含几个方法：\nlock，加锁\nunlock，解锁\ntryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO\nlockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO\n比如\n：\n    NSLock *theLock = [[NSLock alloc] init]; </p>\n<pre><code><figure class=\"highlight\"><pre>if ([the<span class=\"operator\"><span class=\"keyword\">Lock</span> <span class=\"keyword\">lock</span>]) {\n\n//<span class=\"keyword\">do</span> something here\n\n[theLock unlock];</span> \n\n} \n</pre></figure></code></pre>\n<ul>\n<li>方法三，NSRecursiveLock，递归锁</li>\n</ul>\n<p>NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。</p>\n<pre><code><figure class=\"highlight\"><pre>NSRecursiveLock *theLock = <span class=\"string\">[[NSRecursiveLock alloc] init]; \nvoid MyRecursiveFunction(int value) { \n    [theLock lock]; \n    if (value != 0) { \n        –value; \n        MyRecursiveFunction(value); \n    }\n    [theLock unlock]; \n} \nMyRecursiveFunction(5);\n</pre></figure></code></pre>\n<ul>\n<li>方法四，NSConditionLock，条件锁</li>\n</ul>\n<p>NSConditionLock，条件锁，可以设置条件</p>\n<pre><code><figure class=\"highlight\"><pre>//公共部分\nid condLock = <span class=\"string\">[[NSConditionLock alloc] initWithCondition:NO_DATA]; \n\n//线程一，生产者\nwhile(true) { \n\n[condLock lockWhenCondition:NO_DATA]; \n\n//生产数据\n[condLock unlockWithCondition:HAS_DATA];\n\n}\n\n//线程二，消费者\nwhile (true) { \n\n[condLock lockWhenCondition:HAS_DATA\n\n//消费\n[condLock unlockWithCondition:NO_DATA]; \n}\n</pre></figure></code></pre>\n<ul>\n<li>方法五，NSDistributedLock，分布锁</li>\n</ul>\n<p>NSDistributedLock，分布锁，文件方式实现，可以跨进程\n用tryLock方法获取锁。\n用unlock方法释放锁。\n如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。</p>\n<p><strong>本章节(多线程互斥同步问题)参考自:<a href=\"http://blog.sina.com.cn/s/blog_72819b170101590n.html\">http://blog.sina.com.cn/s/blog_72819b170101590n.html</a></strong></p>\n<h2>3:GCD多线程互斥同步问题(阻塞线程的方式去实现同步)</h2>\n<p><a href=\"http://blog.devtang.com/blog/2012/02/22/use-gcd/\">注释3</a></p>\n<h3>1.串行队列</h3>\n<p>(1)GCD下的dispatch_queue队列都是FIFO队列,都会按照提交到队列的顺序执行.\n只是根据队列的性质,分为  </p>\n<p><1>串行队列:用户队列、主线程队列 </p>\n<p><2>并行队列. </p>\n<p>(2)同步(dispatch_sync)、异步方式(dispatch_async). 配合串行队列和并行队列使用.<br>同步队列直接提交两个任务就可以.\n// 串形队列\n    dispatch_queue_t serilQueue = dispatch_queue_create(&quot;com.quains.myQueue&quot;, 0);</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"comment\">//开始时间</span>\n<span class=\"built_in\">NSDate</span> *startTime = [<span class=\"built_in\">NSDate</span> date];\n\n\n__block <span class=\"built_in\">UIImage</span> *image = <span class=\"literal\">nil</span>;\n\n<span class=\"comment\">//1.先去网上下载图片</span>\n<span class=\"built_in\">dispatch_async</span>(serilQueue, ^{\n   <span class=\"comment\">//下载图片</span>\n});\n\n<span class=\"comment\">//2.在主线程展示到界面里</span>\n<span class=\"built_in\">dispatch_async</span>(serilQueue, ^{\n\n    <span class=\"built_in\">NSLog</span>(@<span class=\"string\">\"%@\"</span>,[<span class=\"built_in\">NSThread</span> currentThread]);\n\n    <span class=\"comment\">// 在主线程展示</span>\n    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^{\n      <span class=\"comment\">//显示图片</span>\n});\n\n<span class=\"comment\">//3.清理</span>\ndispatch_release(serilQueue);\n[image release];\n</pre></figure></code></pre>\n<p><strong>注意:</strong></p>\n<p>(1) __block变量分配在栈,retain下,防止被回收. </p>\n<p>(2)dispatch要手动create和release. </p>\n<p>(3)提交到主线程队列的时候,慎用同步dispatch_sync方法,有可能造成死锁.  因为主线程队列是串行队列,要等队列里的任务一个一个执行.所以提交一个任务到队列,如果用同步方法就会阻塞住主线程,而主线程又要等主线程队列里的任务都执行完才能执行那个刚提交的,所以主线程队列里还有其他的任务的话,但他已经被阻塞住了,没法先完成队列里的其他任务,即,最后一个任务也没机会执行到,于是造成死锁.</p>\n<p>(4)提交到串行队列可以用同步方式,也可以用异步方式. </p>\n<h3>2.并行队列</h3>\n<p>采用并行队列的时候,可以采用同步的方式把任务提交到队列里去,即可以实现同步的方式</p>\n<p>//新建一个队列\n    dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"comment\">//记时</span>\n<span class=\"built_in\">NSDate</span> *startTime = [<span class=\"built_in\">NSDate</span> date];\n\n<span class=\"comment\">//加入队列</span>\n<span class=\"built_in\">dispatch_async</span>(concurrentQueue, ^{\n    __block <span class=\"built_in\">UIImage</span> *image = <span class=\"literal\">nil</span>;\n\n    <span class=\"comment\">//1.先去网上下载图片</span>\n    <span class=\"built_in\">dispatch_sync</span>(concurrentQueue, ^{\n        <span class=\"comment\">//下载图片</span>\n    });\n\n    <span class=\"comment\">//2.在主线程展示到界面里</span>\n    <span class=\"built_in\">dispatch_sync</span>(dispatch_get_main_queue(), ^{\n        <span class=\"comment\">//显示图片</span>\n    });\n});\n</pre></figure></code></pre>\n<p>两个同步的任务用一个异步的包起来,提交到并行队列里去,即可实现同步的方式.</p>\n<h3>3.使用分组方式</h3>\n<p>group本身是将几个有关联的任务组合起来,然后提供给开发者一个知道这个group结束的点.\n虽然这个只有一个任务,但是可以利用group的结束点,去阻塞线程,从而来实现同步方式.</p>\n<p>例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：</p>\n<figure class=\"highlight\"><pre> dispatch_group_t <span class=\"keyword\">group</span> = dispatch_group_create();\n dispatch_group_async(<span class=\"keyword\">group</span>, dispatch_get_global_queue(<span class=\"number\">0</span>,<span class=\"number\">0</span>), ^{\n      <span class=\"comment\">// 并行执行的线程一</span>\n });\n dispatch_group_async(<span class=\"keyword\">group</span>, dispatch_get_global_queue(<span class=\"number\">0</span>,<span class=\"number\">0</span>), ^{\n      <span class=\"comment\">// 并行执行的线程二</span>\n });\n dispatch_group_notify(<span class=\"keyword\">group</span>, dispatch_get_global_queue(<span class=\"number\">0</span>,<span class=\"number\">0</span>), ^{\n      <span class=\"comment\">// 汇总结果</span>\n });\n</pre></figure>\n\n<pre><code><figure class=\"highlight\"><pre>dispatch_group_t <span class=\"keyword\">group</span> = dispatch_group_create();\n\ndispatch_queue_t queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);\n\nNSDate <span class=\"variable\">*startTime</span> = [NSDate <span class=\"keyword\">date</span>];\n\n__block UIImage <span class=\"variable\">*image</span> = nil;\n\ndispatch_group_async(<span class=\"keyword\">group</span>, queue, ^{\n    <span class=\"comment\">//1.先去网上下载图片</span>\n    });\n\n<span class=\"comment\">// 2.等下载好了再在刷新主线程</span>\ndispatch_group_notify(<span class=\"keyword\">group</span>, queue, ^{\n\n    <span class=\"comment\">//在主线程展示到界面里</span>\n    dispatch_async(dispatch_get_main_queue(), ^{\n     <span class=\"comment\">//显示图片</span>\n    });\n\n});\n\n<span class=\"comment\">// 释放掉</span>\ndispatch_release(<span class=\"keyword\">group</span>);\n</pre></figure></code></pre>\n<p>dispatch_group 也要手动创建和释放.\ndispatch_notify()提供了一个知道group什么时候结束的点. 当然也可以使用dispatch_wait()去阻塞</p>\n<h3>4.信号量</h3>\n<p>信号量 和 琐 的作用差不多,可以用来实现同步的方式. \n但是信号量通常用在 允许几个线程同时访问一个资源,通过信号量来控制访问的线程个数.</p>\n<p>// 信号量初始化为1\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>);\n\n<span class=\"built_in\">NSDate</span> *startTime = [<span class=\"built_in\">NSDate</span> date];\n\n__block <span class=\"built_in\">UIImage</span> *image = <span class=\"literal\">nil</span>;\n\n\n<span class=\"comment\">//1.先去网上下载图片</span>\n<span class=\"built_in\">dispatch_async</span>(queue, ^{\n\n    <span class=\"comment\">// wait操作-1</span>\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n    <span class=\"comment\">// 开始下载</span>\n    <span class=\"comment\">// signal操作+1</span>\n    dispatch_semaphore_signal(semaphore);\n});\n\n\n<span class=\"comment\">// 2.等下载好了再在刷新主线程</span>\n<span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^{\n\n    <span class=\"comment\">// wait操作-1</span>\n    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n    <span class=\"comment\">//显示图片</span>\n    <span class=\"comment\">// signal操作+1</span>\n    dispatch_semaphore_signal(semaphore);\n});\n</pre></figure></code></pre>\n<p>dispatch_wait会阻塞线程并且检测信号量的值,直到信号量值大于0才会开始往下执行,同时对信号量执行-1操作.<br>dispatch_signal则是+1操作.</p>\n<h3>3.后台运行</h3>\n<p>GCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>\n<p>让程序在后台长久运行的示例代码如下：</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">// AppDelegate.h文件</span>\n@<span class=\"keyword\">property</span> (<span class=\"keyword\">assign</span>, <span class=\"keyword\">nonatomic</span>) UIBackgroundTaskIdentifier backgroundUpdateTask;\n\n<span class=\"comment\">// AppDelegate.m文件</span>\n- (<span class=\"keyword\">void</span>)applicationDidEnterBackground:(<span class=\"built_in\">UIApplication</span> *)application\n{\n    [<span class=\"keyword\">self</span> beingBackgroundUpdateTask];\n    <span class=\"comment\">// 在这里加上你需要长久运行的代码</span>\n    [<span class=\"keyword\">self</span> endBackgroundUpdateTask];\n}\n\n- (<span class=\"keyword\">void</span>)beingBackgroundUpdateTask\n{\n    <span class=\"keyword\">self</span><span class=\"variable\">.backgroundUpdateTask</span> = [[<span class=\"built_in\">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^{\n        [<span class=\"keyword\">self</span> endBackgroundUpdateTask];\n    }];\n}\n\n- (<span class=\"keyword\">void</span>)endBackgroundUpdateTask\n{\n    [[<span class=\"built_in\">UIApplication</span> sharedApplication] endBackgroundTask: <span class=\"keyword\">self</span><span class=\"variable\">.backgroundUpdateTask</span>];\n    <span class=\"keyword\">self</span><span class=\"variable\">.backgroundUpdateTask</span> = UIBackgroundTaskInvalid;\n}\n</pre></figure>\n\n<hr>\n<p>[1] <a href=\"http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html\">http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html</a></p>\n<p>[2] <a href=\"http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html\">http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html</a></p>\n<p>[3] <a href=\"http://blog.devtang.com/blog/2012/02/22/use-gcd/\">http://blog.devtang.com/blog/2012/02/22/use-gcd/</a></p>\n","excerpt":97,"source":"_posts/ios23.md","slug":"ios23","ctime":"2013-09-14T08:38:29.000Z","mtime":"2013-09-14T08:38:29.000Z"},"32":{"id":0,"title":"ios笔记--block应该知道的那几件事","date":"2013-09-11T15:32:18.000Z","updated":"2013-09-14T06:07:31.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>block 现在已经基本上已经使用非常普遍了,在引用中也又很多坑,下面把block开发中应该知道的那几件事总结下.\n<a name=\"more\"></a></p>\n<h2>:内联(inline)Block</h2>\n<blockquote>\n<p>内联block 说白了就是block被嵌入到一个函数中 \n例如:</p>\n</blockquote>\n<p><strong>typedef void (^HelloBlock)(void);</strong></p>\n<figure class=\"highlight\"><pre><span class=\"pp\">- <span class=\"params\">(void)</span> BlockTest{\nHelloBlock myBlock= ^<span class=\"params\">(void)</span>{\nNSLog<span class=\"params\">(@<span class=\"string\">\"Hello Block\"</span>)</span>;\n};\nmyBlock<span class=\"params\">()</span>;\n}\n</pre></figure>\n\n<h2>注意事项</h2>\n<h3>1.内联的block中内部定义的变量 自己本身有读写权限</h3>\n<h3>2.block内部要修改外部变量 需要将外部变量声明__block</h3>\n<h3>3.Block retain是无效的，要想保留block生命周期，可以通过copy来实现，记得release</h3>\n<h3>4.被block的应用的对象，retainCount会自动加一，为了打破这种 retain circle，可以在对象前加__block，这样block块就不会维护这个对象了</h3>\n<p> 下面的写法如果不加上_block a无法dealloc</p>\n<figure class=\"highlight\"><pre>\n__block A  a =[ <span class=\"string\">[[A alloc] init] withBlock:^{\n\n [a action];\n\n [ a release];\n\n}]; //这样A的dealloc方法就会调用\n</pre></figure>\n\n<figure class=\"highlight\"><pre>\n@<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"id\">ViewController</span> ： <span class=\"id\">UIViewViewController</span> </span>\n {\n        <span class=\"built_in\">NSString</span> *_string;\n }\n\n __block ViewController *controller = <span class=\"keyword\">self</span>;   \n    _block = ^{\n         <span class=\"built_in\">NSLog</span>(@<span class=\"string\">\"string %@\"</span>,controller-&gt;_string);\n    };\n</pre></figure>\n\n<h3>5.在独立的block中不能引用self，如果需要访问可以使用参数传递的方法(可以把其考虑成c+中参数传入函数指针对应copy)**</h3>\n<h3>6.不要随便用.语法</h3>\n<figure class=\"highlight\"><pre><span class=\"preprocessor\">#import &lt;UIKit/UIKit.h&gt;   </span>\n@<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AppDelegate</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">UIApplicationDelegate</span>&gt;\n@<span class=\"title\">property</span> (<span class=\"title\">nonatomic</span>, <span class=\"title\">strong</span>) <span class=\"title\">NSString</span> *<span class=\"title\">stringProperty</span>;  \n@<span class=\"title\">end</span>\n</pre></figure>\n\n<figure class=\"highlight\"><pre><span class=\"preprocessor\">#import <span class=\"title\">\"GCDAppDelegate.h\"</span> </span>\n@<span class=\"class\"><span class=\"keyword\">implementation</span> <span class=\"id\">AppDelegate</span> </span>\n@<span class=\"keyword\">synthesize</span> stringProperty;  \n- (<span class=\"keyword\">void</span>) BlockTestError{\nHelloBlock myBlock= ^(<span class=\"keyword\">void</span>){\n\t<span class=\"keyword\">self</span><span class=\"variable\">.stringProperty</span> = @<span class=\"string\">\"Block Objects\"</span>; \n\t<span class=\"built_in\">NSLog</span>(@<span class=\"string\">\"String property = %@\"</span>, <span class=\"keyword\">self</span><span class=\"variable\">.stringProperty</span>);<span class=\"comment\">//运行错误</span>\n};\nmyBlock();\n}}  \n\n- (<span class=\"keyword\">void</span>) BlockTestCorrect{\n\tHelloBlock myBlock= ^(<span class=\"keyword\">void</span>){\n\t\t[<span class=\"keyword\">self</span> setStringProperty:@<span class=\"string\">\"Block Objects\"</span>];\n\t    <span class=\"built_in\">NSLog</span>(@<span class=\"string\">\"self.stringProperty = %@\"</span>, [<span class=\"keyword\">self</span> stringProperty]); <span class=\"comment\">//运行ok</span>\n\t};\nmyBlock();\n}}  \n@<span class=\"keyword\">end</span>\n</pre></figure>\n\n","excerpt":61,"source":"_posts/ios22.md","slug":"ios22","ctime":"2013-09-14T06:07:31.000Z","mtime":"2013-09-14T06:07:31.000Z"},"33":{"id":0,"title":"ios 清理工程中没有用到的图片","date":"2013-08-29T08:43:14.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1,6],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>发布前往往需要清理工程中没有用到的图片，这些图片可能是测试图片也可能是以往版本中替换遗留下来的图片</p>\n</blockquote>\n<a name=\"more\"></a>\n\n<h2>使用方法</h2>\n<ol>\n<li>将下面代码保存成**.sh 然后chomd 777 使其可执行</li>\n<li>将**.sh 拷贝到工程根目录下</li>\n<li>./执行**.sh </li>\n<li><p>再同级目录下会生成一个imge.txt 结果文件</p>\n<p>如下图  </p>\n</li>\n</ol>\n<img src=\"http://ww3.sinaimg.cn/mw690/a43af4ffjw1e83pb1zvo7j215q0pq7bz.jpg\" width=\"300\" height=\"500\">\n\n\n<h2>源码</h2>\n<figure class=\"highlight\"><pre><span class=\"shebang\">#!/bin/sh</span>\n\n<span class=\"keyword\">echo</span> <span class=\"string\">\"删除有风险 下手需谨慎 如需再次确认图片是否被引用到\"</span>\n\n<span class=\"keyword\">echo</span> <span class=\"string\">\"Defult.png 和例如[UIImage imageNamed:@‘img.png'] 可能会误报\"</span>\n\n\nread -n1 -p  <span class=\"string\">\"【Y】查阅如何确认 【N】直接进行图片检索\"</span> \n\ncase <span class=\"variable\">$answer</span> <span class=\"keyword\">in</span> \n\n<span class=\"string\">\"Y\"</span>|<span class=\"string\">\"y\"</span>) \n\nopen -a Safari <span class=\"string\">\"http://blog.csdn.net/hufeng825/article/details/8533647\"</span>\n\n<span class=\"keyword\">echo</span> -n <span class=\"string\">\"按任意键开始程序\"</span>;\n\nread var\n\n;;\n\n<span class=\"string\">\"N\"</span>|<span class=\"string\">\"n\"</span>) \n\n<span class=\"keyword\">echo</span> <span class=\"string\">\"命令执行时终端会输入结果 搜索完毕后 会在当前路径下自动生成imag.txt的结果报告\"</span>\n\n;;\n\n*) \n\n;;\n\nesac\n\n\n\n\nPROJ=`find .  ! -name <span class=\"string\">'*.xib'</span> -o -name <span class=\"string\">'*.[mh]'</span> -o -name <span class=\"string\">'*.storyboard'</span> -o -name <span class=\"string\">'*.mm'</span> -o -name <span class=\"string\">'*.html'</span> `\n\n\n<span class=\"keyword\">echo</span> <span class=\"string\">\"~~~~~~~~~~~~开始搜索~~~~~~~~~~~~\"</span> &gt;&gt;<span class=\"string\">'./image.txt'</span>;\n\n<span class=\"keyword\">for</span> png <span class=\"keyword\">in</span> `find . -name <span class=\"string\">'*.png'</span>`\n<span class=\"keyword\">do</span>\n\n   name=`basename -s .png <span class=\"variable\">$png</span>`\n   name=`basename -s @2x <span class=\"variable\">$name</span>`\n   <span class=\"keyword\">if</span> ! grep -qhs <span class=\"string\">\"<span class=\"variable\">$name</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$PROJ</span>\"</span>; <span class=\"keyword\">then</span>\n        <span class=\"keyword\">echo</span> <span class=\"string\">\"<span class=\"variable\">$png</span> 可能没引用\"</span> \n        <span class=\"keyword\">echo</span> <span class=\"string\">\"<span class=\"variable\">$png</span> 可能没引用\"</span>  &gt;&gt;<span class=\"string\">'./image.txt'</span> ;\n   <span class=\"keyword\">fi</span>\n<span class=\"keyword\">done</span>\n\n<span class=\"keyword\">for</span> jpg <span class=\"keyword\">in</span> `find . -name <span class=\"string\">'*.jpg'</span>`\n<span class=\"keyword\">do</span>\n   name=`basename -s .jpg <span class=\"variable\">$jpg</span>`\n   name=`basename -s @2x <span class=\"variable\">$name</span>`\n   <span class=\"keyword\">if</span> ! grep -qhs <span class=\"string\">\"<span class=\"variable\">$name</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$PROJ</span>\"</span>; <span class=\"keyword\">then</span>\n        <span class=\"keyword\">echo</span> <span class=\"string\">\"<span class=\"variable\">$png</span> 可能没引用\"</span> \n        <span class=\"keyword\">echo</span> <span class=\"string\">\"<span class=\"variable\">$jpg</span> 可能没引用\"</span>  &gt;&gt;<span class=\"string\">'./image.txt'</span>;\n   <span class=\"keyword\">fi</span>\n<span class=\"keyword\">done</span>\n\n<span class=\"keyword\">echo</span> <span class=\"string\">\"~~~~~~~~~~~~结束搜索~~~~~~~~~~~~\"</span> &gt;&gt;<span class=\"string\">'./image.txt'</span>;\n&lt;&lt;EOF\n</pre></figure>\n\n","excerpt":84,"source":"_posts/ios3.md","slug":"ios3","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"34":{"id":0,"title":"removeFromSuperview添加动画使其更加高雅美观","date":"2013-08-29T10:29:40.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>程序中难免使用removeFromSuperview，但是view控件直接从界面突然消失会显得非常不友好，作为一个高端大气上档次的app细节处处应该注意，\n<a name=\"more\"></a>\n添加一个简单的动画给用户的感觉立刻不一样了。废话不说直接上代码</p>\n<figure class=\"highlight\"><pre>   [UIView animateWithDuration:<span class=\"number\">0.2</span>\n\n                     animations:^{_logViewController<span class=\"preprocessor\">.view</span><span class=\"preprocessor\">.alpha</span> = <span class=\"number\">0.0</span><span class=\"comment\">;}</span>\n\n                     completion:^(BOOL finished)\n\n                                { [_logViewController<span class=\"preprocessor\">.view</span> removeFromSuperview]<span class=\"comment\">; }</span>\n\n     ]<span class=\"comment\">;</span>\n</pre></figure>\n\n</blockquote>\n","excerpt":94,"source":"_posts/ios4.md","slug":"ios4","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"35":{"id":0,"title":"ios 通过当前view得到所在的viewcontroller","date":"2013-08-29T10:35:01.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>long long ago ，带过的小弟遇到了一个问题，需要从当前的控件（一般是uiview）获取当前所在的viewcontroller\n<a name=\"more\"></a>\n当时给出他的解决办法</p>\n<figure class=\"highlight\"><pre>@<span class=\"class\"><span class=\"keyword\">implementation</span> <span class=\"id\">UIView</span> (<span class=\"id\">GetVCAdditions</span>)</span>\n- (<span class=\"built_in\">UIViewController</span> *)GetiewController {\n    Class vcc = [<span class=\"built_in\">UIViewController</span> <span class=\"built_in\">class</span>];\n    UIResponder *responder = <span class=\"keyword\">self</span>;\n    <span class=\"keyword\">while</span> ((responder = [responder nextResponder]))\n        <span class=\"keyword\">if</span> ([responder isKindOfClass: vcc])\n            <span class=\"keyword\">return</span> (<span class=\"built_in\">UIViewController</span> *)responder;\n    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;\n}\n</pre></figure>\n\n","excerpt":72,"source":"_posts/ios5.md","slug":"ios5","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"36":{"id":0,"title":"快速清除subviews之 隐私循环","date":"2013-08-29T10:48:47.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>问：如何快速把当前view下的所有子view 及其子子view们删除掉\n<a name=\"more\"></a>\n解答这个问题前先介绍下 NSArray </p>\n</blockquote>\n<p>NSArray 类定义的方法</p>\n<ol>\n<li>makeObjectsPerformSelector:@select（aMethod）</li>\n</ol>\n<p>简介：让数组中的每个元素 都调用 aMethod </p>\n<ol>\n<li><p>makeObjectsPerformSelector:@select（aMethod）</p>\n<p>　　　　              withObject:oneObject</p>\n</li>\n</ol>\n<p><strong>ps：让数组中的每个元素 都调用 aMethod  并把 withObject 后边的 oneObject 对象做为参数传给方法aMethod</strong></p>\n<p>因此可以利用隐私循环来快速清除subviews</p>\n<p>[[self.view subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];</p>\n","excerpt":52,"source":"_posts/ios7.md","slug":"ios7","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"37":{"id":0,"title":"ios iphone5 适配 之 如何使app 适用不通分辨率","date":"2013-08-29T10:44:36.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>iphone5适配 有如下集中种思路</p>\n<a name=\"more\"></a>\n\n<p>1：利用自身的autoresize 加上代码实现</p>\n<p>2：写两套xib</p>\n<p>3：利用ios5+ 以上的autolayout</p>\n<p>前两种方式应用比较广泛 ，因为毕竟国内还有部分应用ios4.3的用户</p>\n<p>下面给第二种方式应用下的部分代码</p>\n<figure class=\"highlight\"><pre>- (<span class=\"keyword\">id</span>)init\n{\n\n    <span class=\"built_in\">NSString</span>    *clssName = NSStringFromClass([<span class=\"keyword\">self</span> <span class=\"built_in\">class</span>]);\n    <span class=\"built_in\">NSString</span>    *xibName = is4InchScreen() ?[<span class=\"built_in\">NSString</span> stringWithFormat:@<span class=\"string\">\"%@_4inch\"</span>, clssName] : clssName;\n    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithNibName:xibName bundle:<span class=\"literal\">nil</span>];\n    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>) {}\n    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;\n\n}\n</pre></figure>\n\n","excerpt":26,"source":"_posts/ios6.md","slug":"ios6","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"38":{"id":0,"title":"xcode 5.0 的持续继承","date":"2013-08-31T12:41:27.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<p>&gt;\nXcode的支持持续集成通过Xcode的服务流程。Xcode的服务，可在OS X服务器，自动一体化建设过程中，您的应用程序的分析，测试和归档。<a name=\"more\"></a>从开发的Mac，您可以创建机器人上运行一个单独的服务器，在那里他们执行这些集成。机器人可以帮助确保您的产品始终处于释放状态，当有故障时，服务会通知你的人或代码变化引起的故障。</p>\n<img src=\"http://img.blog.csdn.net/20130617220248765\" class=\"left\" width=\"400\" height=\"600\">\n\n\n<hr>\n<h2>概览</h2>\n<p>按照本文档中列出的步骤，建立一个持续集成的工作流程，使用Xcode和Xcode服务。\n    注：持续集成工作流程通常依赖于一个或多个开发Mac上运行Xcode和一个独立的OS X服务器运行Xcode的服务。但是，您可以安装开发的Mac OS X Server的。这样的配置可以有助于评估如何采用持续集成。之后，你会发现它有一个专门的OSX服务器运行Xcode的托管服务，你的资料库，并远程执行集成更多有用的。</p>\n<hr>\n<h2>设置和自定义的Xcode服务</h2>\n<pre><code><figure class=\"highlight\"><pre>即使你从来没有架设一台服务器，你会发现OSX服务器上设立了Xcode服务是简单的过程。后服务运行起来，你可以添加开发设备，配置机器人，并指定发布标准。\n</pre></figure></code></pre>\n<p><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/200-Adopting_a_Continuous_Integration_Workflow/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1\">有关章节： “采用持续集成工作流”</a></p>\n<hr>\n<h2>创建和运行僵尸</h2>\n<pre><code><figure class=\"highlight\"><pre>机器人的自动化工作流程的心脏。机器人构建和测试产品与您选择的方案。随着Xcode的服务能够访问你的项目的源代码库中，您可以创建并安排定期运行或在每个源代码提交的机器人。您也可以设定机器人发送邮件通知其集成的成功或失败。\n</pre></figure></code></pre>\n<p><a href=\"https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1\">有关章节： “配置机器人执行连续集成”</a></p>\n<h2>监控和​​管理集成</h2>\n<pre><code><figure class=\"highlight\"><pre>机器人的自动化工作流程的心脏。机器人构建和测试您的产品，您所选择的计划。Xcode的服务提供了日志管理机器人，查看测试结果，并读取整合日志导航。该服务还提供了通过一个网页，在那里您可以查看bot活动的总结以及集成细节的结果。\n</pre></figure></code></pre>\n<p><a href=\"https://daw.apple.com/cgi-bin/WebObjects/DSAuthWeb.woa/wa/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2F%2Flibrary%2Fprerelease%2Fios%2Fdocumentation%2FIDEs%2FConceptual%2Fxcode_guide-continuous_integration%2F300-Working_with_Bots%2Fview_integration_results%2Ehtml#//apple_ref/doc/uid/TP40013292-CH4-SW1\">有关章节： “工作与机器人”</a></p>\n","excerpt":79,"source":"_posts/ios8.md","slug":"ios8","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"39":{"id":0,"title":"Xcode的持续集成指南","date":"2013-08-31T13:11:39.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[5],"tags":[1],"comments":true,"layout":"post","content":"<h2>采用持续集成工作流</h2>\n<p>设置MAC作为服务器，在其上运行Xcode的服务。然后确保你的本地项目，发布源代码库。要完成设立一个持续集成的工作流程，配置的机器人，不知疲倦地进行集成和时间表。\n<a name=\"more\"></a></p>\n<h2>OS X Server的安装和配置的Xcode服务</h2>\n<p>要运行的Xcode的服务，您必须先安装运行的是Mac OS X v10.9开发者预览版OS X Server的预览。您还必须在服务器上安装Xcode开发者预览。自动构建，分析，测试，和归档您的产品，您将使用Xcode的服务。</p>\n<h3>要安装和运行Xcode的服务</h3>\n<ol>\n<li><p>转到<a href=\"http://developer.apple.com/downloads的，并获得OS\">http://developer.apple.com/downloads的，并获得OS</a> X v10.9开发者预览版，OS X Server的预览，和Xcode开发者预览版的预发布版本。</p>\n</li>\n<li><p>安装OS X v10.9开发者预览版，Mac OS X Server的预览，和Xcode开发者预览版的Mac上，你会运行Xcode的服务。</p>\n</li>\n<li><p>启动服务器应用程序/应用。</p>\n</li>\n<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>\n</li>\n<li><p>当您第一次打开Xcode的服务在一个特定的服务器上，该服务会询问您确定的Xcode版本，它应该用来执行其任务。</p>\n</li>\n<li><p>点击选择的Xcode，并选择使用的Xcode版本。</p>\n</li>\n<li><p>点击On / Off开关打开服务</p>\n</li>\n</ol>\n<p>接下来，添加你的服务器允许访问Xcode的服务团队，如资产配置的配置文件和签名证书为iOS设备构建产品开发团队。你必须是一个管理员或开发团队的代理，这样才能把服务器加进来。</p>\n<h3>要添加您的服务器开发团队</h3>\n<ol>\n<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>\n</li>\n<li><p>在“设置”窗格中，单击“添加”按钮，旁边的开发团队标签。</p>\n</li>\n<li><p>输入您的Apple开发者证书，并选择一个团队。</p>\n</li>\n</ol>\n<p>加入团队后，Xcode的服务，您可以添加iOS开发设备运行单元测试时使用。</p>\n<h3>要添加一个iOS开发设备的Xcode服务</h3>\n<ol>\n<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>\n</li>\n<li><p>将设备连接到服务器，并等待，直到它出现在设备列表中。</p>\n</li>\n<li><p>点击“加入队伍”按钮旁边的列表中的设备。</p>\n</li>\n</ol>\n<p>添加帐户资料库和您的服务器配置开发的Mac。你会写你的Mac上的使用Xcode代码，你就会让OS X服务器进行持续集成。您还必须发布或您当地的项目转移到资料库，可通过Xcode的服务。</p>\n<h3>你开发的Mac OS X Server的帐户添加到Xcode</h3>\n<ol>\n<li><p>在Xcode的开发Mac上，单击“帐户”首选项“窗口。</p>\n</li>\n<li><p>点击添加按钮（+），并选择“添加服务器”。</p>\n</li>\n<li><p>从服务器列表中选择服务器，输入服务器地址，然后单击“下一步”按钮。</p>\n</li>\n<li><p>指定您的连接到服务器的凭据，然后单击“添加”。</p>\n</li>\n</ol>\n<p>您可以添加到您的帐户资料库，加快结帐操作。（你也可以添加库到您的清单后，当您检查的项目）。</p>\n<h3>要添加存储库到您的帐户</h3>\n<ol>\n<li><p>在Xcode的开发Mac上，单击“帐户”首选项“窗口。</p>\n</li>\n<li><p>点击添加按钮（+），并选择“添加库。</p>\n</li>\n<li><p>在文本字段中，输入库添加的地址，然后单击“完成”按钮。</p>\n</li>\n</ol>\n<h2>Xcode的服务和团队成员共享项目</h2>\n<p>对于Xcode的服务，您的项目进行集成，它必须包含这些项目的存储库的访问。启用访问托管Git仓库在服务器上运行的Xcode服务或Git或Subversion版本库，包含你的项目添加连接信息。</p>\n<p>如果同一个团队开发，持续集成涉及到整个团队。谁的作品在产品上的人都必须能够访问所有产品的资源，使任何人都可以引起谁都可能解决问题。如果你有一个不保持源代码库中的项目或工作区，你必须检查你的文件到存储库，让其他团队成员可以在这些产品上。</p>\n<p><strong>您可以在服务器上创建一个Xcode服务器，托管Git仓库</strong>\n开发团队可以共享更改产品OS X服务器托管在一个Git仓库。创建一个Xcode服务器托管Git仓库之前，你必须：</p>\n<ol>\n<li><p>确保都有谁应该能够访问存储库服务器上的用户帐户。</p>\n</li>\n<li><p>打开系统偏好设置中的服务器上的远程登录服务。</p>\n</li>\n</ol>\n<h3>要创建一个Xcode服务器托管您的服务器上的Git仓库</h3>\n<ol>\n<li><p>在服务器应用程序边栏中，选择Xcode的服务，然后单击“存储库”按钮。</p>\n</li>\n<li><p>点击添加按钮（+），并指定存储库的信息：</p>\n<ul>\n<li>选择“主机一个Git仓库。”</li>\n<li>名称：输入资料库的名称（例如，项目名称）。</li>\n<li>访问：确定允许用户访问存储库。</li>\n</ul>\n</li>\n<li><p>单击“创建”。</p>\n<p> 新的资料库资料库列表中出现。如果你有一个发展的Mac上现有的Git管理的项目，你可以把你的变化，这个新的储存库，将其配置为远程，如未来。</p>\n</li>\n</ol>\n<h3>从发展的Mac，您可以共享现有的Git管理项目</h3>\n<p>当您共享一个项目，其中包含一个Git仓库，是当地发展的Mac，Xcode的服务可以检查出来进行集成。共享一个项目之前，你必须：</p>\n<ol>\n<li>作为OS X服务器运行Xcode的服务的管理员进行身份验证。</li>\n<li>确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。</li>\n</ol>\n<h4>要共享项目</h4>\n<ol>\n<li><p>打开项目发展的Mac上，并选择源控制&gt; PROJECT_NAME &gt;配置PROJECT_NAME。</p>\n</li>\n<li><p>按一下远程控制。</p>\n</li>\n<li><p>点击“添加”按钮（+）。</p>\n</li>\n<li><p>选择“创建新的远程。</p>\n</li>\n<li><p>选择一台服务器。</p>\n</li>\n<li><p>输入远程名称。</p>\n</li>\n<li><p>单击“创建”。</p>\n</li>\n<li><p>单击“完成”。</p>\n</li>\n<li><p>这使得共享资源库的上游库项目存​​储库。</p>\n</li>\n</ol>\n<h3>您可以创建一个新项目开发的Mac OS X服务器和主机守则</h3>\n<p>当您创建您的开发Mac上的项目，你可以创建一个共享库。创建一个共享的项目之前，你必须：</p>\n<ol>\n<li>作为OS X服务器运行Xcode的服务的管理员进行身份验证。</li>\n<li>确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。</li>\n</ol>\n<h4>要创建共享项目</h4>\n<ol>\n<li><p>选择“文件”&gt;“新建”&gt;“项目。</p>\n</li>\n<li><p>为您的项目中选择一个模板。</p>\n</li>\n<li><p>指定项目的选项，并单击“下一步”。</p>\n</li>\n<li><p>指定的位置。</p>\n</li>\n<li><p>选择“创建git仓库”选项。</p>\n</li>\n<li><p>确定服务器。</p>\n</li>\n</ol>\n<p>单击“创建”。</p>\n<p>您可以使用Git来管理你的开发Mac上的非托管的工作区目录\n当你创建一个Xcode的工作区或项目，你必须包括一个Git仓库中生成的工作区目录的选项。如果您没有选择该选项，您的工作区目录不包括一个Git仓库。与他人使用Git版本控制系统要共享工作区目录，在该目录中，你必须初始化一个Git仓库。</p>\n<p>您可以使用Subversion的管理项目\nXcode的服务可以连接你的Subversion版本库，并从它的检查项目。</p>\n<h2>使用搜索引擎来生成，运行静态分析，测试和存档</h2>\n<p>您可以运行一个项目的集成通过三个计划行动：</p>\n<ol>\n<li>分析，进行静态分析。</li>\n<li>测试，运行一组测试案例。</li>\n<li>存档，建立一个归档的产品，计划建成。</li>\n</ol>\n<p>您可以手动执行这些操作，为您做出更改产品。然而，手动集成可以是乏味且容易出错。例如，你可能会忘记发布一个小的变化，打破你的队友的单元测试之前进行测试操作。Xcode的服务提供了一个具有成本效益的方式自动执行集成：机器人。机器人会自动执行你的集成：</p>\n<ol>\n<li>每次更改发布到存储库。</li>\n<li>上定期（比如说，每天进行集成，需要很长的时间才能完成）。\nÂ 机器人运行通过Xcode的服务，以在资源库中的项目的当前版本进行集成，是一个过程。包括一个集成构建，分析，测试，归档产品上。可以是成功的积分（即，所有的整合动作传递没有问题）的或不成功的。计划中定义的集成自动化，您必须共享该方案，并创建一个或多个机器人来执行这些集成。</li>\n</ol>\n<p>要充分利用您的产品开发流程的持续集成环境中，遵循以下做法：</p>\n<ol>\n<li><p>制定适当的单元测试套件和测试用例，显影单元测试后，包括他们在你的机器人运行计划。要了解关于单元测试的更多信息，请参见Xcode的单元测试指南\n为了帮助确保您所做的更改都破不了您或其他人后，你应​​该配合这些变化与单元测试，确定是否规定一种或一组序列功能的方法。有些球队在它的头把这种方法首先开发测试，通过测试的方法，然后执行。</p>\n</li>\n<li><p>执行静态分析，你应该在您的集成包括静态分析。\n静态分析是深刻检查你的代码，下面的代码路径，您的应用程序可能不遵循正常的发展过程中。这个过程揭示难以发现的编码错误，还确定了在你的代码不遵循建议的API的用法，比如基金会和AppKit的成语。</p>\n</li>\n<li><p>确保您的产品建立和正确打包。您您的产品作出了重大变化，特别是结构性的变化，如添加或删除文件后，应归档。让你的机器人自动为您归档。\n当您的产品中包含的结构性问题，Xcode可以创建一个归档它为你的团队成员之间共享或提交到App Store。建立和归档产品的能力是你的代码更改的正确性的主要指标。</p>\n</li>\n</ol>\n<h2>分享计划</h2>\n<p>共享的计划被确定为在一个项目中共享和发布共享资源库，以及与其他共享项目文件。你可以分享计划之前，你必须检查的项目。</p>\n<h3>要共享计划</h3>\n<ol>\n<li><p>开发的Mac上，打开的项目，其中包含共享的计划。</p>\n</li>\n<li><p>选择产品&gt;计划&gt;管理计划。</p>\n</li>\n<li><p>分享的计划，选择共享选项，并单击“确定”。</p>\n</li>\n<li><p>选择源控制&gt;提交。</p>\n</li>\n<li><p>选择共享的资料夹。</p>\n</li>\n<li><p>指定你提交的信息：</p>\n<ul>\n<li>在文本字段中输入你的提交信息。</li>\n<li>选择“推到远程”选项（如果您的项目使用Git管理）。</li>\n</ul>\n</li>\n<li><p>点击“提交文件”按钮。</p>\n</li>\n</ol>\n<h2>创建机器人</h2>\n<p>共享计划后，你可以创建一个机器人来执行持续集成。</p>\n<p>要创建一个僵尸</p>\n<p>开发的Mac上，打开的项目，其中包含计划，定义的行动，以自动化。</p>\n<p>选择产品&gt;创建BOT，指定机器人的标识属性，并单击“下一步”。</p>\n<p>与指定库凭据机器人，并单击“下一步”。</p>\n<p>指定的整合时间表，行动的机器人来执行，以及是否清洁产品前建设。</p>\n<p>附表：指定往往机器人集成。</p>\n<p>定期：整合每小时，每天或每周。\n在提交更改时集成发布到存储库。\n手册：机器人不会自动整合。\n操作：选择机器人作为整合的一部分执行的行动。</p>\n<p>清洁：指定机器人是否重用以前的版本。</p>\n<p>单击“下一步”。</p>\n<p>如果您选择创建机器人执行第一次整合，整合的结果，出现在日志中的导航仪。</p>\n","excerpt":104,"source":"_posts/ios9.md","slug":"ios9","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"40":{"id":0,"title":"ios 开发笔记之图片 Image","date":"2013-08-20T01:29:39.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[1],"tags":[1],"comments":true,"layout":"post","content":"<h2>关于图片资源</h2>\n<p>ios 程序会把图片资源编译成二进制文件，程序运行时会把这些图片从磁盘加载直接到内存，如果图片很大，加载速度就会很慢。\n<a name=\"more\"></a>\n为了优化提高性能，需要尽量压缩图片资源。（ps 苹果公司的UIKit 开发者Andy Matuschak指出：使用resizable image是最快的方法。）</p>\n<h2>关于图片资源的压缩</h2>\n<p>如果不需要用半透明的图片 则尽量不要用png 格式的图片。相应的可以用jpg格式的。另外谷歌最新推出的一种格式webp</p>\n<h3>1 WebP是什么</h3>\n<p>WebP是Google推出的一种同时提供了有损压缩与无损压缩的图片格式。目前互联网上传输的数据有65%都是图片，WebP就是出于减少数据量、加速网络传输的目的而开发的。WebP希望能够达到和JPEG同水平的图片质量，但是更小的文件，以减少图片的传送时间。\n在有损压缩的状况下，WebP比同样画质的JPEG少了25% ～ 34%的文件大小 。而在无损压缩的情形中，比起用libpng产生的PNG图片，WebP少了34%的文件大小，也比用pngout再处理过的PNG图片少了26%的文件大小。</p>\n<h3>2 WebP的使用</h3>\n<p>webp图片压缩率会比jpeg、png更高，因此下载图片会更省流量，特别适合在mobile app上使用。 比如iOS app上，可以把webp编译生成framework，然后加入引用就可以是使用了。强烈推荐。\n这iOS解析时，可以直接使用 WebPImage。\nNSData <em>imageData = [NSData dataWithContentsOfURL:url];\nUIImage </em>tmpImage = [[WebPImage alloc] loadWebPFromData:imageData];\nSDWebImage最近也提供了对webp的支持，起先不支持自己写了一个分类，现在可以直接用他的UIImage+WebP</p>\n<h2>关于加载方式</h2>\n<p>  imageNamed每次都读图片到缓存中，只适合频繁使用的图片，\ninitWithContentsOfFile的方法加载图片后，不缓存，适合加载不常使用的图片。 \n引导图片一般情况下只会启动一次而且图片也一般情况下比较大所以用imageNamed 会非常， 如果用initWithContentsOfFile:，这些图片所占用内存可以很快被释放</p>\n<blockquote>\n<p>资料参考by wufawei stackoverflow</p>\n</blockquote>\n","excerpt":79,"source":"_posts/iosimage.md","slug":"iosimage","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"41":{"id":0,"title":"MAC OS X 下快速切换代理","date":"2013-09-03T05:20:05.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[1,6],"tags":[1],"comments":true,"layout":"post","content":"<p>因为行业原因 在公司上网必须通过代理安装，所以每天上下班开电脑第一件事 就是开关代理。于是做了一个软件 利用shell进行切换代理。</p>\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e898v6vmwdj20dk06bwep.jpg\" class=\"left \" width=\"300\" height=\"400\" title=\"运行效果图\">\n\n\n  <a name=\"more\"></a>\n\n<img src=\"http://ww4.sinaimg.cn/mw690/a43af4ffjw1e898wixkiej207q020dfu.jpg\" class=\"left\" width=\"200\" height=\"300\" title=\"软件\">\n\n\n\n\n<p>下面是主要源码</p>\n<figure class=\"highlight\"><pre><span class=\"keyword\">tell</span> <span class=\"type\">application</span> <span class=\"string\">\"System Events\"</span>\n\n<span class=\"keyword\">set</span> proxy_dialog <span class=\"keyword\">to</span> <span class=\"command\">display dialog</span> <span class=\"string\">\"代理模块(Ethernet版本):\"</span> buttons {<span class=\"string\">\"打开代理模式1\"</span>, <span class=\"string\">\"打开代理模式2\"</span>, <span class=\"string\">\"关闭代理\"</span>} default button <span class=\"string\">\"打开代理模式1\"</span> <span class=\"keyword\">with</span> title <span class=\"string\">\"华夏基金开发环境快速切换代理App\"</span>\n\n<span class=\"keyword\">set</span> proxy_interface <span class=\"keyword\">to</span> button returned <span class=\"keyword\">of</span> proxy_dialog\n\n<span class=\"keyword\">end</span> <span class=\"keyword\">tell</span>\n\n\n<span class=\"keyword\">if</span> proxy_interface <span class=\"keyword\">is</span> <span class=\"string\">\"打开代理模式1\"</span> <span class=\"keyword\">then</span>\n\n<span class=\"command\">do shell script</span> <span class=\"string\">\"networksetup -setwebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setsecurewebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setwebproxystate Ethernet on&&networksetup -setsecurewebproxystate Ethernet on\"</span> <span class=\"keyword\">with</span> administrator privileges\n\n<span class=\"keyword\">end</span> <span class=\"keyword\">if</span>\n\n\n<span class=\"keyword\">if</span> proxy_interface <span class=\"keyword\">is</span> <span class=\"string\">\"打开代理模式2\"</span> <span class=\"keyword\">then</span>\n\n<span class=\"command\">do shell script</span> <span class=\"string\">\"networksetup -setwebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setsecurewebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setwebproxystate Ethernet on&&networksetup -setsecurewebproxystate Ethernet on\"</span> <span class=\"keyword\">with</span> administrator privileges\n\n<span class=\"keyword\">end</span> <span class=\"keyword\">if</span>\n\n\n<span class=\"keyword\">if</span> proxy_interface <span class=\"keyword\">is</span> <span class=\"string\">\"关闭代理\"</span> <span class=\"keyword\">then</span>\n\n<span class=\"command\">do shell script</span> <span class=\"string\">\"networksetup -setwebproxystate Ethernet off&&networksetup -setsecurewebproxystate Ethernet off\"</span> <span class=\"keyword\">with</span> administrator privileges\n\n<span class=\"keyword\">end</span> <span class=\"keyword\">if</span>\n</pre></figure>\n\n","excerpt":208,"source":"_posts/mac3.md","slug":"mac3","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"42":{"id":0,"title":"mac 下 git svn 的代理设置","date":"2013-09-02T00:10:34.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[2,3],"tags":[1],"comments":true,"layout":"post","content":"<p>所干的工作 因为涉及到金融行业网络安全性比较高 公司的网络设置了代理 这导致了git svn 双双挂了。 \n<a name=\"more\"></a>\n废话少说 下面介绍如何对git svn 设置代理</p>\n<ol>\n<li><p>$HOME 下 我的路径为/Users/jason:</p>\n</li>\n<li><p>进入$HOME/.subversion </p>\n<p>编辑servers 文件 添加</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"matrix\">[global]</span>\n http-proxy-host = <span class=\"transposed_variable\">XX.</span><span class=\"transposed_variable\">XX.</span><span class=\"transposed_variable\">XX.</span>XX\n http-proxy-port = XXXX\n<span class=\"matrix\">[groups]</span>\n</pre></figure></code></pre>\n</li>\n<li><p>编辑$HOME/.gitconfig</p>\n<pre><code><figure class=\"highlight\"><pre>[http]        \n\n     proxy = http://XX<span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span>:XXXX\n\n[https]\n      proxy = http://XX<span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span>:XXXX\n</pre></figure></code></pre>\n</li>\n<li><p>或者直接用命令</p>\n<pre><code><figure class=\"highlight\"><pre> git config --global http<span class=\"preprocessor\">.proxy</span> http://XX<span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span>:XXXX\n git config --global https<span class=\"preprocessor\">.proxy</span> http://XX<span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span><span class=\"preprocessor\">.XX</span>:XXXX\n</pre></figure></code></pre>\n</li>\n</ol>\n","excerpt":57,"source":"_posts/mac1.md","slug":"mac1","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"43":{"id":0,"title":"mac 下更新DNS 缓存","date":"2013-09-03T09:14:30.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[1,6],"tags":[1],"comments":true,"layout":"post","content":"<p>开始的时候难免遇到修改host的时候，但是host后没有即刻生效，可使用终端命令手动清除DNS缓存：</p>\n<figure class=\"highlight\"><pre><span class=\"title\">dscacheutil</span> -flushcache\n</pre></figure>\n\n","excerpt":0,"source":"_posts/mac4.md","slug":"mac4","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"44":{"id":0,"title":"工作四年多了","date":"2013-08-08T09:16:03.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[7],"tags":[2],"comments":true,"layout":"post","content":"<h2>工作好几年了 谈谈自己的一些感想吧</h2>\n<p>最近几件事情触动挺大的，\n<a name=\"more\"></a></p>\n<p>1：跟侯的差距越来越远了， 不到三年 侯做到了很多我没做到的事情1-)自考了北大计算机系 2-)结识了年薪几十万的漂亮嫂子 3-）拿到了驾照 4-）在燕郊买了房子</p>\n<p>虽然彼此间还是隔三差五的聚聚，但是间隔越来越长了，大家都在忙，而我是真的在瞎忙 忙的没有任何意义。</p>\n<p>2：家里的压力，家里的压力从催着找女朋友结婚 到现在的赶紧攒首付买房子，之前很天真的甚至有些自私的想 不结婚不要孩子，可是现在觉得真的很对不起两个老人的</p>\n<p>3：同事和朋友，现在还记得几年前 sally姐说的那句话 同事永远成不了朋友。 有一次跟周妈谈起旺哥为什么不喜欢带新人，周妈谈了一口气说 旺旺是被现在这个社会伤的太深了了。虽然不太清楚在旺哥身上发生过什么 但是 回想这几年发生在自己身上的事情 也能体会的到写。现在这年头 不要期待着知恩图报 祈求不要恩将仇报就好了。 </p>\n<p>4：多一事不如少一事。  自己的经历应该放到有价值的人和事上面。 </p>\n<p>5：金钱虽然不是唯一的判断标准 但是却是最有效的衡量一个人的办法。</p>\n<p>6：珍惜零散的时间 </p>\n<p>7：英语 very important</p>\n<p>8：一些事情心里明白就行了 不要说出来</p>\n<img src=\"http://img.my.csdn.net/uploads/201101/25/3619941_1295933551y8U4.jpg\" class=\"right profile\" width=\"300\" height=\"500\" title=\"昔日的小伙伴\">\n","excerpt":43,"source":"_posts/mood.md","slug":"mood","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"45":{"id":0,"title":"Markdown","date":"2013-08-14T08:13:21.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[5],"tags":[1],"comments":true,"layout":"post","content":"<p>本文简单介绍下 Markdown 语法\n<a name=\"more\"></a></p>\n<h3>什么是Markdown</h3>\n<p>Markdown是一个将文本转化为HTML的工具。简单来说，Markdown是一个兼顾可读性与易用性的轻量级标记体系。Markdown并不追求大而全，它只关心HTML里最常用的几个标记，对于一些不常用的标记它允许直接将HTML标记插入文本。</p>\n<hr>\n<h2>表格</h2>\n<table>\n<thead>\n<tr>\n<th>标号</th>\n<th>面向对象概念</th>\n<th>面向关系概念 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>1</em></td>\n<td><code>对象</code></td>\n<td><strong>表的行（即记录）</strong></td>\n</tr>\n<tr>\n<td>2</td>\n<td>属性</td>\n<td>表的列（即字段）</td>\n</tr>\n</tbody>\n</table>\n<p>代码如下</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">标号</span>  <span class=\"comment\">|</span> <span class=\"comment\">面向对象概念</span> <span class=\"comment\">|</span> <span class=\"comment\">面向关系概念</span> \n<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">|</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span> <span class=\"comment\">|</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span>\n<span class=\"comment\">*1*</span> <span class=\"comment\">|</span> <span class=\"comment\">`对象`</span> <span class=\"comment\">|</span> <span class=\"comment\">**表的行（即记录）**</span>\n<span class=\"comment\">2</span> <span class=\"comment\">|</span> <span class=\"comment\">属性</span> <span class=\"comment\">|</span> <span class=\"comment\">表的列（即字段）\n</pre></figure>\n\n<hr>\n<h2>标题</h2>\n<p>Markdown提供了两种方式（Setext和Atx）来显示标题。</p>\n<p>代码如下</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">Setext方式</span>\n<span class=\"comment\">标题1</span>\n<span class=\"comment\">=================</span>\n\n<span class=\"comment\">标题2</span>\n<span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"literal\">-</span>\n\n<span class=\"comment\">Atx方式</span>\n<span class=\"comment\">#</span> <span class=\"comment\">标题1</span>\n<span class=\"comment\">##</span> <span class=\"comment\">标题2</span>\n<span class=\"comment\">######</span> <span class=\"comment\">标题6\n</pre></figure>\n\n<hr>\n<h2>换行</h2>\n<p>在文字的末尾使用两个或两个以上的空格来表示换行。</p>\n<p>代码如下</p>\n<figure class=\"highlight\"><pre><span class=\"blockquote\">&gt; 这是一个引用，</span>\n<span class=\"blockquote\">&gt; 这里木有换行，   </span>\n<span class=\"blockquote\">&gt; 在这里换行了。</span>\n<span class=\"blockquote\">&gt; &gt; 内部嵌套</span>\n</pre></figure>\n\n<hr>\n<h2>列表</h2>\n<h3>无序列表使用*、+或-后面加上空格来表示。</h3>\n<p>代码如下 </p>\n<figure class=\"highlight\"><pre><span class=\"bullet\">* </span>Item 1\n<span class=\"bullet\">* </span>Item 2\n<span class=\"bullet\">* </span>Item 3\n\n<span class=\"bullet\">+ </span>Item 1\n<span class=\"bullet\">+ </span>Item 2\n<span class=\"bullet\">+ </span>Item 3\n\n<span class=\"bullet\">- </span>Item 1\n<span class=\"bullet\">- </span>Item 2\n<span class=\"bullet\">- </span>Item 3\n</pre></figure>\n\n<h3>有序列表使用数字加英文句号加空格表示。</h3>\n<p>代码如下 </p>\n<figure class=\"highlight\"><pre><span class=\"bullet\">1. </span>Item 1\n<span class=\"bullet\">2. </span>Item 2\n<span class=\"bullet\">3. </span>Item 3\n</pre></figure>\n\n<hr>\n<h2>代码区域</h2>\n<p>行内代码使用反斜杠`表示。 \n代码段落则是在每行文字前加4个空格或者1个缩进符表示。</p>\n<hr>\n<h2>强调</h2>\n<p>Markdown使用*或_表示强调。</p>\n<p>代码如下 </p>\n<figure class=\"highlight\"><pre>\n单星号 = <span class=\"emphasis\">*斜体*</span>\n单下划线 = <span class=\"emphasis\">_斜体_</span>\n双星号 = <span class=\"strong\">**加粗**</span>\n双下划线 = <span class=\"strong\">__加粗__</span>\n</pre></figure>\n\n<p>链接</p>\n<p>Markdown支持两种风格的链接：Inline和Reference。</p>\n<p>语法：</p>\n<p>Inline：以中括号标记显示的链接文本，后面紧跟用小括号包围的链接。如果链接有title属性，则在链接中使用空格加“title属性”。\nReference：一般应用于多个不同位置使用相同链接。通常分为两个部分，调用部分为[链接文本][ref]；定义部分可以出现在文本中的其他位置，格式为[ref]: <a href=\"http://some/link/address\">http://some/link/address</a> (可选的标题)。 \n注：ref中不区分大小写。</p>\n<p>代码如下 </p>\n<figure class=\"highlight\"><pre>\n这是一个Inline[示例](http:<span class=\"comment\">//www.baidu.com \"可选的title\")。</span>\n这是一个Reference[示例][<span class=\"keyword\">ref</span>]。\n[<span class=\"keyword\">ref</span>]: http:<span class=\"comment\">//www.baidu.com</span>\n</pre></figure>\n\n<hr>\n<h2>图片</h2>\n<p>图片的使用方法基本上和链接类似，只是在中括号前加叹号。 \n注：Markdown不能设置图片大小，如果必须设置则应使用HTML标记<img>。</p>\n<p>代码如下 </p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">notextile</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"title\">notextile</span>&gt;</span>\n\nInline示例：![替代文本](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\")\nReference示例：![替代文本][pic]\n[pic]: http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\"\nHTML示例：<span class=\"tag\">&lt;<span class=\"title\">img</span> <span class=\"attribute\">src</span>=<span class=\"value\">\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\"</span> <span class=\"attribute\">alt</span>=<span class=\"value\">\"替代文本\"</span> <span class=\"attribute\">title</span>=<span class=\"value\">\"标题文本\"</span> <span class=\"attribute\">width</span>=<span class=\"value\">\"200\"</span> /&gt;</span>\n</pre></figure>\n\n<p>效果</p>\n<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" class=\"right\" width=\"300\" height=\"400\" title=\"可选的title\">\n\n<p>Inline示例：<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" alt=\"替代文本\" title=\"可选的title\">\nReference示例：![替代文本][<a href=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\">http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg</a>]</p>\n<p>HTML示例：<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" alt=\"替代文本\" title=\"标题文本\" width=\"200\" /></p>\n<hr>\n<h2>自动链接</h2>\n<p>使用尖括号，可以为输入的URL或者邮箱自动创建链接。如test@test.com。</p>\n<h2>分隔线</h2>\n<p>在一行中使用三个或三个以上的*、-或_可以添加分隔线，其中可以有空白，但是不能有其他字符。</p>\n<h2>转义字符</h2>\n<p>Markdown中的转义字符为\\，可以转义的有：</p>\n<figure class=\"highlight\"><pre><span class=\"command\">\\\\</span> 反斜杠\n<span class=\"command\">\\`</span> 反引号\n<span class=\"command\">\\*</span> 星号\n<span class=\"command\">\\_</span> 下划线\n<span class=\"command\">\\{</span><span class=\"command\">\\}</span> 大括号\n<span class=\"command\">\\[</span><span class=\"command\">\\]</span> 中括号\n<span class=\"command\">\\(</span><span class=\"command\">\\)</span> 小括号\n<span class=\"command\">\\#</span> 井号\n<span class=\"command\">\\+</span> 加号\n<span class=\"command\">\\-</span> 减号\n<span class=\"command\">\\.</span> 英文句号\n<span class=\"command\">\\!</span> 感叹号\n</pre></figure>\n\n","excerpt":23,"source":"_posts/markdown.md","slug":"markdown","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"46":{"id":0,"title":"MQ 笔记之 mac 下安装环境","date":"2013-08-20T09:47:34.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[8],"tags":[1],"comments":true,"layout":"post","content":"<h2>下载</h2>\n<p><a href=\"http://www.apache.org/dyn/closer.cgi?path=/activemq/apache-activemq/5.8.0/apache-activemq-5.8.0-bin.tar.gz\">从下载地址中下载包</a>\n解压包然后把包放到一个自己不会手一抖就删掉的位置，此处我放到了本地的document下\n如下图\n<a name=\"more\"></a></p>\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7uav8h7lbj20o80gkjtw.jpg\" class=\"left\" width=\"200\" height=\"300\" title=\"图片\">\n\n<h2>添加环境到path</h2>\n<p>把/你的保存路径/apache-activemq-5.8.0/bin/activemq 添加到 PATH 中 </p>\n<ol>\n<li>cd </li>\n<li>执行 vi .profile </li>\n<li>输入 i </li>\n<li>插入 export MQ=/你的路径/apache-activemq-5.8.0/bin/macosx/activemq</li>\n<li>wq</li>\n<li>source .profile</li>\n</ol>\n<h2>启动mq</h2>\n<p>$Mq start\n输入账号 admin 密码  admin</p>\n<p><strong>注意</strong> 如果用代理上网 请把网络环境设置下 如下图</p>\n<img src=\"http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubcv9nx0j20oa08egmc.jpg\" width=\"200\" height=\"300\" title=\"网络配置\">\n\n\n<h2>查看启动效果</h2>\n<img src=\"http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubfs7cg1j21ga0oe0yw.jpg\" width=\"200\" height=\"300\" title=\"启动效果\">\n\n\n<h2>基本配置</h2>\n<p>conf/jetty.xml</p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">bean</span> <span class=\"attribute\">id</span>=<span class=\"value\">\"securityConstraint\"</span>&gt;</span>\n \n        <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"name\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"BASIC\"</span> /&gt;</span>\n \n        <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"roles\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"admin\"</span> /&gt;</span>\n \n        <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"authenticate\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"false\"</span> /&gt;</span>\n \n<span class=\"tag\">&lt;/<span class=\"title\">bean</span>&gt;</span>\n</pre></figure>\n\n<p>此处可以配置登陆用户权限</p>\n<figure class=\"highlight\"><pre> <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"connectors\"</span>&gt;</span>\n            <span class=\"tag\">&lt;<span class=\"title\">list</span>&gt;</span>\n                <span class=\"tag\">&lt;<span class=\"title\">bean</span> <span class=\"attribute\">id</span>=<span class=\"value\">\"Connector\"</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"org.eclipse.jetty.server.nio.SelectChannelConnector\"</span>&gt;</span>\n                    <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"port\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"8161\"</span> /&gt;</span>\n                <span class=\"tag\">&lt;/<span class=\"title\">bean</span>&gt;</span>\n            <span class=\"tag\">&lt;/<span class=\"title\">list</span>&gt;</span>\n <span class=\"tag\">&lt;/<span class=\"title\">property</span>&gt;</span>\n</pre></figure>\n\n<p>此处用来修改端口号</p>\n","excerpt":194,"source":"_posts/mq1.md","slug":"mq1","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"47":{"id":0,"title":"MQ 笔记之 消息持久化","date":"2013-08-21T15:43:37.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[8],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>在broker中设置属性persistent=”true”(默认是true)，同时发送的消息也应该是persitent类型的。ActiveMQ消息持久化有三种方式：AMQ、KahaDB、JDBC。\n配置文件在config/jetty.xml\n<a name=\"more\"></a></p>\n</blockquote>\n<h2>一、AMQ</h2>\n<p>AMQ是一种文件存储形式，它具有写入速度快和容易恢复的特点。消息存储在一个个文件中，文件的默认大小为32兆，如果一条消息的大小超过了32兆，那么这个值必须设置大点。当一个存储文件中的消息已经全部被消费，那么这个文件将被标识为可删除，在下一个清除阶段，这个文件被删除。默认配置如下：</p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">amqPersistenceAdapter</span> <span class=\"attribute\">directory</span>=<span class=\"value\">\"activemq-data\"</span> <span class=\"attribute\">maxFileLength</span>=<span class=\"value\">\"32mb\"</span>/&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span>\n</pre></figure>\n\n<table>\n<thead>\n<tr>\n<th>属性名称</th>\n<th>默认值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>directory</td>\n<td>activemq-data</td>\n<td>消息文件和日志的存储目录</td>\n</tr>\n<tr>\n<td>useNIO</td>\n<td>true</td>\n<td>使用NIO协议存储消息</td>\n</tr>\n<tr>\n<td>syncOnWrite</td>\n<td>false</td>\n<td>同步写到磁盘，这个选项对性能影响非常大</td>\n</tr>\n<tr>\n<td>maxFileLength</td>\n<td>32mb</td>\n<td>一个消息文件的大小</td>\n</tr>\n<tr>\n<td>persistentIndex</td>\n<td>true</td>\n<td>消息索引的持久化，如果为false，那么索引保存在内存中</td>\n</tr>\n<tr>\n<td>maxCheckpointMessageAddSize</td>\n<td>4kb</td>\n<td>一个事务允许的最大消息量</td>\n</tr>\n<tr>\n<td>cleanupInterval</td>\n<td>30000</td>\n<td>清除操作周期，单位ms</td>\n</tr>\n<tr>\n<td>indexBinSize</td>\n<td>1024</td>\n<td>索引文件缓存页面数，缺省为1024，当amq扩充或者缩减存储时，会锁定整个broker，导致一定时间的阻塞，所以这个值应该调整到比较大，但是代码中实现会动态伸缩，调整效果并不理想。</td>\n</tr>\n<tr>\n<td>indexKeySize</td>\n<td>96</td>\n<td>索引key的大小，key是消息ID</td>\n</tr>\n<tr>\n<td>indexPageSize</td>\n<td>16kb</td>\n<td>索引的页大小</td>\n</tr>\n<tr>\n<td>directoryArchive</td>\n<td>archive</td>\n<td>存储被归档的消息文件目录</td>\n</tr>\n<tr>\n<td>archiveDataLogs</td>\n<td>false</td>\n<td>当为true时，归档的消息文件被移到directoryArchive,而不是直接删除</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>二、 KahaDB</h2>\n<p>KahaDB是基于文件的本地数据库储存形式，虽然没有AMQ的速度快，但是它具有强扩展性，恢复的时间比AMQ短，从5.4版本之后KahaDB做为默认的持久化方式。默认配置如下</p>\n<figure class=\"highlight\"><pre> <span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"title\">kahaDB</span> <span class=\"attribute\">directory</span>=<span class=\"value\">\"activemq-data\"</span> <span class=\"attribute\">journalMaxFileLength</span>=<span class=\"value\">\"32mb\"</span>/&gt;</span>\n <span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span>\n</pre></figure>\n\n<p>KahaDB的属性：</p>\n<table>\n<thead>\n<tr>\n<th>property name</th>\n<th>default value</th>\n<th>Comments</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>directory</td>\n<td>activemq-data</td>\n<td>消息文件和日志的存储目录</td>\n</tr>\n<tr>\n<td>indexWriteBatchSize</td>\n<td>1000</td>\n<td>一批索引的大小，当要更新的索引量到达这个值时，更新到消息文件中</td>\n</tr>\n<tr>\n<td>indexCacheSize</td>\n<td>10000</td>\n<td>内存中，索引的页大小</td>\n</tr>\n<tr>\n<td>enableIndexWriteAsync</td>\n<td>false</td>\n<td>索引是否异步写到消息文件中</td>\n</tr>\n<tr>\n<td>journalMaxFileLength</td>\n<td>32mb</td>\n<td>一个消息文件的大小</td>\n</tr>\n<tr>\n<td>enableJournalDiskSyncs</td>\n<td>true</td>\n<td>是否讲非事务的消息同步写入到磁盘</td>\n</tr>\n<tr>\n<td>cleanupInterval</td>\n<td>30000</td>\n<td>清除操作周期，单位ms</td>\n</tr>\n<tr>\n<td>checkpointInterval</td>\n<td>5000</td>\n<td>索引写入到消息文件的周期，单位ms</td>\n</tr>\n<tr>\n<td>ignoreMissingJournalfiles</td>\n<td>false</td>\n<td>忽略丢失的消息文件，false，当丢失了消息文件，启动异常</td>\n</tr>\n<tr>\n<td>checkForCorruptJournalFiles</td>\n<td>false</td>\n<td>检查消息文件是否损坏，true，检查发现损坏会尝试修复</td>\n</tr>\n<tr>\n<td>checksumJournalFiles</td>\n<td>false</td>\n<td>产生一个checksum，以便能够检测journal文件是否损坏。</td>\n</tr>\n<tr>\n<td><code>5.4版本之后有效的属性:</code></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>archiveDataLogs</td>\n<td>false</td>\n<td>当为true时，归档的消息文件被移到directoryArchive,而不是直接删除</td>\n</tr>\n<tr>\n<td>directoryArchive</td>\n<td>null</td>\n<td>存储被归档的消息文件目录</td>\n</tr>\n<tr>\n<td>databaseLockedWaitDelay</td>\n<td>10000</td>\n<td>在使用负载时，等待获得文件锁的延迟时间，单位ms</td>\n</tr>\n<tr>\n<td>maxAsyncJobs</td>\n<td>10000</td>\n<td>同个生产者产生等待写入的异步消息最大量</td>\n</tr>\n<tr>\n<td>concurrentStoreAndDispatchTopics</td>\n<td>false</td>\n<td>当写入消息的时候，是否转发主题消息</td>\n</tr>\n<tr>\n<td>concurrentStoreAndDispatchQueues</td>\n<td>true</td>\n<td>当写入消息的时候，是否转发队列消息</td>\n</tr>\n<tr>\n<td>5.6版本之后有效的属性:</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>archiveCorruptedIndex</td>\n<td>false</td>\n<td>是否归档错误的索引</td>\n</tr>\n</tbody>\n</table>\n<p>从5.6版本之后，有可能发布通过多个kahadb持久适配器来实现分布式目标队列存储。什么时候用呢？如果有一个快速的生产者和消费者，当某一个时刻生产者发生了不规范的消费，那么有可能产生一条消息被存储在两个消息文件中，同时，有些目标队列是危险的并且要求访问磁盘。在这种情况下，你应该用通配符来使用mKahaDB。如果目标队列是分布的，事务是可以跨越多个消息文件的。</p>\n<p>每个KahaDB的实例都可以配置单独的适配器，如果没有目标队列提交给filteredKahaDB，那么意味着对所有的队列有效。如果一个队列没有对应的适配器，那么将会抛出一个异常。配置如下：</p>\n<figure class=\"highlight\"><pre><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">mKahaDB</span> <span class=\"attribute\">directory</span>=<span class=\"value\">\"</span><span class=\"variable\">${activemq.base}</span><span class=\"xml\">/data/kahadb\"&gt;\n    <span class=\"tag\">&lt;<span class=\"title\">filteredPersistenceAdapters</span>&gt;</span>\n      <span class=\"comment\">&lt;!-- match all queues --&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">filteredKahaDB</span> <span class=\"attribute\">queue</span>=<span class=\"value\">\"&gt;\"</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n          <span class=\"tag\">&lt;<span class=\"title\">kahaDB</span> <span class=\"attribute\">journalMaxFileLength</span>=<span class=\"value\">\"</span><span class=\"number\">32</span><span class=\"xml\">mb\"/&gt;\n        <span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span>\n      <span class=\"tag\">&lt;/<span class=\"title\">filteredKahaDB</span>&gt;</span>\n      \n      <span class=\"comment\">&lt;!-- match all destinations --&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">filteredKahaDB</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n          <span class=\"tag\">&lt;<span class=\"title\">kahaDB</span> <span class=\"attribute\">enableJournalDiskSyncs</span>=<span class=\"value\">\"false\"</span>/&gt;</span>\n        <span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span>\n      <span class=\"tag\">&lt;/<span class=\"title\">filteredKahaDB</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"title\">filteredPersistenceAdapters</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"title\">mKahaDB</span>&gt;</span>\n <span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span></span>\n</pre></figure>\n\n<p>如果filteredKahaDB的perDestination属性设置为true，那么匹配的目标队列将会得到自己对应的KahaDB实例。配置如下</p>\n<figure class=\"highlight\"><pre><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n  <span class=\"tag\">&lt;<span class=\"title\">mKahaDB</span> <span class=\"attribute\">directory</span>=<span class=\"value\">\"</span><span class=\"variable\">${activemq.base}</span><span class=\"xml\">/data/kahadb\"&gt;\n    <span class=\"tag\">&lt;<span class=\"title\">filteredPersistenceAdapters</span>&gt;</span>\n      <span class=\"comment\">&lt;!-- kahaDB per destinations --&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">filteredKahaDB</span> <span class=\"attribute\">perDestination</span>=<span class=\"value\">\"true\"</span> &gt;</span>\n        <span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n          <span class=\"tag\">&lt;<span class=\"title\">kahaDB</span> <span class=\"attribute\">journalMaxFileLength</span>=<span class=\"value\">\"</span><span class=\"number\">32</span><span class=\"xml\">mb\" /&gt;\n        <span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span>\n      <span class=\"tag\">&lt;/<span class=\"title\">filteredKahaDB</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"title\">filteredPersistenceAdapters</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"title\">mKahaDB</span>&gt;</span>\n <span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span></span>\n</pre></figure>\n\n<h2>三、 JDBC</h2>\n<p>配置JDBC适配器</p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">persistenceAdapter</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"title\">jdbcPersistenceAdapter</span> <span class=\"attribute\">dataSource</span>=<span class=\"value\">\"#mysql-ds\"</span> <span class=\"attribute\">createTablesOnStartup</span>=<span class=\"value\">\"false\"</span> /&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">persistenceAdapter</span>&gt;</span>\n</pre></figure>\n\n<p>dataSource指定持久化数据库的bean，createTablesOnStartup是否在启动的时候创建数据表，默认值是true，这样每次启动都会去创建数据表了，一般是第一次启动的时候设置为true，之后改成false。</p>\n<p>MYSQL持久化bean</p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">bean</span> <span class=\"attribute\">id</span>=<span class=\"value\">\"mysql-ds\"</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"org.apache.commons.dbcp.BasicDataSource\"</span> <span class=\"attribute\">destroy-method</span>=<span class=\"value\">\"close\"</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"driverClassName\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"com.mysql.jdbc.Driver\"</span>/&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"url\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"jdbc:mysql://localhost/activemq?relaxAutoCommit=true\"</span>/&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"username\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"activemq\"</span>/&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"password\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"activemq\"</span>/&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"poolPreparedStatements\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"true\"</span>/&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">bean</span>&gt;</span>\n</pre></figure>\n\n<p>SQL Server持久化bean</p>\n<figure class=\"highlight\"><pre> <span class=\"tag\">&lt;<span class=\"title\">bean</span> <span class=\"attribute\">id</span>=<span class=\"value\">\"mssql-ds\"</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"net.sourceforge.jtds.jdbcx.JtdsDataSource\"</span> <span class=\"attribute\">destroy-method</span>=<span class=\"value\">\"close\"</span>&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"serverName\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"SERVERNAME\"</span>/&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"portNumber\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"PORTNUMBER\"</span>/&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"databaseName\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"DATABASENAME\"</span>/&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"user\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"USER\"</span>/&gt;</span>\n   <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"password\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"PASSWORD\"</span>/&gt;</span>\n <span class=\"tag\">&lt;/<span class=\"title\">bean</span>&gt;</span>\n</pre></figure>\n\n<p>Oracle持久化bean</p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">bean</span> <span class=\"attribute\">id</span>=<span class=\"value\">\"oracle-ds\"</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"org.apache.commons.dbcp.BasicDataSource\"</span> <span class=\"attribute\">destroy-method</span>=<span class=\"value\">\"close\"</span>&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"driverClassName\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"oracle.jdbc.driver.OracleDriver\"</span>/&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"url\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"jdbc:oracle:thin:@10.53.132.47:1521:activemq\"</span>/&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"username\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"activemq\"</span>/&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"password\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"activemq\"</span>/&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"maxActive\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"200\"</span>/&gt;</span>\n\t<span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"poolPreparedStatements\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"true\"</span>/&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">bean</span>&gt;</span>\n</pre></figure>\n\n<p>DB2持久化bean</p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">bean</span> <span class=\"attribute\">id</span>=<span class=\"value\">\"db2-ds\"</span> <span class=\"attribute\">class</span>=<span class=\"value\">\"org.apache.commons.dbcp.BasicDataSource\"</span>  <span class=\"attribute\">destroy-method</span>=<span class=\"value\">\"close\"</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"driverClassName\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"com.ibm.db2.jcc.DB2Driver\"</span>/&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"url\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"jdbc:db2://hndb02.bf.ctc.com:50002/activemq\"</span>/&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"username\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"activemq\"</span>/&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"password\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"activemq\"</span>/&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"maxActive\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"200\"</span>/&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">property</span> <span class=\"attribute\">name</span>=<span class=\"value\">\"poolPreparedStatements\"</span> <span class=\"attribute\">value</span>=<span class=\"value\">\"true\"</span>/&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"title\">bean</span>&gt;</span>\n</pre></figure>\n\n<hr>\n<blockquote>\n<p>本博文from 淮少吧</p>\n</blockquote>\n","excerpt":137,"source":"_posts/mq3.md","slug":"mq3","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"48":{"id":0,"title":"MQ 笔记之 JMS 简介 （什么是JMS）","date":"2013-08-21T13:22:00.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[8],"tags":[1],"comments":true,"layout":"post","content":"<h2>一：JMS基本概念</h2>\n<h3>1.      JMS的目标</h3>\n<p>为企业级的应用提供一种智能的消息系统，JMS定义了一整套的企业级的消息概念与工具，\n<a name=\"more\"></a></p>\n<p>尽可能最小化的Java语言概念去构建最大化企业消息应用。统一已经存在的企业级消息系</p>\n<p>统功能。</p>\n<h3>2.      JMS提供者</h3>\n<p>JMS提供者是指那些完全完成JMS功能与管理功能的JMS消息厂商，理论上JMS提供者完成 </p>\n<p>JMS消息产品必须是100%的纯Java语言实现，可以运行在跨平台的架构与操作系统上，当前</p>\n<p>一些JMS厂商包括IBM,Oracle, JBoss社区 (JBoss Community), Apache 社区(ApacheCommunity)。</p>\n<h3>3.      JMS应用程序, 一个完整的JMS应用应该实现以下功能：</h3>\n<ul>\n<li><p>JMS 客户端 – Java语言开发的接受与发送消息的程序</p>\n</li>\n<li><p>非JMS客户端 – 基于消息系统的本地API实现而不是JMS</p>\n</li>\n<li><p>消息 – 应用程序用来相互交流信息的载体</p>\n</li>\n<li><p>被管理对象–预先配置的JMS对象，JMS管理员创建，被客户端运用。如链接工厂，主题等</p>\n</li>\n<li><p>JMS提供者–完成JMS功能与管理功能的消息系统</p>\n</li>\n</ul>\n<h2>二: JMS 规范</h2>\n<h3>连接工厂</h3>\n<p>连接工厂是GUST用来创建连接的对象，例如ActiveMQ提供的ActiveMQConnectionFactory。</p>\n<h3>连接</h3>\n<p>JMS Connection封装了客户与JMS提供者之间的一个虚拟的连接。</p>\n<h3>会话</h3>\n<p>MS Session是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。</p>\n<h3>目的地</h3>\n<p>目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2 规范中定义了两种消息传递域</p>\n<h4>点对点的消息模式(Point to Point Messaging)</h4>\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7umekfemwj20is06o0tb.jpg\" height=\"300\" title=\" 200 点对点\">\n\n\n<hr>\n<p>下面的JMS对象在点对点消息模式中是必须的：</p>\n<ul>\n<li><p>队列(Queue) – 一个提供者命名的队列对象，客户端将会使用这个命名的队列对象</p>\n</li>\n<li><p>队列链接工厂(QueueConnectionFactory) – 客户端使用队列链接工厂创建链接队列ConnectionQueue来取得与JMS点对点消息提供者的链接。</p>\n</li>\n<li><p>链接队列(ConnectionQueue) – 一个活动的链接队列存在在客户端与点对点消息提供者之间，客户用它创建一个或者多个JMS队列会话(QueueSession)</p>\n</li>\n<li><p>队列会话(QueueSession) – 用来创建队列消息的发送者与接受者(QueueSenderandQueueReceiver)</p>\n</li>\n<li><p>消息发送者(QueueSender 或者MessageProducer)– 发送消息到已经声明的队列</p>\n</li>\n<li><p>消息接受者(QueueReceiver或者MessageConsumer) – 接受已经被发送到指定队列的消息</p>\n</li>\n</ul>\n<p><strong>注意如下：</strong></p>\n<ul>\n<li>每个消息只能有一个消费者。</li>\n<li>消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。</li>\n</ul>\n<h4>发布订阅模式(publish – subscribe Mode)</h4>\n<img src=\"http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7umpp9onwj20is0ayjsk.jpg\" class=\"center\" height=\"200\" title=\" 300 发布者\">\n\n<hr>\n<ul>\n<li><p>主题Topic(Destination) – 一个提供者命名的主题对象，客户端将会使用这个命名的主题对象</p>\n</li>\n<li><p>主题链接工厂(TopciConnectionFactory) – 客户端使用主题链接工厂创建链接主题 ConnectionTopic来取得与JMS消息Pub/Sub提供者的链接</p>\n</li>\n<li><p>链接主题(ConnectionTopic) – 一个活动的链接主题存在发布者与订阅者之间</p>\n</li>\n<li><p>会话(TopicSession) – 用来创建主题消息的发布者与订阅者 (TopicPublisher  and TopicSubscribers)</p>\n</li>\n<li><p>消息发送者MessageProducer) – 发送消息到已经声明的主题</p>\n</li>\n<li><p>消息接受者(MessageConsumer) – 接受已经被发送到指定主题的消息</p>\n</li>\n</ul>\n<p><strong>注意如下：</strong></p>\n<ul>\n<li>每个消息可以有多个消费者。</li>\n<li>生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。</li>\n</ul>\n<hr>\n<blockquote>\n<p>本系列博文参考自whitesock  淮少吧 贾志刚</p>\n</blockquote>\n","excerpt":88,"source":"_posts/mq2.md","slug":"mq2","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"49":{"id":0,"title":"MQ 笔记之 游标 及其游标优化","date":"2013-08-22T01:38:51.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[8],"tags":[1],"comments":true,"layout":"post","content":"<h2>概观</h2>\n<blockquote>\n<p>在ActiveMQ的Broker中，光标用来持有一批在内存等待发送目标地址的消息。默认情况下这小消息被从存储器取出只想一个cursor(存储光标)<br><a name=\"more\"></a>\n5.0.0版本后，Activemq实现了一种新的内存模型来防止慢消费者阻塞快速生产者。通常消息在未消费或者发送后未收到消费者的确认信息时都会持久保存消息到存储中。当有消费者来消费消息时，broker会分页一批一批的从存储中取出消息，放入消息处理队列。游标就是指向下次批量获取消息时的存储位置。   </p>\n</blockquote>\n<p>ctiveMQ有另一种游标实现，VM cursor，在某些情境下非常快。VM cursor是，进入的消息直接关联cursor，同时存储到消息存储器中。（关联cursor的同时存储到消息存储器中）。如果消费者（consumer）非常快，可以跟的上消息流的话，VM cursor会工作的非常好。但是，对于慢消费者，这个策略就不是那么有效了。VMcursor被积压的消息填满，同时它可能会去调用流控制去抑制producer生产message。</p>\n<h2>根据游标的保存方式不同，可分为三种类型：</h2>\n<h3>Store-based cursors</h3>\n<p>broker默认采用的游标。它将游标信息保存在存储中。针对速度不同的消费者，这种游标机制采取的方式不同。对于快速消费者，因为消费速度很快，存储中 的消息数量会很少，所以不需要游标。这时，消息发送到broker时，先保存在持久存储中，然后直接发送给了消费者。而对于慢消费者，消息的持久存储中会 保存大量的消息，所以需要使用游标来指定下一次批量读取消息的位置。  </p>\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v81y31hnj20ip04qaaj.jpg\" class=\"center\" title=\"Store-based实现原理图 300 200\">\n\n<p> <strong>图一：</strong></p>\n<pre><code><figure class=\"highlight\"><pre> 消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedHashMap，如果没有可用内存，则走路径2，当需要消息的时候，直接从消息存储的介质里每次读取一批消息，然后存入LinkedHashMap。\n</pre></figure></code></pre>\n<h3>VM cursors</h3>\n<p>若消费者能跟上生产者生产的速度，这时持久存储中消息虽然不是很多，但是若能也能在内存中保存一些游标，对获取存储中的消息的性能会有很大的提升。 \n那么VM Cursors在ActiveMQ4.x中是如何工作的呢？发送消息保存在内存中，并在需要的时候传递给调度队列。这可以是非常快的，但也有不利的一面，不能够处理非常缓慢的消费者或消费者已经很长一段时间处于非活动状态：   </p>\n<img src=\"http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v878r0ahj20iu04tjrr.jpg\" class=\"center\" title=\"file实现原理图 300 200\">\n\n<p>  <strong>图二：</strong></p>\n<pre><code><figure class=\"highlight\"><pre>消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedList，如果没有可用内存，则走路径2，把消息写入临时文件中，当需要消息的时候，直接从临时文件中读写一批，然后送入LinkedList。\n</pre></figure></code></pre>\n<h3>File-based cursors</h3>\n<p>对VM cursors 的一种改进。当内存中的游标达到一定限额后，就会将一些游标存储到磁盘上的临时文件中。使用这种类型的游标时，消息储存可能会变慢，但消费者处理一般都会更快。通过缓冲到磁盘，它可以让消息代理来处理不受内存限制的大量消息，而生产者发送消息的速度会受到影响：\n <strong>图三</strong></p>\n <img src=\"http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7v8airx6dj20it04sjrl.jpg\" class=\"center\" title=\"vm 实现原理 300 200\">\n\n<pre><code><figure class=\"highlight\"><pre> 消息接收后，首先完成消息存储的工作，如(1)所示，然后直接把消息存放在内存中的LinkedList。\n</pre></figure></code></pre>\n<h3>Paging for Non-Persistent Messages（非持久性的消息分页调度）</h3>\n<p>Store based cursor也可以处理非持久性的消息，也就是没有存储在磁盘中的消息，非持久性消息被直接传递给游标，所以Store based cursor也只是嵌入了File based cursor的功能。</p>\n<h2>3种消息cursor的比较</h2>\n<table>\n<thead>\n<tr>\n<th>消息cursor类型</th>\n<th>性能</th>\n<th>稳定性</th>\n<th>最佳使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Store-based</td>\n<td>当内存不够时，需要进行1次消息存储操作，性能在3种方式中居中</td>\n<td>最好</td>\n<td>activeMQ默认使用该cursor，因为它能满足大部分场景需要</td>\n</tr>\n<tr>\n<td>File</td>\n<td>当内存不够时，需要进行2次消息存储操作，并且在删除消息的时候也就相应的要删除2次，性能在3种方式中最差</td>\n<td>居中</td>\n<td>主要用在当消息存储慢(如消息是放在数据库里)，并且消费者相对快的情况下</td>\n</tr>\n<tr>\n<td>VM</td>\n<td>在内存够的情况下，3种message cursor性能一样</td>\n<td>最容易出现内存溢出的问题</td>\n<td>很快，但不能处理慢消息消费者</td>\n</tr>\n</tbody>\n</table>\n<h3>基于存储的消息指针_测试结果</h3>\n<table>\n<thead>\n<tr>\n<th>测试方法</th>\n<th>结果说明</th>\n<th>是否通过</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送,不接收，因为是默认的，所以不用在服务器端配置。</td>\n<td>1．对于非持久化消息，一定数量之后，也会产生临时文件。 2．对于持久化的消息，则适用该方式的消息指针，直到达到磁盘空间的设置上限。</td>\n<td>是</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3>VM消息指针_测试结果</h3>\n<table>\n<thead>\n<tr>\n<th>测试方法</th>\n<th>结果说明</th>\n<th>是否通过</th>\n<th>备注 </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：cursore 队列中存储到一定量消息的时候，broker不再接收生产者发送过来的消息，56W左右，broker也不报错，客户端也不报错。</td>\n<td>是</td>\n<td>若设置producerflowControl=false，则消息数量持续增长，直到broker报错：WARN  AMQMessageStore  - Message could not be added to long term store: Java heap space java.lang.OutOfMemoryError: Java heap space </td>\n</tr>\n</tbody>\n</table>\n<h3>基于文件的消息指针_测试结果</h3>\n<table>\n<thead>\n<tr>\n<th>测试方法</th>\n<th>结果说明</th>\n<th>是否通过</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：fileQueueCursor</td>\n<td>一段时间之后，broker打印出一信息：INFO MonetStore - Monet Store using data directory &quot;C:\\Activemq 5.1\\bin..  \\data\\localhost\\tmp_storage&quot;  临时文件被放置在tmp_storage目录下</td>\n<td>是</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>Configuring Cursors</h2>\n<p>Activemq默认使用store-based游标。当然也可为不同的Destination修改游标策略。通过修改destinationPolicy节点来更改默认配置。<br>destinationPolicy节点包含多ge policyMap节点。<br>policyMap包含一个policyEntries节点，policyEntries节点包含多个policyEntry 节点。policyEntry就是具体的一个游标策略了。<br>Topics的消费者分为持久订阅者和临时订阅者，所以有两套配置。Queues只有一类消费者，所以只有一套配置。\n对于持久订阅者可以使用PendingDurableSubscriberMessageStoragePolicy来指定游标策略。可配置的策略有vmDurableCursor和fileDurableSubscriberCursor. </p>\n<p><strong>对于临时订阅者可以使用pendingSubscriberPolicy 来指定。可配置的策略有vmCursor和fileCursor。下面是关于Topics的一些xml配置：</strong></p>\n<figure class=\"highlight\"><pre>&lt;beans <span class=\"keyword\">...</span> &gt;\n&lt;broker <span class=\"keyword\">...</span>&gt;\n    <span class=\"keyword\">...</span>\n&lt;destinationPolicy&gt;\n&lt;policyMap&gt;\n&lt;policyEntries&gt;\n&lt;policyEntrytopic=<span class=\"string\">\"com.iona.&gt;\"</span>&gt;\n            <span class=\"keyword\">...</span>\n&lt;pendingSubscriberPolicy&gt;\n&lt;vmCursor/&gt;\n&lt;/pendingSubscriberPolicy&gt;\n&lt;PendingDurableSubscriberMessageStoragePolicy&gt;\n&lt;fileDurableSubscriberPolicy/&gt;\n&lt;/PendingDurableSubscriberMessageStoragePolicy&gt;\n            <span class=\"keyword\">...</span>\n&lt;/policyEntry&gt;\n          <span class=\"keyword\">...</span>\n&lt;/policyEntries&gt;\n&lt;/policyMap&gt;\n&lt;/destinationPolicy&gt;\n    <span class=\"keyword\">...</span>\n&lt;/broker&gt;\n  <span class=\"keyword\">...</span>\n&lt;/beans&gt;\n</pre></figure>\n\n<p><strong>Queues 同样也有vm和file两种类型的游标存储策略。pendingQueuePolicy 节点的可配置子节点有vmQueueCursor和fileQueueCursor</strong></p>\n<figure class=\"highlight\"><pre>&lt;beans <span class=\"keyword\">...</span> &gt;\n&lt;broker <span class=\"keyword\">...</span>&gt;\n        <span class=\"keyword\">...</span>   \n&lt;destinationPolicy&gt;\n&lt;policyMap&gt;\n&lt;policyEntries&gt;\n&lt;policyEntryqueue=<span class=\"string\">\"com.iona.&gt;\"</span>&gt;  \n                <span class=\"keyword\">...</span>   \n&lt;pendingQueuePolicy&gt;\n&lt;vmQueueCursor/&gt;\n&lt;/pendingQueuePolicy&gt;\n                <span class=\"keyword\">...</span>   \n&lt;/policyEntry&gt;\n              <span class=\"keyword\">...</span>   \n&lt;/policyEntries&gt;\n&lt;/policyMap&gt;\n&lt;/destinationPolicy&gt;\n        <span class=\"keyword\">...</span>   \n&lt;/broker&gt;\n      <span class=\"keyword\">...</span>   \n&lt;/beans&gt;\n</pre></figure>\n\n<h3>配置vmcursor：</h3>\n<p>下面配置了一个borker的所有topic和queue都使用了vmCursor</p>\n<figure class=\"highlight\"><pre><span class=\"tag\">&lt;<span class=\"title\">broker</span> <span class=\"attribute\">...</span> &gt;</span>\n  ...\n  <span class=\"tag\">&lt;<span class=\"title\">destinationPolicy</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"title\">policyMap</span>&gt;</span>\n      <span class=\"tag\">&lt;<span class=\"title\">policyEntries</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"title\">policyEntry</span> <span class=\"attribute\">topic</span>=<span class=\"value\">\"&gt;\"</span>&gt;</span>\n          <span class=\"tag\">&lt;<span class=\"title\">pendingSubscriberPolicy</span>&gt;</span>\n            <span class=\"tag\">&lt;<span class=\"title\">vmCursor</span> /&gt;</span>\n          <span class=\"tag\">&lt;/<span class=\"title\">pendingSubscriberPolicy</span>&gt;</span>\n        <span class=\"tag\">&lt;/<span class=\"title\">policyEntry</span>&gt;</span>\n        <span class=\"tag\">&lt;<span class=\"title\">policyEntry</span> <span class=\"attribute\">queue</span>=<span class=\"value\">\"&gt;\"</span>&gt;</span>\n          <span class=\"tag\">&lt;<span class=\"title\">pendingSubscriberPolicy</span>&gt;</span>\n            <span class=\"tag\">&lt;<span class=\"title\">vmCursor</span> /&gt;</span>\n          <span class=\"tag\">&lt;/<span class=\"title\">pendingSubscriberPolicy</span>&gt;</span>\n        <span class=\"tag\">&lt;/<span class=\"title\">policyEntry</span>&gt;</span>\n      <span class=\"tag\">&lt;/<span class=\"title\">policyEntries</span>&gt;</span>\n    <span class=\"tag\">&lt;/<span class=\"title\">policyMap</span>&gt;</span>\n  <span class=\"tag\">&lt;/<span class=\"title\">destinationPolicy</span>&gt;</span>\n  ...\n<span class=\"tag\">&lt;/<span class=\"title\">broker</span>&gt;</span>\n</pre></figure>\n\n<p>topic和queue都使用了通配符【&gt;】,这个匹配所有的目标名称。你可以根据情况指定一些选择目标的模式。但是VM Cursor仅仅适用于那些消费者可以跟得上目标消息节奏的这种情况。</p>\n<hr>\n<p><a href=\"http://www.cnblogs.com/kaka/archive/2012/07/24/2606699.html\">http://www.cnblogs.com/kaka/archive/2012/07/24/2606699.html</a>\n<a href=\"http://netcomm.iteye.com/blog/470585\">http://netcomm.iteye.com/blog/470585</a></p>\n","excerpt":105,"source":"_posts/mq4.md","slug":"mq4","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"50":{"id":0,"title":"MQ 笔记之 发送接受实例","date":"2013-08-23T02:27:45.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[8],"tags":[1],"comments":true,"layout":"post","content":"<blockquote>\n<p>mq 支持多种发送格式  BytesMessage  MapMessage ObjectMessage TextMessage StreamMessage等\n<a name=\"more\"></a></p>\n</blockquote>\n<p>本文章以 MapMessage 和 ObjectMessage 为例</p>\n<p><strong>注意 发送ObjectMessage时  接受实例必须相同类名</strong></p>\n<h2>发送实例</h2>\n<p>import org.apache.activemq.ActiveMQConnectionFactory;</p>\n<p>import javax.jms.*;</p>\n<p>public class Send {</p>\n<p> public static void main(String[] args) throws Exception {\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();</p>\n<pre><code><figure class=\"highlight\"><pre>    Connection connection = connectionFactory<span class=\"preprocessor\">.createConnection</span>()<span class=\"comment\">;</span>\n    connection<span class=\"preprocessor\">.start</span>()<span class=\"comment\">;</span>\n\n    Session session = connection<span class=\"preprocessor\">.createSession</span>(Boolean<span class=\"preprocessor\">.TRUE</span>, Session<span class=\"preprocessor\">.AUTO</span>_ACKNOWLEDGE)<span class=\"comment\">;</span>\n    Destination destination = session<span class=\"preprocessor\">.createQueue</span>(<span class=\"string\">\"hf\"</span>)<span class=\"comment\">;</span>\n\n    MessageProducer producer = session<span class=\"preprocessor\">.createProducer</span>(destination)<span class=\"comment\">;</span>\n   for(int i=<span class=\"number\">0</span><span class=\"comment\">; i&lt;3; i++) {</span>\n</pre></figure></code></pre>\n<p>//            MapMessage message = session.createMapMessage();\n//           message.setLong(&quot;count&quot;, new Date().getTime());\n//            message.setObject(&quot;hf&quot;,new SendData());\n      ObjectMessage message = session.createObjectMessage();\n      message.setObject(new SendData());\n//           message.setBytes(&quot;count&quot;, getTestData(1));\n            Thread.sleep(1);\n            //通过消息生产者发出消息\n            producer.send(message);\n        }\n        session.commit();\n        session.close();\n        connection.close();\n    }\n}</p>\n<h2>接收实例</h2>\n<figure class=\"highlight\"><pre>import org<span class=\"preprocessor\">.apache</span><span class=\"preprocessor\">.activemq</span><span class=\"preprocessor\">.ActiveMQConnectionFactory</span><span class=\"comment\">;</span>\n\nimport javax<span class=\"preprocessor\">.jms</span>.*<span class=\"comment\">;</span>\n\npublic class Recive {\n\npublic static void main(String[] args) throws Exception {\n    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory()<span class=\"comment\">;</span>\n\n    Connection connection = connectionFactory<span class=\"preprocessor\">.createConnection</span>()<span class=\"comment\">;</span>\n    connection<span class=\"preprocessor\">.start</span>()<span class=\"comment\">;</span>\n\n    final Session session = connection<span class=\"preprocessor\">.createSession</span>(Boolean<span class=\"preprocessor\">.TRUE</span>, Session<span class=\"preprocessor\">.AUTO</span>_ACKNOWLEDGE)<span class=\"comment\">;</span>\n    Destination destination = session<span class=\"preprocessor\">.createQueue</span>(<span class=\"string\">\"hf\"</span>)<span class=\"comment\">;</span>\n\n    MessageConsumer consumer = session<span class=\"preprocessor\">.createConsumer</span>(destination)<span class=\"comment\">;</span>\n<span class=\"comment\">/*//listener 方式\nconsumer.setMessageListener(new MessageListener() {\n\n    public void onMessage(Message msg) {\n        MapMessage message = (MapMessage) msg;\n        //TODO something....\n        System.out.println(\"收到消息：\" + new Date(message.getLong(\"count\")));\n        session.commit();\n    }\n\n});\nThread.sleep(30000);\n\t*/</span>\n\tint i=<span class=\"number\">0</span><span class=\"comment\">;</span>\n\twhile(i&lt;<span class=\"number\">100</span>) {\n\ti++<span class=\"comment\">;</span>\n\t//            MapMessage message = (MapMessage) consumer<span class=\"preprocessor\">.receive</span>()<span class=\"comment\">;</span>\n\tObjectMessage message = (ObjectMessage) consumer<span class=\"preprocessor\">.receive</span>()<span class=\"comment\">;</span>\n\n\tsession<span class=\"preprocessor\">.commit</span>()<span class=\"comment\">;</span>\n\n\t//TODO something....\n\t//             System<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(<span class=\"string\">\"收到消息：\"</span> + arrayToString(message<span class=\"preprocessor\">.getBytes</span>(<span class=\"string\">\"count\"</span>)))<span class=\"comment\">;</span>\n\n\tSystem<span class=\"preprocessor\">.out</span><span class=\"preprocessor\">.println</span>(<span class=\"string\">\"收到消息：\"</span> + ((SendData) message<span class=\"preprocessor\">.getObject</span>())<span class=\"preprocessor\">.getDateStr</span>())<span class=\"comment\">;</span>\n\t}\n\n\tsession<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n\tconnection<span class=\"preprocessor\">.close</span>()<span class=\"comment\">;</span>\n}\n\n//    public static final String arrayToString(byte[] bytes)\n//    {\n//        StringBuffer buff = new StringBuffer()<span class=\"comment\">;</span>\n//        for (int i = <span class=\"number\">0</span><span class=\"comment\">; i &lt; bytes.length; i++)</span>\n//        {\n//            buff<span class=\"preprocessor\">.append</span>(bytes[i] + <span class=\"string\">\" \"</span>)<span class=\"comment\">;</span>\n//        }\n//        return buff<span class=\"preprocessor\">.toString</span>()<span class=\"comment\">;</span>\n//    }\n}\n</pre></figure>\n\n<h2>传递参数</h2>\n<p>import java.io.Serializable;\nimport java.util.Date;</p>\n<p>/<em>*\n </em> Created with IntelliJ IDEA.\n <em> User: jason\n </em> Date: 13-8-22\n <em> Time: 下午5:21\n </em> To change this template use File | Settings | File Templates.\n */\npublic class SendData  implements Serializable {</p>\n<p>//    private  static  final  long serialVersionUID = -23235245213533L;</p>\n<pre><code><figure class=\"highlight\"><pre><span class=\"keyword\">private</span>  <span class=\"keyword\">byte</span>[] buffer;\n\n<span class=\"keyword\">private</span> String dateStr;\n\n<span class=\"keyword\">public</span> SendData() {\n    setBuffer(<span class=\"keyword\">null</span>);\n    setDateStr(<span class=\"keyword\">null</span>);\n}\n\n<span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] getBuffer() {\n    <span class=\"keyword\">return</span> buffer;\n}\n\n<span class=\"keyword\">public</span> String getDateStr() {\n    <span class=\"keyword\">return</span> dateStr;\n}\n\n<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setDateStr(String dateStr) {\n    <span class=\"keyword\">this</span>.dateStr = String.valueOf(<span class=\"keyword\">new</span> Date().getTime());\n}\n\n<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> setBuffer(<span class=\"keyword\">byte</span>[] buffer) {\n    System.<span class=\"keyword\">out</span>.print(<span class=\"string\">\"begin \\n\"</span>);\n    <span class=\"keyword\">byte</span> [ ] buffers = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>*<span class=\"number\">1</span>];\n    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span> ;  i&lt; buffers.length ;i++)\n        buffers[i] = Byte.parseByte(<span class=\"string\">\"2\"</span>);\n    System.<span class=\"keyword\">out</span>.print(<span class=\"string\">\"end \\n\"</span>);\n    <span class=\"keyword\">this</span>.buffer = buffers;\n}\n</pre></figure></code></pre>\n<p>}</p>\n","excerpt":95,"source":"_posts/mq5.md","slug":"mq5","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"51":{"id":0,"title":"读 林锐博士的项目管理 笔记1","date":"2013-09-09T08:07:57.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[9],"tags":[1],"comments":true,"layout":"post","content":"<h2>软件挣钱难的问题</h2>\n<p><a name=\"more\"></a></p>\n<h3>一、承接合同项目，为甲方开发软件系统。</h3>\n<ol>\n<li><p>市场上能够承接到的合同项目，利润很小。而高利润的项目则被有权势的人或机构掌控。 </p>\n</li>\n<li><p>项目需求和验收受制于客户。开发过程中，客户会不断变更需求，导致开发方不断修改软件，项目验收被不断地延后，开发方成本（包括机会成本）越来越高。</p>\n</li>\n<li><p>缺乏规模复制效益。由于合同项目都是针对特定客户（甲方）的特定需求而签订的，即使做成功了一个合同项目，也很难“复制这个项目”直接卖给下一个客户。</p>\n</li>\n</ol>\n<h3>二、开发并销售通用软件产品</h3>\n<ol>\n<li><p>凡是面向个人的通用软件产品，由于盗版原因，几乎无法靠卖软件来挣钱。</p>\n</li>\n<li><p>只有企业级软件产品不容易被大量盗版，可以走“通用软件产品盈利模式”，难度非常高。开发方必须把自己打造成为“企业级应用的领导者”，否则客户不信任你的方法和产品，产品就无法通用。于是客户提出的个性化需求越来越多，回到了“合同项目盈利模式”。 </p>\n</li>\n</ol>\n<h3>三、运营模式</h3>\n<ol>\n<li><p>互联网公司的业务太容易被模仿，同质化竞争严重。每个领域都死掉了成千上万的相同业务的互联网公司，最终只有少数几家可以活下来，极大地浪费社会财富。</p>\n</li>\n<li><p>互联网公司的另一个大缺点是太浮躁，过分追求快而导致根基不扎实，国内绝大多数互联网公司的软件研发管理，要比传统软件公司混乱得多。</p>\n</li>\n</ol>\n<hr>\n<blockquote>\n<p>软件企业要想多挣钱，靠“开源节流”。“开源”主要靠优化盈利模式，使得现有的技术和资源产生更高的效益。“节流”主要靠改进管理，使企业的所有经营环节更加合理，减少不必要的成本，省下来的钱也就成了利润</p>\n</blockquote>\n","excerpt":21,"source":"_posts/project0.md","slug":"project0","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"52":{"id":0,"title":"svn错误：SVN remains in conflict?","date":"2013-09-03T05:49:56.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[10],"tags":[1],"comments":true,"layout":"post","content":"<p>解决如下:</p>\n<figure class=\"highlight\"><pre><span class=\"comment\">svn</span> <span class=\"comment\">remove</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">force</span> <span class=\"comment\">yourfilename</span>\n<span class=\"comment\">svn</span> <span class=\"comment\">resolve</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">accept=working</span>  <span class=\"comment\">yourfilename</span>\n<span class=\"comment\">svn</span> <span class=\"comment\">commit</span> <span class=\"literal\">-</span><span class=\"comment\">m</span> <span class=\"comment\">\"\"\n</pre></figure>\n\n","excerpt":0,"source":"_posts/svn3.md","slug":"svn3","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"53":{"id":0,"title":"svn 版本恢复命令行操作（转）","date":"2013-09-03T05:51:18.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[10],"tags":[1],"comments":true,"layout":"post","content":"<p>svn没有恢复旧版本的直接功能，不过可以使用svn merge命令恢复。\n比如说当前HEAD为14，而我要恢复成10版本，怎么做？用svn merge：\n<a name=\"more\"></a></p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> update\n<span class=\"title\">svn</span> merge <span class=\"comment\">--revision 14:10</span>\n<span class=\"title\">svn</span> commit -m <span class=\"string\">\"restore to revision 10\"</span>\n</pre></figure>\n\n<p>可能会很奇怪，因为不理解为什么合并能恢复旧版本。</p>\n<p>这里要理解一个关键点，就是svn merge的原理。merge是比较指定版本的差异，然后把这些差异应用到本地工作副本，而-r后的14:10，是指相对于版本14来说版本10的变化（注意，这个版本的次序很重要。），也就是相对版本14，我版本10添加了哪些文件或目录，以及哪些文件添加了哪些行删除了哪些行。</p>\n<p>由于在客户端提交应用程序时的误操作，导致修改了基线版本，此处利用两个命令来进行恢复：</p>\n<ol>\n<li>将客户端恢复合并到指定版本：</li>\n</ol>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> merge -r <span class=\"number\">112</span>:<span class=\"number\">111</span> <span class=\"url\">svn://192.168.0.119/UBoot/trunk/u-boot-1.3.3\n</pre></figure>\n\n<p>此步骤将下位机由112恢复到111版本：</p>\n<ol>\n<li>重新修订基线版本</li>\n</ol>\n<figure class=\"highlight\"><pre>svn <span class=\"operator\"><span class=\"keyword\">commit</span> -m <span class=\"string\">\"Undoing change committed in r111.\"</span>\n</pre></figure>\n\n<p>此步骤将恢复后的111版本提交，但是此时的版本号为113</p>\n","excerpt":80,"source":"_posts/svn4.md","slug":"svn4","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"54":{"id":0,"title":"svn  临时 切换用户 命令","date":"2013-09-03T05:56:11.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[10],"tags":[1],"comments":true,"layout":"post","content":"<p>作为team leader  有时候需要帮别人解决技术问题，尝尝再别人的电脑上改了某些代码，提交的时候遇到了问题，就是怎样临时用自己的账户提交，提交完后 用不影响同事的电脑原有的svn账号\n<a name=\"more\"></a></p>\n<p>下面的可以解决这个问题</p>\n<p>在所有命令下强制加上--username 和--password选项。 </p>\n<p>例如：</p>\n<p>l<figure class=\"highlight\"><pre><span class=\"comment\">svn</span> <span class=\"comment\">ci</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">username</span> <span class=\"comment\">hufeng</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">password</span> <span class=\"comment\">####\n</pre></figure></p>\n","excerpt":98,"source":"_posts/svn5.md","slug":"svn5","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"55":{"id":0,"title":"svn 回退版本","date":"2013-09-03T06:02:35.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[10],"tags":[1],"comments":true,"layout":"post","content":"<figure class=\"highlight\"><pre>svn merge -r <span class=\"symbol\">rHEAD:</span><span class=\"number\">4367</span> <span class=\"symbol\">http:</span>/<span class=\"regexp\">/svnserver/svn</span><span class=\"regexp\">/pingan/client</span><span class=\"regexp\">/iPhone2/trunk</span><span class=\"regexp\">/\n</pre></figure>\n\n<p>本地回退</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> ci -m <span class=\"string\">\"提交\"</span>\n</pre></figure>\n\n","excerpt":0,"source":"_posts/svn6.md","slug":"svn6","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"56":{"id":0,"title":"svn 打 tag","date":"2013-09-03T06:04:29.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[10],"tags":[1],"comments":true,"layout":"post","content":"<figure class=\"highlight\"><pre>svn cp . <span class=\"symbol\">http:</span>/<span class=\"regexp\">/svnserver/svn</span><span class=\"regexp\">/pingan/client</span><span class=\"regexp\">/iPhone2/tags</span><span class=\"regexp\">/appstore_v1.010_rc01  -m \"1.010\"\n</pre></figure>\n\n","excerpt":0,"source":"_posts/svn7.md","slug":"svn7","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"57":{"id":0,"title":"svn错误local add incoming add upon merge","date":"2013-09-03T06:06:15.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[10],"tags":[1],"comments":true,"layout":"post","content":"<p>在svn命令行merge之后文件经常会出现local add, incoming add upon merge问题，导致无法提交，可以通过以下命令解决冲突 \nSummarizing to resolve the tree conflict committing your working dir with svn client 1.6.x you can use: \n<a name=\"more\"></a></p>\n<figure class=\"highlight\"><pre><span class=\"comment\">svn</span> <span class=\"comment\">resolve</span> <span class=\"literal\">-</span><span class=\"literal\">-</span><span class=\"comment\">accept</span> <span class=\"comment\">working</span> <span class=\"literal\">-</span><span class=\"comment\">R</span> <span class=\"string\">.</span>\n</pre></figure>\n\n<p>where . is the directory in conflict.</p>\n","excerpt":187,"source":"_posts/svn8.md","slug":"svn8","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"58":{"id":0,"title":"svn命令总结","date":"2013-09-03T06:08:30.000Z","updated":"2013-09-14T05:57:20.000Z","categories":[10],"tags":[1],"comments":true,"layout":"post","content":"<h2>1. 创建分支</h2>\n<p>svn cp <a href=\"http://svn.trunk/\">http://svn.trunk/</a> <a href=\"http://svn.branches/\">http://svn.branches/</a>  –m “create a branch”\n<a name=\"more\"></a></p>\n<h2>2. 合并分支</h2>\n<h3>1、在某个branch里合并trunk上的修改，</h3>\n<p>进入分支目录，然后执行：</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> merge <span class=\"url\">http://svn/repo/trunk\n</pre></figure>\n\n<h3>2、在trunk上合并branch的修改。</h3>\n<p>进入trunk目录，然后执行</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> merge --reintegrate <span class=\"url\">http://svn/repo/branches/branch1\n</pre></figure>\n\n<h2>3. 将文件checkout到本地目录</h2>\n<p>svn checkout path（path是服务器上的目录）</p>\n<figure class=\"highlight\"><pre>例如：svn checkout svn:<span class=\"regexp\">//</span><span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span><span class=\"regexp\">/pro/</span>domain\n简写：svn co\n</pre></figure>\n\n<h2>4. 往版本库中添加新的文件</h2>\n<p>svn add file</p>\n<figure class=\"highlight\"><pre>例如：svn addtest<span class=\"preprocessor\">.php</span>(添加test<span class=\"preprocessor\">.php</span>)\nsvn <span class=\"keyword\">add</span> *<span class=\"preprocessor\">.php</span>(添加当前目录下所有的php文件)\n</pre></figure>\n\n<h2>5. 将改动的文件提交到版本库</h2>\n<p>svn commit -m “LogMessage“ [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)</p>\n<figure class=\"highlight\"><pre>例如：svn <span class=\"operator\"><span class=\"keyword\">commit</span> -m “<span class=\"keyword\">add</span> test file <span class=\"keyword\">for</span> my test“ test.php\n简写：svn ci\n</pre></figure>\n\n<h2>6. 加锁/解锁</h2>\n<p>svn lock -m “LockMessage“ [--force] PATH</p>\n<figure class=\"highlight\"><pre>例如：svn <span class=\"operator\"><span class=\"keyword\">lock</span> -m “<span class=\"keyword\">lock</span> test file“ test.php\nsvn unlock PATH\n</pre></figure>\n\n<h2>7. 更新到某个版本</h2>\n<p>svn update -r m path</p>\n<p>例如：</p>\n<figure class=\"highlight\"><pre>svn <span class=\"operator\"><span class=\"keyword\">update</span>如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。\nsvn <span class=\"keyword\">update</span> -r <span class=\"number\">200</span> test.php(将版本库中的文件test.php还原到版本<span class=\"number\">200</span>)\nsvn <span class=\"keyword\">update</span> test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先<span class=\"keyword\">update</span>，修改文件，然后清除svn resolved，最后再提交<span class=\"keyword\">commit</span>)\n</pre></figure>\n\n<p>简写：svn up</p>\n<h2>8.查看文件或者目录状态</h2>\n<ol>\n<li>svn status path（目录下的文件和子目录的状态，正常状态不显示）</li>\n</ol>\n<p>【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】</p>\n<ol>\n<li>svn status -v path(显示文件和子目录状态)\n第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。<br><strong>注：</strong> svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。\n简写：svn st</li>\n</ol>\n<h2>9.删除文件</h2>\n<p>svn delete path -m “delete test fle“</p>\n<p>例如：</p>\n<figure class=\"highlight\"><pre>svn <span class=\"operator\"><span class=\"keyword\">delete</span> svn://<span class=\"number\">192.168</span><span class=\"number\">.1</span><span class=\"number\">.1</span>/pro/<span class=\"keyword\">domain</span>/test.php -m “<span class=\"keyword\">delete</span> test file”\n或者直接svn <span class=\"keyword\">delete</span> test.php 然后再svn ci -m ‘<span class=\"keyword\">delete</span> test file‘，\n</pre></figure>\n\n<p>推荐使用这种简写：svn (del, remove, rm)</p>\n<h2>10.查看日志</h2>\n<p>svn log path\n例如：</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> log test.php 显示这个文件的所有修改记录，及其版本号的变化\n</pre></figure>\n\n<h2>11.查看文件详细信息</h2>\n<p>svn info path</p>\n<p>例如：</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> <span class=\"built_in\">info</span> test.php\n</pre></figure>\n\n<h2>12.比较差异</h2>\n<p>svn diff path(将修改的文件与基础版本比较)</p>\n<p>例如：</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> diff test.php\n</pre></figure>\n\n<p>svn diff -r m:n path(对版本m和版本n比较差异)</p>\n<p>例如：</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> diff -r <span class=\"number\">200</span>:<span class=\"number\">201</span> test.php\n</pre></figure>\n\n<p>简写：svn di</p>\n<h2>13.将两个版本之间的差异合并到当前文件</h2>\n<p>svn merge -r m:n path\n例如：</p>\n<figure class=\"highlight\"><pre><span class=\"title\">svn</span> merge -r <span class=\"number\">200</span>:<span class=\"number\">205</span> test.php（将版本<span class=\"number\">200</span>与<span class=\"number\">205</span>之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）\n</pre></figure>\n\n<h2>14.SVN 帮助</h2>\n<p>svn help<br>svn help ci  </p>\n<h2>15.版本库下的文件和目录列表</h2>\n<p>svn list path\n显示path目录下的所有属于版本库的文件和目录<br>简写：svn ls</p>\n<h2>16.创建纳入版本控制下的新目录</h2>\n<p>svn mkdir: 创建纳入版本控制下的新目录。</p>\n<p>用法: </p>\n<ol>\n<li>mkdir PATH…</li>\n<li>mkdir URL…</li>\n</ol>\n<p>创建版本控制的目录。</p>\n<ol>\n<li>每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。</li>\n<li>每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。</li>\n</ol>\n<h2>17.恢复本地修改</h2>\n<p>svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:<br>用法: revert PATH…<br>注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录</p>\n<h2>18.代码库URL变更</h2>\n<p>svn switch (sw): 更新工作副本至不同的URL。</p>\n<p>用法: </p>\n<ol>\n<li>switch URL [PATH]</li>\n<li><p>switch –relocate FROM TO [PATH...]</p>\n<ul>\n<li><p>更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。</p>\n</li>\n<li><p>改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2>19.解决冲突</h2>\n<p>svn resolved: 移除工作副本的目录或文件的“冲突”状态。 </p>\n<p>用法: resolved PATH…</p>\n<p><strong>注意:</strong> 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的\n相关文件，然后让 PATH 可以再次提交。</p>\n<h2>20.输出指定文件或URL的内容。</h2>\n<p>svn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。  </p>\n<p>svn cat -r PREV filename &gt; filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)</p>\n","excerpt":155,"source":"_posts/svn9.md","slug":"svn9","ctime":"2013-09-14T05:57:20.000Z","mtime":"2013-09-14T05:57:20.000Z"},"59":{"id":0,"title":"散文","date":"2013-08-08T02:29:16.000Z","updated":"2013-09-09T13:41:58.000Z","categories":[],"tags":[2],"comments":true,"layout":"post","content":"<h2>浮华过后，心若沉浮浅笑安然</h2>\n<p>生活或许是一件艺术品，需懂得欣赏，意中细品，学会经受。<a name=\"more\"></a>人生似一场追梦，那就是无数个美丽的梦而创造。人生常在繁华中等待，只不过每个人都在等待一个自己想要的未来。人生的迁徙，沉重着你的步履，有些感怀让你沉浸。曾让你迷失了方向，繁华落幕后，空山流水静其身，花开似无情，花落去留意，放眼望去，世间的喜悲离合聚散相依，匆匆如尘埃里的一颗沙粒，生命的深度，靠心去我体悟，生命的宽度，需魅力去赞颂。</p>\n<p>浮华沉寂陌生的城市，穿越年华的酸楚，风停了，雨骤了，心倦了，等待与思念的相互侵蚀，生命的前行，梦的边缘，思绪舞动一隅的嗔怨。行走的日光倾城，常伴有风的抚慰，雨的湿浸，山水的同路，莲的独隅，红尘碾转，自断不了纷争，待过忘川时，不过淡似轻风，花开催人老，纵马须恣意，清浅仲夏煮一壶清茶，待坐而品茗，静看花开花落，笑看云卷亦舒。</p>\n<p>今夕何夕，尘缘路上的回眸一笑，注定了浅笑安然。流年似水，生命的时光中，因为有缘相识，荒草丛生的原野上，没有早一步，晚一步，这就是缘。夏雨微凉，一袭雨过，岁月氤氲了一帘幽梦，芬芳轻盈着一执而念的光阴，生活缱绻起了风景，流年浮华过后，&quot;此情可待成追忆，只是当时已惘然&quot;.</p>\n<p>心最柔软的地方，穿过了心刺的屏障，曾为一朵玫瑰而绽放，蜿蜒寂寞的藤，月光隐约着浪漫的惆怅，穿越横亘的流浪，时间煮雨，回忆终究会让年华淡泊，活着也许是一种修行，时光静好，品一茗清茶，落花无言，人淡如菊，润一份心境，携一缕阳光，让芳华依旧绽放。字里行间的缠绵，泪痕迭起了四季的轮回，愿得一个人，白守不分离，铺满诗意的路径，夜如此静谧，带伤的诗句常娇嗔着粉饰，步伐太急，却忘了缓缓停下来让心安祥。</p>\n<p>山与水的缠绵，任流音乐的浮想，清寂时常敲碎夜的散漫，凄迷的烟雨里，水滴的顺势而滑，水声伴风雨的飘渺芳飞，无垠的夜空，静静的聆听，繁琐打搅，细密的疏雨，意境的恰入，飘散的雨滴，透过肌肤直抵心深处，奈何雨的朦胧，相思成林泪千行。无情的冷风常拔弄着心弦，溅湿的思愁，陌路的不在相见，这个季，风儿依柔，雨儿心醉，满目的寒殇，素色时光的轻狂，喧哗背后的沉静，简单的真谛，心若沉浮，此事不关山与月。</p>\n<p>浮华掠影后，静静的听雨，感风的倾诉，世界太喧闹，已至于背离了自己，沉静中的超脱，不常泛滥，无意的碰触，深知心里的冬天时常接伴，甚至盛夏炎炎，那份落韵的雪，也会勾画着伤感的景致。卑微轻触着虚无，平淡晕染着凄冷。如若没有那么多牵扯，也不会有那么多眷念，不用去刻意与深究，这个世界本就复杂，盼一份温暖，守一份静染，只愿在高山流水间吟诵，世间最难识是情，最难诉的是痴。</p>\n<p>生命总有尽头，心灵总需要出口，每个人身上都有一把锁，有人说寂寞是种狂欢，但真正的寂寞是无法用热闹来填埋，只有你为心灵找到了决口，上锁的心慢慢绽放，才能真正的释怀，人之所以挣扎与纠结，是把钥匙丢了，但希望总在远方起航心若沉浮，浅笑安然。</p>\n<!-- ![](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg)-->\n<!-- <img src=\"http://placekitten.com/890/280\">\n-->\n<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" class=\"right\" width=\"300\" height=\"400\" title=\"壮壮\">\n\n<!-- <img src=\"http://placekitten.com/300/500\" class=\"right\" width=\"150\" height=\"250\" title=\"Place Kitten #3\">\n\n<img src=\"http://placekitten.com/300/500\" class=\"right\" width=\"150\" height=\"250\" title=\"Place Kitten #4\" alt=\"An image of a very cute kitten\">\n -->","excerpt":53,"source":"_posts/散文.md","slug":"散文","ctime":"2013-09-09T13:41:58.000Z","mtime":"2013-09-09T13:41:58.000Z"},"_primary":60},"pages":{"1":{"title":"New Page","date":"2013-08-04T10:24:33.000Z","updated":"2013-08-29T13:47:50.000Z","comments":true,"layout":"page","content":"<p>title: New Page</p>\n<h2>date: 2013-08-04 18:24:33</h2>\n","excerpt":0,"source":"new-page/index.md","path":"new-page/index.html","ctime":"2013-08-29T13:47:50.000Z","mtime":"2013-08-29T13:47:50.000Z"},"_primary":2},"categories":{"1":{"name":"ios","slug":"ios","posts":[1,2,4,19,20,22,23,24,26,27,25,30,28,31,32,29,33,34,35,36,37,38,41,43,40]},"2":{"name":"git","slug":"git","posts":[3,5,6,7,11,12,13,14,15,8,42,9,10]},"3":{"name":"svn","slug":"git/svn","posts":[7,15,42]},"4":{"name":"hibernate","slug":"hibernate","posts":[16,18]},"5":{"name":"hexo","slug":"hexo","posts":[17,21,39,45]},"6":{"name":"mac","slug":"ios/mac","posts":[19,30,33,41,43]},"7":{"name":"情感","slug":"情感","posts":[44]},"8":{"name":"MQ","slug":"MQ","posts":[46,47,49,50,48]},"9":{"name":"项目管理","slug":"项目管理","posts":[51]},"10":{"name":"svn","slug":"svn","posts":[52,53,54,55,56,57,58]},"_primary":11},"tags":{"1":{"name":"技术","slug":"技术","posts":[1,2,3,4,5,6,7,11,12,13,14,15,8,16,17,18,19,20,21,22,23,24,26,27,25,30,28,31,32,29,33,34,35,36,37,38,39,42,41,43,45,40,46,47,49,51,52,53,54,55,56,57,58,50,48,9,10]},"2":{"name":"情感","slug":"情感","posts":[44,59]},"_primary":3},"assets":{"1":{"source":"source/favicon.ico","mtime":"2013-08-06T12:58:43.000Z"},"2":{"source":"themes/bootstrap/source/Jianli.htm","mtime":"2013-09-14T05:57:20.000Z"},"3":{"source":"themes/bootstrap/source/search.html","mtime":"2013-09-09T13:41:58.000Z"},"4":{"source":"themes/bootstrap/source/css/bootstrap-responsive.css","mtime":"2013-08-06T12:58:43.000Z"},"5":{"source":"themes/bootstrap/source/css/bootstrap-responsive.min.css","mtime":"2013-08-06T12:58:43.000Z"},"6":{"source":"themes/bootstrap/source/css/bootstrap.css","mtime":"2013-09-09T15:15:14.000Z"},"7":{"source":"themes/bootstrap/source/css/bootstrap.min.css","mtime":"2013-09-09T15:46:19.000Z"},"8":{"source":"themes/bootstrap/source/css/hexobootstrapcss.css","mtime":"2013-09-09T15:09:49.000Z"},"9":{"source":"themes/bootstrap/source/css/hf.css","mtime":"2013-09-09T15:46:18.000Z"},"10":{"source":"themes/bootstrap/source/css/tab.css","mtime":"2013-09-09T13:41:58.000Z"},"11":{"source":"themes/bootstrap/source/css/xcode.css","mtime":"2013-09-09T14:47:15.000Z"},"12":{"source":"themes/bootstrap/source/js/bootstrap.js","mtime":"2013-08-06T12:58:43.000Z"},"13":{"source":"themes/bootstrap/source/js/bootstrap.min.js","mtime":"2013-08-06T12:58:43.000Z"},"14":{"source":"themes/bootstrap/source/js/gotop.js","mtime":"2013-08-06T15:21:00.000Z"},"15":{"source":"themes/bootstrap/source/js/jquery-tapir.js","mtime":"2013-09-09T13:41:58.000Z"},"16":{"source":"themes/bootstrap/source/js/jquery-1.8.3.min.js","mtime":"2013-08-06T12:58:43.000Z"},"17":{"source":"themes/bootstrap/source/js/jquery.easing.min.js","mtime":"2013-09-09T13:41:58.000Z"},"18":{"source":"themes/bootstrap/source/js/jquery.imagesloaded.min.js","mtime":"2013-09-09T13:41:58.000Z"},"19":{"source":"themes/bootstrap/source/js/jquery.js","mtime":"2013-08-06T12:58:43.000Z"},"20":{"source":"themes/bootstrap/source/js/jquery.menuindex.js","mtime":"2013-08-29T13:47:50.000Z"},"21":{"source":"themes/bootstrap/source/js/jquery.pagination.js","mtime":"2013-08-06T12:58:43.000Z"},"22":{"source":"themes/bootstrap/source/js/jquery.scrollUp.js","mtime":"2013-09-09T13:41:58.000Z"},"23":{"source":"themes/bootstrap/source/js/jquery.scrollUp.min.js","mtime":"2013-09-09T13:41:58.000Z"},"24":{"source":"themes/bootstrap/source/img/glyphicons-halflings-white.png","mtime":"2013-08-06T12:58:43.000Z"},"25":{"source":"themes/bootstrap/source/img/glyphicons-halflings.png","mtime":"2013-08-06T12:58:43.000Z"},"26":{"source":"themes/bootstrap/source/img/hufeng825.jpg","mtime":"2013-08-06T12:58:43.000Z"},"27":{"source":"themes/bootstrap/source/img/loading.gif","mtime":"2013-09-09T13:41:58.000Z"},"28":{"source":"themes/bootstrap/source/img/patterns/mooning.png","mtime":"2013-08-06T12:58:43.000Z"},"29":{"source":"themes/bootstrap/source/img/patterns/white_wall_hash.png","mtime":"2013-09-09T13:41:58.000Z"},"_primary":30}}