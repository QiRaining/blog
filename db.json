{"Asset":{"6fg93ng7p528m9k6":{"_id":"6fg93ng7p528m9k6","source":"source/favicon.ico","mtime":1377913082000},"2sw64o0fdlvbz8ei":{"_id":"2sw64o0fdlvbz8ei","source":"themes/bootstrap/source/Jianli.htm","mtime":1379391691000},"rnf9xbm3a891eg4b":{"_id":"rnf9xbm3a891eg4b","source":"themes/bootstrap/source/search.html","mtime":1378826228000},"3b6tug17d5oyuaqk":{"_id":"3b6tug17d5oyuaqk","source":"themes/bootstrap/source/css/bootstrap-responsive.css","mtime":1377913082000},"9bu1llonqwk4w4ms":{"_id":"9bu1llonqwk4w4ms","source":"themes/bootstrap/source/css/bootstrap-responsive.min.css","mtime":1377913082000},"fhoa4ib404738kla":{"_id":"fhoa4ib404738kla","source":"themes/bootstrap/source/css/bootstrap.css","mtime":1377913082000},"ro9ih8uv9kcqoiyj":{"_id":"ro9ih8uv9kcqoiyj","source":"themes/bootstrap/source/css/bootstrap.min.css","mtime":1377913082000},"whh5qxkpalhrvt6i":{"_id":"whh5qxkpalhrvt6i","source":"themes/bootstrap/source/css/hexobootstrapcss.css","mtime":1378826228000},"oq6p2hw31mdldyse":{"_id":"oq6p2hw31mdldyse","source":"themes/bootstrap/source/css/hf.css","mtime":1381426909000},"37c74ny4ltrskfe8":{"_id":"37c74ny4ltrskfe8","source":"themes/bootstrap/source/css/tab.css","mtime":1377913082000},"ipd2ha5elckz7klu":{"_id":"ipd2ha5elckz7klu","source":"themes/bootstrap/source/css/xcode.css","mtime":1378826228000},"n1kmam7kp2rb1obs":{"_id":"n1kmam7kp2rb1obs","source":"themes/bootstrap/source/js/bootstrap.js","mtime":1377913082000},"wqrtww3skvtdhz5v":{"_id":"wqrtww3skvtdhz5v","source":"themes/bootstrap/source/js/bootstrap.min.js","mtime":1377913082000},"fawn37v5cu1m9n3t":{"_id":"fawn37v5cu1m9n3t","source":"themes/bootstrap/source/js/gotop.js","mtime":1378826228000},"de6m2726tng2jpjr":{"_id":"de6m2726tng2jpjr","source":"themes/bootstrap/source/js/jquery-1.8.3.min.js","mtime":1377913082000},"6dbhudanboqrt4dh":{"_id":"6dbhudanboqrt4dh","source":"themes/bootstrap/source/js/jquery-tapir.js","mtime":1378133853000},"di0lfiwer6xp9n3x":{"_id":"di0lfiwer6xp9n3x","source":"themes/bootstrap/source/js/jquery.easing.min.js","mtime":1377913082000},"pl6iallluoqyxqzx":{"_id":"pl6iallluoqyxqzx","source":"themes/bootstrap/source/js/jquery.imagesloaded.min.js","mtime":1377913082000},"jj71dy58r3s7ruil":{"_id":"jj71dy58r3s7ruil","source":"themes/bootstrap/source/js/jquery.js","mtime":1377913082000},"kj6sn3alelcenhje":{"_id":"kj6sn3alelcenhje","source":"themes/bootstrap/source/js/jquery.menuindex.js","mtime":1377913082000},"t7qr80zwbyqjkf4c":{"_id":"t7qr80zwbyqjkf4c","source":"themes/bootstrap/source/js/jquery.pagination.js","mtime":1377913082000},"qi0huntlm14tk6ah":{"_id":"qi0huntlm14tk6ah","source":"themes/bootstrap/source/js/jquery.scrollUp.js","mtime":1377913082000},"55so5yn4wp4ff555":{"_id":"55so5yn4wp4ff555","source":"themes/bootstrap/source/js/jquery.scrollUp.min.js","mtime":1377913082000},"re4ik8xbxaiam2pg":{"_id":"re4ik8xbxaiam2pg","source":"themes/bootstrap/source/img/glyphicons-halflings-white.png","mtime":1377913082000},"wtgfiidemmxu21cc":{"_id":"wtgfiidemmxu21cc","source":"themes/bootstrap/source/img/glyphicons-halflings.png","mtime":1377913082000},"mrqxyof8znjm90b8":{"_id":"mrqxyof8znjm90b8","source":"themes/bootstrap/source/img/hufeng825.jpg","mtime":1377913082000},"9h1bufs9qajym346":{"_id":"9h1bufs9qajym346","source":"themes/bootstrap/source/img/loading.gif","mtime":1378131266000},"t9fr7ju7knro6dvw":{"_id":"t9fr7ju7knro6dvw","source":"themes/bootstrap/source/img/patterns/mooning.png","mtime":1377913082000},"zo8jljy7rekcaa33":{"_id":"zo8jljy7rekcaa33","source":"themes/bootstrap/source/img/patterns/white_wall_hash.png","mtime":1377914544000}},"Cache":{"dwrk0rsijcruazwa":{"_id":"dwrk0rsijcruazwa","content":"title: How to get the color of a pixel in an UIView?\ndate: 2013-09-03 16:33:35\ntags: [技术]\ncategories: ios\n---\n记得一年前做招行掌上生活M+的时候 其中有个需求是画一画功能，就是在地图上用手指画个圈 然后得到这个圈里面所有指定商户。\n当时为了精度 除了利用 \n\n```\nBOOL mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView.path, NULL, polygonViewPoint, NO);\n```\n来验证此点是否在画的区域内 同时为了精度 还用到了点位的颜色色值进行校验。\n\n无法把全部代码给出 下面把 如何得到uiview 某点的函数给出\n\n UIView+ColorOfPoint.h\n\n```\n@interface UIView (ColorOfPoint)\n- (UIColor *) colorOfPoint:(CGPoint)point;\n@end\n```\n\n UIView+ColorOfPoint.m\n\n```\n#import \"UIView+ColorOfPoint.h\"\n#import <QuartzCore/QuartzCore.h>\n\n@implementation UIView (ColorOfPoint)\n\n- (UIColor *) colorOfPoint:(CGPoint)point\n{\n    unsigned char pixel[4] = {0};\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    CGContextRef context = CGBitmapContextCreate(pixel, 1, 1, 8, 4, colorSpace, kCGImageAlphaPremultipliedLast);\n\n    CGContextTranslateCTM(context, -point.x, -point.y);\n\n    [self.layer renderInContext:context];\n\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n\n    //NSLog(@\"pixel: %d %d %d %d\", pixel[0], pixel[1], pixel[2], pixel[3]);\n\n    UIColor *color = [UIColor colorWithRed:pixel[0]/255.0 green:pixel[1]/255.0 blue:pixel[2]/255.0 alpha:pixel[3]/255.0];\n\n    return color;\n}\n```\n@end\n\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg 300 600 模拟器%}\n","mtime":1379221447000,"source":"_posts/22.md"},"2x8b36weksbdqcgb":{"_id":"2x8b36weksbdqcgb","content":"title: git系类教程之 找出最懒的程序员\ndate: 2013-09-03 11:19:34\ntags: [技术]\ncategories: git\n---\n\n>场景假设:⼀一个开发⼩小组有10个程序员,他们⽤用 Git 做版本控制,某⼀一天程序员A push了当天的⼏几个 commit之后,突然在想“我在这个项⺫⽬目到底⼀一共进⾏行过多少次commit?谁⽐比我commit更多?多多少?谁是 组⾥里⾯面进⾏行最多commit的?谁是最少的?”\n<!-- more -->\n\nGit ⾮非常⼈人性化地⽀支持这样⼀一个命令:$ git shortlog\n这个命令会返回这个 git repository 底下每个⽤用户进⾏行 commit 的次数,以及每次 commit 的注释。 -s 参数省略每次 commit 的注释,仅仅返回⼀一个简单的统计。\n-n 参数按照 commit 数量从多到少的顺利对⽤用户进⾏行排序\n\n```\n$ git shortlog -s -n\n  135  Tom Preston-Werner\n  6  remi\n  3  Mikael Lind\n  3  Toby DiPasquale\n  2  Aristotle Pagaltzis\n  2  Basil Shkara\n  1  Marc Chung\n  1  Nick Gerakines\n\n ```","mtime":1379221447000,"source":"_posts/git10.md"},"4a6daremxusjyicw":{"_id":"4a6daremxusjyicw","content":"title: 判断地图坐标是否在区域内\ndate: 2013-09-03 16:51:48\ntags: [技术]\ncategories: ios\n\n---\n\n>此方法与前一篇文章中的得到UIView某点的色值达到的效果一直，通常为了保持精度 两个方法一起使用。\n  \n<!-- more -->\n```\n-(IBAction)foundTap:(UITapGestureRecognizer *)recognizer\n{\n    CGPoint point = [recognizer locationInView:self.mapView];\n\n    CLLocationCoordinate2D tapPoint = [self.mapView convertPoint:point toCoordinateFromView:self.view];\n\n    [self pointInsideOverlay:tapPoint];\n\n    if (isInside) \n     {\n       ....\n     }\n}\n```\nHere is a method to call from the previous to check if the point is inside the overlay:\n```\n-(void)pointInsideOverlay:(CLLocationCoordinate2D )tapPoint \n{\n    isInside = FALSE; \n\n    MKPolygonView *polygonView = (MKPolygonView *)[mapView viewForOverlay:polygonOverlay];\n\n    MKMapPoint mapPoint = MKMapPointForCoordinate(tapPoint);\n\n    CGPoint polygonViewPoint = [polygonView pointForMapPoint:mapPoint];\n\n    BOOL mapCoordinateIsInPolygon = CGPathContainsPoint(polygonView.path, NULL, polygonViewPoint, NO);\n\n        if ( !mapCoordinateIsInPolygon )\n\n            //we are finding points that are inside the overlay\n        {\n            isInside = TRUE;\n        }\n}\n```\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e89eyhiwqbj20hs0qo769.jpg 300 600 %}\n","mtime":1379221447000,"source":"_posts/23.md"},"0j3p4gtpjeli4nin":{"_id":"0j3p4gtpjeli4nin","content":"title: git错误 fatal: remote origin already exists.\ndate: 2013-09-03 13:37:59\ntags: [技术]\ncategories: git\n---\n\n> 当执行 git remote addorigin git@github.com:hufeng825/test.git\n\n错误提示：fatal: remote origin already exists.\n<!-- more -->\n解决办法\n\n```\n$ git remote rm origin\n\n```","mtime":1379221447000,"source":"_posts/git11.md"},"d27u262a9xwqhygu":{"_id":"d27u262a9xwqhygu","content":"title: git 系类教程之 log显示\ndate: 2013-09-02 17:59:59\ntags: [技术]\ncategories: git\n---\n查看log是程序员常用的操作之一,不要以为一个git log了事,下面介绍下git log 的高级操作.\n<!-- more -->\n\n1. 显示所有提交记录的包括提交时间 提交人员联系方式等等: git log\n\n2. 显示所有提交记录 只显示提交信息: git shortlog\n\n3. 显⽰示版本历史,以及版本间的内容差异:git log -p\n\n4. 只显⽰示最近⼀一次提交:git log -1\n\n5. 显⽰示最近的20个提交:以及版本间的内容差异:git log -20 -p\n\n6. 显⽰示最近6⼩小时的提交:git log --since=\"6 hours\"\n\n7. 显⽰示两天之前的提交:git log --before=\"2 days\" ","mtime":1378826228000,"source":"_posts/git2.md"},"na2hen58x9ks1ec8":{"_id":"na2hen58x9ks1ec8","content":"title: git错误 git rebase master First, rewinding head to replay your work on top of it... error: The following unt\ndate: 2013-09-03 13:39:50\ntags: [技术]\ncategories: git\n---\n\ngit rebase master\nFirst, rewinding head to replay your work on top of it...\nerror: The following untracked working tree files would be overwritten by checkout:\n<!-- more -->\nHFFrame.xcodeproj/project.xcworkspace/xcuserdata/apple.xcuserdatad/UserInterfaceState.xcuserstate\nPlease move or remove them before you can switch branches.\nAborting\ncould not detach HEAD\n\n执行\n```\n~/Desktop/HFFrame(example) $ git clean -d -fx \"\"\n\n```\n","mtime":1379221447000,"source":"_posts/git12.md"},"13elxxrx8wmd5332":{"_id":"13elxxrx8wmd5332","content":"title: mac 开发 git svn 应该添加那些忽略列表\ndate: 2013-09-03 13:45:11\ntags: [技术]\ncategories: \n- git\n- svn\n---\n>如题，git svn 应该添加那些忽略列表?\n<!-- more -->\n\n1. .DS_Store\n2. build\n3. *~.nib\n4. *.so\n5. *.pbxuser\n6. *.mode\n7. *.perspective*\n","mtime":1379221447000,"source":"_posts/git13.md"},"ffut3skc5r2kd9p5":{"_id":"ffut3skc5r2kd9p5","content":"title: git 系类教程之 懂的这些配置能让git 更好用\ndate: 2013-09-02 18:16:59\ntags: [技术]\ncategories: git\n---\n\n是不是抱怨git操作太过于复杂,是不是想要让log 更加漂亮 是不是想要让git 跟svn 一样支持st ci 等等这样的缩写命令……\n<!-- more -->\n下面的这些配置能够满足你.\n\n打开终端 执行\n```\ncd\nvi .git/.gitconfig\n```\n然后修改gitconfig\n```\n[alias]\n  logs = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n  st = status\n  ci = commit\n  br = branch\n  co = checkout\n  df = diff\n  lg = log -p\n```\n\n如果想要把 rebase 當做 git pull 的預設值，可以在專在 .gitconfig 加上\n```\n\n[branch \"master\"]\n  remote = origin\n  merge = refs/heads/master\n  rebase = true\n```\n\n也可以直接加到 ~/.gitconfig 讓所有的 tracked branches 都自動套用這個設定：\n```\n[branch]  \n\tautosetuprebase = always\n```\n\n\n\n\n","mtime":1378826228000,"source":"_posts/git4.md"},"y60mcfb64sc9m0lw":{"_id":"y60mcfb64sc9m0lw","content":"title: git系列教程之 修改远程仓库地址 modify remote url\ndate: 2013-09-03 09:50:37\ntags: [技术]\ncategories: git\n---\n某天突然IT部门告之服务器要换地址了，本地有clone出来的git厍，则需要修改一下origin的地址，以便能继续push和pull，方法是，在命令行项目所在目录下执行：\n<!-- more -->\n\tgit remote set-url origin 新地址\n\n","mtime":1379221447000,"source":"_posts/git5.md"},"xmi8msiopgu1jatx":{"_id":"xmi8msiopgu1jatx","content":"title: git系类教程之 获取指定分支指定文件的更新\ndate: 2013-09-03 10:03:50\ntags: [技术]\ncategories: git\n---\n多分支并行时，主干A 想要获取某分支上的某个文件的更新，但是并不像merge 这个分支，如图\n\n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1e89338drs8j20ib0g4abh.jpg 150 200 %}\n<!-- more -->\n\n```\ngit checkout 指定分支 指定文件\n\ngit checkout breanchA HFFrame/Global/Global_macro.h\n```","mtime":1379221447000,"source":"_posts/git6.md"},"1aglxlwx2efxj9xs":{"_id":"1aglxlwx2efxj9xs","content":"title: git 系列教程之 提交信息的后悔药 修改提交信息\ndate: 2013-09-02 18:06:42\ntags: [技术]\ncategories: git\n---\n有没有提交过\"修改bug\" \"上传代码\" 等等类似脑残的提交信息. code review 时看到这样的提交信息 每个team leader 肯定不会容忍的. 下面要介绍的是如何修改之前提交的历史信息\n<!-- more -->\n\n##方法一 可以修改最后一次 commit\n\t git commit --amend \n----\n\n##方法二 交互式修改\n\n###步骤一\n   \n\tgit rebase -i master~1 //最\n\tgit rebase -i master~5 //最后五次\n\n###步骤二\n // 显示结果如下，修改 pick 为 edit ，并 :wq 保存退出\n\t pick 91b495b 2012-01-08: \"提交信息内容\"\n\n\t# Rebase 9ef2b1f..91b495b onto 9ef2b1f\n\t#\n\t# Commands:\n\t#  pick = use commit\n\t#  edit = use commit, but stop for amending //改上面的 pick 为 edit\n\t#  squash = use commit, but meld into previous commit\n\t#\n\t# If you remove a line here THAT COMMIT WILL BE LOST.\n\t# However, if you remove everything, the rebase will be aborted.\n\t#\n\n###步骤三\n 使用\n\n\tgit rebase --continue //完成操作\n","mtime":1378826228000,"source":"_posts/git3.md"},"t8nx1mrfjhcq3tt8":{"_id":"t8nx1mrfjhcq3tt8","content":"title: git系类教程之 指定公钥\ndate: 2013-09-03 10:13:04\ntags: [技术]\ncategories: git\n---\n\n如果本地有多个公钥 如何对git 进行指定用哪个公钥呢？\n<!-- more -->\n\n```\nvi .git/config \n\n\n[core]\n\n       repositoryformatversion = 0\n\n       filemode = true\n\n       bare = false\n\n       logallrefupdates = true\n\n       ignorecase = true\n\n[remote \"origin\"]\n\n       fetch = +refs/heads/*:refs/remotes/origin/*\n\n       url = ssh://dev@nav.fun-guide.mobi:6521/home/dev/git/cmb.git\n\n[branch \"master\"]\n\n       remote = origin\n\n       merge = refs/heads/master\n\n[branch \"cmb-dingcan\"]\n\n       remote = origin\n\n       merge = refs/heads/cmb-dingcan\n\n~                                                                               \n\n\n\nHost git.magus-soft.com\n\nHostName git.magus-soft.com\n\nPort 6521\n\nUser git\n\nIdentityFile ~/.ssh/iphone_git\n\n~                                                                                 \n\n\n\n／.ssh/config\n\n```","mtime":1379221447000,"source":"_posts/git7.md"},"molyit66qpnssd05":{"_id":"molyit66qpnssd05","content":"title: git与SVN协同的工作流程\ndate: 2013-09-03 11:00:12\ntags: [技术]\ncategories: [git, svn]\n---\n\ngit可以和SVN服务器一起使用，即，中央服务器采用svn，本地代码库使用git。这样的好处是，可以兼容以前的项目，同时本地有一套完整的版本控制系统，可以随时查看代码修改历史，随时提交，不需要网络。合适的时候再提交到SVN服务器。git-svn的工作流程也有很多，我们推荐使用下面这种方式。\n\n<!-- more-->\n\n\n##一.git-svn初始化\n\n```\ngit svn init SVNREMOTEURL\n\n```\n-s 参数是表面使用的是svn标准命名方法,即 trunk,tags,branches,这个参数有时很重要,建议使用,命 令后面还可以加个文件夹名字作为clone后的目录\n\n```\ngit svn fetch\n\n```\n可能碰到只想从某个版本开始进行fetch,那么请需要 –r 参数。 例如:\n\n```\n$ git svn fetch -r 1342:HEAD\n\n$ git remote add origin GITREMOTEURL 初始化远程git 地址 \n\n这⼀一步可以省略 如果没必要提交到远程git 服务器中\n\n```\n\n##二.git-svn基本⽤用法\n\n###本地修改代码后提交 \n\n```\ngit commit -a -m “”\n\n```\n###同步远程svn 服务器 \n\n```\ngit svn rebase \n\n```\n###推送到远程svn服务器 \n\n```\ngit svn dcommit \n\n```\n###推送到远程git 服务器 \n\n```\ngit push\n\n```\n\n###从SVN服务器获取代码\n\n```\n$ git svn clone http://svnserver/project/trunk\n\n```\n### 创建一个本地分支\n\n```\n为了方便合并，减少不必要的麻烦，最好保持主分支master不变，在一个新的分支进行日常工作\n\ngit branch workA\n\n```\n###日常修改和提交\n\n\n与git的工作流程完全一样\n\n```\n$ git checkout -b work\n$ git commit -a\n\n```\n###切回master从SVN获取最新代码\n\n```\n$ git checkout master\n$ git svn rebase\n\n```\n\n###master同步后，与工作分支合并\n\n```\n$ git checkout work\n$ git rebase master     ## 手工解决可能的冲突\n\n```\n\n###合并主分支\n\n```\n$ git checkout master $ git merge work\n\n```\n\n###git-svn 解决冲突 \n\n* ⼿动打开冲突的⽂文件 找到冲突的地⽅方修改完成后保存\n\n* 执⾏行 git add 冲突⽂文件\n\n* git rebase --continue \n\n* git svn dcommit","mtime":1379221447000,"source":"_posts/git9.md"},"dgbnaphg0jemufda":{"_id":"dgbnaphg0jemufda","content":"title: hexo教程1 如何安装hexo\ndate: 2013-08-08 14:21:33\ntags: [技术]\ncategories: [hexo]\n---\n<!--more-->\n##前言\n>很早之前就想自己搭建一个博客，但是无奈已没有时间 而没有银子购买服务器，把家里的mac 当做服务器搭建wordpress但是不能保证速度和访问时间。偶然间发现了octopress,于是兴冲冲的折腾起来，最后搭建成功了，废了很大的经历，最主要的原因是还是网络原因，octopress 安装需要下载大量的安装依赖非常繁琐，到处是坑。后来偶然间发现了hexo，发现要比octopress 好用的太多了。于是果断废弃octopress 转头hexo\n\n***\n\n##概念理解\nhexo 是基于node.js 的 和rails 差不多。再次使用前 需要安装两个插件\n\n *   nvm （版本控制）\n     nodejs version manager,可以把它理解为 rails里面的rvm  \n *   npm （包管理机制 ）\n \t nodejs package manager,可以把它理解为 rails 里面的bundle \n     \n- - -\n###安装步骤(mac)\n>只针对于mac 其他的请到官网查看相应平台的安装方法http://zespia.tw/hexo \n\n***\n#### npm\n***\n打开终端 执行一下命令\n\n```\ngit clone git://github.com/creationix/nvm.git ~/nvm\n```\n安装完毕后，在~/.bash_profile或~/.bashrc加入以下内容\n\n```\n. ~/nvm/nvm.sh`\n```\n执行\n\n```\nsource .bash_profile //或者 source .bashrc\n```\n之后即可使用 nvm 来安装 Node.js\n\n```\n   nvm install v0.8.14\n   nvm use v0.8.14\n   nvm alias default v0.8.14 \n```\n***\n#### hexo\n安装\n\n```\nnpm install -g hexo\n```\n更新\n\n```\nnpm update -g \n```\n***\n\n###设定\n\n编辑 _config.yml\n\n下面贴出我的配置 大家自行根据各自的配置进行相应修改\n\n\n\t// Site\n\ttitle: 阿峰的技术窝窝\n\tsubtitle: 专注于移动互联网\n\tdescription: C/C++/Linux/嵌入式/IOS/WEB/\n\tauthor: Jason Hu\n\temail: hufeng@hufengvip.cn\n\tlanguage: zh-CN\n\n\t// URL\n\t// If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\n\turl: http://hufeng825.github.com\n\troot: /\n\tpermalink: :year/:month/:day/:title/\n\ttag_dir: tags\n\tarchive_dir: archives\n\tcategory_dir: categories\n\tcode_dir: downloads/code\n\n\t// Writing\n\tnew_post_name: :title.md # File name of new posts\n\tdefault_layout: post\n\tauto_spacing: false # Add spaces between asian characters and western characters\n\ttitlecase: false # Transform title into titlecase\n\tmax_open_file: 100\n\tfilename_case: 0\n\thighlight:\n\t  enable: true\n\t  line_number: true\n\t  tab_replace:\n\n\t// Category & Tag\n\tdefault_category: IOS\n\tcategory_map:\n\ttag_map:\n\n\t// Archives\n\t// 2: Enable pagination\n\t// 1: Disable pagination\n\t// 0: Fully Disable\n\tarchive: 2\n\tcategory: 2\n\ttag: 2\n\n\t// Server\n\t// Hexo uses Connect as a server\n\t// You can customize the logger format as defined in\n\t// http://www.senchalabs.org/connect/logger.html\n\tport: 4000\n\tlogger: false\n\tlogger_format:\n\n\t// Date / Time format\n\t// Hexo uses Moment.js to parse and display date\n\t// You can customize the date format as defined in\n\t// http://momentjs.com/docs/#/displaying/format/\n\tdate_format: YYYY MMM D\n\ttime_format: H:mm:ss\n\n\t// Pagination\n\t// Set per_page to 0 to disable pagination\n\tper_page: 10\n\tpagination_dir: page\n\n\t// Disqus\n\tdisqus_shortname:\n\n\t// Extensions\n\t// Plugins: https://github.com/tommy351/hexo/wiki/Plugins\n\t// Themes: https://github.com/tommy351/hexo/wiki/Themes\n\n\tplugins:\n\t- hexo-generator-sitemap\n\n\n\ttheme: bootstrap\n\texclude_generator:\n\n\t// Deployment\n\t// Docs: http://zespia.tw/hexo/docs/deploy.html\n\tdeploy: \n\t  type: github\n\t  repository: https://github.com/hufeng825/hufeng825.github.io.git\n\t  branch: master\n ","mtime":1377913082000,"source":"_posts/hexo1.md"},"e127yktv9srjiou7":{"_id":"e127yktv9srjiou7","content":"title: git系类教程之 综合篇\ndate: 2013-09-03 10:18:19\ntags: [技术]\ncategories: git\n---\n\n不敢说这是git常用操作最全的教程，这是本人再前人的基础上加上应用了三年多git总结的，应该是比较全的，后续我还会把git 常见的错误总结出来。\n<!-- more -->\n\n##git基本工作流程\n\ngit支持很多种不同的工作流程，我们采用的是与SVN接近的模拟中央服务器流程。即，有一个公用的代码库放在服务器上，开发者从这个共享的服务器克隆后，在本地开发，然后提交到服务器，并且从服务器获取其他用户提交的内容。\n\n**注意** git是分布式的代码控制系统，所以每个代码库都是平等的，这里只是在逻辑上划分了一个中央服务器而已，在物理结构上，中央代码库与本地代码库没有什么不同。\n[编辑]创建帐号\ngit可以使用多种协议在代码库之间通信。我们目前采用ssh协议，需要用户在服务器上有一个ssh帐号才能访问代码库。用户需要在本机创建一个ssh密钥对，把公钥发给管理员，密钥保存在自己本机。这样，就可以使用密钥连接服务器。\n\n\n##开始工作\n开始工作之前，需要复制一套中央服务器的代码库：\n\n```\n$ git clone /server/repo/project\n\n```\n\n###本地修改和提交\n\ngit的提交操作是在本地完成的，不需要网络连接。\n\n```\n$ git checkout branch\n--- 编辑现有文件或者添加新文件 ...\n\n```\n\n```\n$ git add newfile\n$ git commit -a\n--- 填写此次提交的备注\n\n```\n###从中央服务器获取其他人的更新\n\n这个操作实际是执行了获取更新，并且与本地代码合并两个操作。因为有可能2人改了同一个地方，所以这里有可能会出现冲突的情况。出现冲突时，需要手工合并代码。\n\n```\n$ git pull\n向中央服务器发送本地的修改\n这个操作是把本地的所有新的commit历史都提交到服务器\n\n```\n\n```\n$ git push\n\n```\n\n##一：版本控制守则\n\n1. 不要提交垃圾文件。包括临时文件，编译产生的二进制文件，个人设置文件，系统cache，与项目无关的文件等等。使用.gitignore文件来告诉git哪些文件应该忽略掉。  \n\n2. 不要提交不能编译运行的代码到master分支。平时创建临时分支来工作，可以随时提交，当告一段落之后再合并到master分支。保证master分支的代码是可运行的，这样不会给团队中的其他人带来不必要的影响。 \n\n3. 善用分支。可以每开始一个新功能时就创建一个新分支，改完后合并到master。每个新版本也要用一个新分支，这样如果需要改老版本的bug，那么可以很轻松地切换到老分支，改完后再切回新分支。 \n\n4. 多提交，及时提交。每当改动达到可以用一句话描述的时候，就提交。 \n\n5. 一定要写清楚提交注释，写明做了哪些修改，不要用笼统的一句话例如“改bug”，而是要写具体的说明例如，“按钮文字从转发改成分享”。\n每个准备提交上线的版本要打tag，命名成v1.0.0_rc1这种格式，第一次提交就是rc1，第二次提交就是rc2等等 \n\n---\n\n##二：git仓库\n\n###请求代码\n\n```\n$ git clone ssh://%%%%.git\n$ git clone ssh://%%%%%%.git\n\n```\n\n##三： 本地代码库管理\n\n### 1.让git使用你的用户名来标记每次commit\n\n```\n$ git config --global user.name \"hufeng\"\n$ git config --global user.email hufeng@hufengvip.cn\n\n```\n### 2.在当前目录初始化一个代码库\n\n```\n$ git init\n\n```\n\n### 3.把所有文件加入版本控制\n\n```\n$ git add .\n\n```\n### 4.commit所有修改过的文件\n\n```\n$ git commit -a\n\n```\n\n### 5.扔掉对代码库所做的修改，恢复到HEAD版本\n\n```\n$ git checkout -f\n或\n$ git reset --hard\n\n```\n### 6.优化log显示\n\n```\ngit log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n\n```\n### 7.创建一个分支\n\n```\n$ git branch test\n\n```\n\n### 8.切换到一个分支\n\n```\n$ git checkout test\n\n```\n\n### 9.切换回主分支\n\n```\n$ git checkout master\n\n```\n### 10.命令行提示符脚本\n\n*把下面的脚本放到 ~/.profile 或者 ~/.bashrc 里，命令行的提示符即会显示出当前的git分支名称。例如：~/Projects/cmb (master) $*\n\n```\nfunction parse_git_branch {\n      ref=$(git symbolic-ref HEAD 2> /dev/null) || return\n        echo \"(\"${ref#refs/heads/}\")\"\n}\n\nPS1=\"\\w \\$(parse_git_branch)\\$ \"\n\n```\n---\n\n## 三. 操作远程代码库\n\n### 1.使用git协议共享本地代码库\n\ngit本身带了一个服务器命令，启动后，其他机器可以用git协议访问本机的代码库\n\n```\n$ git daemon --export-all --base-path=/home/pub/projects/ test.git\n\n```\n**注意：**\n\n* 如果返回\"fatal: no matching remote head\"，说明代码库里没有文件或者没有commit过。\n* 在.git目录下应该有git-daemon-export-ok这个文件，否则必须使用export-all参数来强制共享\n* 如果允许远程提交代码，需要加上 --enable=receive-pack 参数\n\n### 2.从版本库中删除文件\n\n```\n在git rm -rf  --cached  CCB.xcodeproj/project.xcworkspace/xcuserdata/  \n\n--cached 本地保留服务器删除\n\n```\n### 3.远程仓库的重命名\n\n在新版 Git 中可以用 git remote rename 命令修改某个远程仓库的简短名称，比如想把 pb 改成 paul，可以这么运行：\n\n```\n$ git remote rename pb paul\n$ git remote origin pau\n\n```\n**注意**\n对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 pb/master 分支现在成了paul/master。\n\n### 4.远程仓库的删除\n\n碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 git remote rm 命令：\n\n```\n$ git remote rm branchA\n\n```\n或者使用\t\n\n```\n $ git push origin :xx //删除远程\n \n $ git branch -d xx //删除本地\n\n```\n\n### 5.更新指定分支指定文件\n\n```\n$ git checkout 指定分支 指定文件\n\n$ git checkout master HFFrame/Global/Global_macro.h\n\n```\n\n### 6.复制一个远程代码库\n\n```\n$ git clone git://10.150.150.136/test.git test\n\n```\n\n### 7.从远程代码库上的主分支获取最新的代码\n\n第一次：\n\n```\n$ git pull git://10.150.###.###/test.git master\n或\n$ git pull ssh://10.150.###.###/test.git master\n\n```\n以后：\n\n```\n$git pull origin master\n\n指定好配置文件后可以直接执行pull push 不用跟后面的分支 骨干\n\n具体方法是 仓库跟目录 .git/config \n\n [core]\n           repositoryformatversion = 0\n           filemode = true\n           bare = false\n           logallrefupdates = true\n           ignorecase = true\n   [remote \"origin\"]\n           fetch = +refs/heads/*:refs/remotes/orig    in/*\n           url = ssh://git@git.huaxia.com:6521    /cmblife.git\n   [branch \"master\"]\n          remote = origin\n          merge = refs/heads/master\n   [branch \"hufeng\"]\n          remote = origin\n          merge = refs/heads/hufeng\n\n```\n### 8.将本地代码库的修改传给远程代码库\n\n如果是提交到master分支：\n\n```\n$ git push origin master\n\n```\n**警告** 远程代码库应该是一个空的bare库，否则会搞乱working copy！！如果working copy是干净的，可以使用git checkout -f来同步代码库。如果已经做了修改，则就没有很好的办法恢复同步状态了！\n\n### 9. 在远程代码库创建一个分支\n\n有时候在本地创建的分支希望分享到远程代码库的分支里，下面命令会在远程创建一个名为branch的分支，并且和本地的branch分支关联起来\n\n```\n$ git push origin branch\n\n```\n以后，即可使用 git push 来分享代码到远程库。\n\n\n### 10.在本地关联一个远程库的分支\n\n有时候需要在本地获取一个远程分支，使用这个命令：\n\n```\n$ git branch --track origin/branch\n\n```\n以后即可使用 git pull 来获取远程的更新\n\n\n### 11.下载所有远程分支\n\n```\n$ get fetch --all\n\n```\n\n\n\n\n\n\n\n","mtime":1381244446000,"source":"_posts/git8.md"},"g2vv1vu8vh4m1oqa":{"_id":"g2vv1vu8vh4m1oqa","content":"title: mac 下的默认配置\ndate: 2013-08-31 21:45:59\ntags: [技术]\ncategories: [ios, mac]\n---\n\n请几天安装其他的shell 结果把默认的shell更改了  有没有快捷的方法更换会默认配置 <!--more-->其实mac 下 有一个很简单命令可以搞定这些用户默认设置\n打开终端社着敲敲如下的命令\n\n\tchsh\n\n{%img left http://ww3.sinaimg.cn/mw690/a43af4ffjw1e866tu4f66j20a107sq3i.jpg  运行效果 300  400 %}\n\n\n","mtime":1378087359000,"source":"_posts/ios10.md"},"ozd2umcz6pvpmcgk":{"_id":"ozd2umcz6pvpmcgk","content":"title: hibernate 笔记之 session\ndate: 2013-08-14 10:36:16\ntags: [技术]\ncategories: hibernate\n---\n## session 的概述\n<!-- more -->\n\n1. session 接口是hibernate 向应用程序提供操作数据库最主要的接口，他提供了基本的保存，更新，删除和加载java对象的方法\n\n2. session 具有一个缓存对象，位于缓存中的对象成为持久化对象，它和数据库中的相关记录对应，session能够在某些时间点，按照缓存中的对象变化来执行相关的sql语句。来同步更新数据库，这一过程被称为清理缓存\n\n3. 站在持久化的角度，hibernate 把对象分成四种状态：持久化状态，临界状态，游流状态 删除状态 session的特定方法能使对象从一个状态转换成另一个状态\n\n---\n## Session 接口\nSession 是应用程序与数据库之间交互操作的一个单线程对象,是 Hibernate 运作的中心,所有持久化对象必须在 session 的管理下才可以进 行持久化操作。此对象的生命周期很短。Session 对象有一个一级缓存,显 式执行 flush 之前,所有的持久层操作的数据都缓存在 session 对象处。相 当于 JDBC 中的 Connection。\n\n• 持久化类与 Session 关联起来后就具有了持久化的能力。\n\n• Session 类的方法:\n\n* 取得持久化对象的方法: get() load()\n\n* 持久化对象都得保存,更新和删除: save(),update(),saveOrUpdate(),delete()\n\n* 开启事务: beginTransaction().\n\n* 管理 Session 的方法:isOpen(),flush(), clear(), evict(), close()等\n\n\n\n```\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.hibernate.Hibernate;\nimport org.hibernate.Session;\nimport org.hibernate.Transaction;\n\nimport com.vince.entity.User;\nimport com.vince.util.HibernateUtil;\n\n\npublic class Test {\n\t\n\t\n\tpublic static void evict(){\n\t\t\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n\t\tUser user = new User(\"test-7\",17,new Date());\n\t\tsession.save(user);\n\t\t\n\t\tsession.evict(user);//把对象从session中清除,在批量处理时，避免session中缓存的对象太多，会导致内存溢出\n//\t\tsession.clear();//清除session中所有的缓存对象\n\t\tUser user2 = (User)session.load(User.class, user.getId());\n\t\tSystem.out.println(user2);\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t\n\t\n\t/**\n\t * merge方法：合并,保存或更新\n\t * \n\t * \n\t */\n\tpublic static void merge(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n\t\t//情况一：临时对象(新创建的对象)\n\t\t//1)user1 的状态是瞬时对象时，创建一个新的对象user2,把user1对象的属性拷贝到新建的user2对象中,持久化这个user2对象,执行insert语句\n//\t\tUser user1 = new User();\n//\t\tuser1.setAge(22);\n//\t\tuser1.setName(\"test--3\");\n//\t\tuser1.setCreateDate(new Date());\n//\t\t\n//\t\t\n//\t\tUser user2 = (User)session.merge(user1);\n//\t\t\n//\t\tSystem.out.println(user1==user2);\n\t\t\n\t\t//情况二：user1 的状态是游离对象时，Session缓存中是否存在ID为与user1相同的持久化对象\n\t\t//(1)如果有\n//\t\tUser user2 = (User)session.load(User.class, 1);\n//\t\tUser user1 = new User();\n//\t\tuser1.setAge(20);\n//\t\tuser1.setCreateDate(new Date());\n//\t\tuser1.setId(1);\n//\t\tuser1.setName(\"test---4\");\n//\t\tsession.merge(user1);\n\t\t\n\t\t\n\t\t\n\t\t//情况三：如果session中不存在该对象，那么去数据库中查询是否存在该ID的记录，\n\t\t//如果存在，那么就加载这条记录到session中(user2)，比较两个对象属性是否一致，\n\t\t//如果不一致，就把user1的属性拷贝到user2中，执行update语句\n\t\t//如果一致，就不执行任何操作\n//\t\tUser user1 = new User();\n//\t\tuser1.setAge(22);\n////\t\tuser1.setCreateDate(new Date());\n//\t\tuser1.setId(5);\n//\t\tuser1.setName(\"aaa\");\n//\t\tsession.merge(user1);\n\t\t\n\t\t//情况四：如果session中不存在该对象，那么去数据库中查询是否存在该ID的记录，\n\t\t//如果不存在，创建一个新的对象user2,把user1对象的属性拷贝到新建的user2对象中,\n\t\t//持久化这个user2对象,执行insert语句\n\t\tUser user1 = new User();\n\t\tuser1.setAge(22);\n\t\tuser1.setCreateDate(new Date());\n\t\tuser1.setId(6);\n\t\tuser1.setName(\"bbb\");\n\t\tUser user2 = (User)session.merge(user1);\n\t\t\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t\t\n\t}\n\t\n\t/**\n\t * saveOrUpdate 方法：执行保存或更新\n\t * 1、如果实体对象是临时状态（没有ID），那么该方法将执行保存操作\n\t * 2、如果实体对象是游离状态（有ID），那么该方法以将执行更新操作\n\t * \t如果数据库不存在该ID，那么更新将抛出异常\n\t * 3、判断ID是否为空（整型ID 0 空），根据映射文件中的unsaved-value\n\t * \t属性值来判断\n\t */\n\tpublic static void saveOrUpdate(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n\t\tUser user = new User();\n\t\tuser.setAge(21);\n\t\tuser.setName(\"test--1\");\n\t\tuser.setCreateDate(new Date());\n\t\tuser.setId(3);\n\t\t\n\t\tsession.saveOrUpdate(user);\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t\n\tpublic static void delete(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n//\t\tUser user = new User();\n//\t\tuser.setId(6);\n//\t\tuser.setName(\"xxx\");\n\t\t\n\t\tUser user = (User)session.load(User.class, 3);\n\t\t\n\t\tsession.delete(user);\n\t\t\n\t\tSystem.out.println(user.getId());\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t/**\n\t * 更新对象:通过update方法\n\t * 1、如果数据库中不存在ID的记录，抛出异常\n\t * 2、默认生成的SQL语句会根据ID为条件更新所有字段，\n\t * 如果只更新发生变化的字段，那么在映射文件的class配置中添加 dynamic-update=true\n\t * \n\t */\n\tpublic static void update2(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\t\n//\t\tUser user = new User(\"Tom-1\",23,new Date());\n\t\tUser user = (User)session.get(User.class, 1);\n\t\t\n\t\tuser.setName(\"888\");\n\t\tsession.update(user);\n\t\t\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t/**\n\t * 更新对象\n\t * 通过session 的脏数据机制\n\t */\n\tpublic static void update1(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\tUser user = (User)session.load(User.class, 1);\n\t\tuser.setName(\"xxx\");\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t/**\n\t * load方法：\n\t * 1、如果数据库不存在记录，那么将抛出异常\n\t * 2、load方法先执行延迟加载，返回代理对象，在真正使用到该对象时才会\n\t * 从数据库中查询\n\t * 3、初始化代理对象的方法：\n\t * （1）调用代理对象的非主键属性\n\t * （2）Hibernate.initialize()方法初始化代理对象\n\t */\n\tpublic static User load(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\tUser user = (User)session.load(User.class, 5);\n\t\t\n//\t\tSystem.out.println(user.getName());\n\t\tHibernate.initialize(user);//初始化代理对象\n\t\ttx.commit();\n\t\tsession.close();\n\t\t\n\t\treturn user;\n\t}\n\t\n\t/**\n\t * get方法：\n\t * 1、立即从数据库中查询数据\n\t * 2、如果数据库不存在记录，那么将返回null\n\t */\n\tpublic static void get(){\n\t\tSession session = HibernateUtil.getSession();\n\t\tTransaction tx = session.beginTransaction();\n\t\tClass c = User.class;\n\t\tUser user = (User)session.get(c, 1);\n\t\tif(user!=null){\n\t\t//修改时间\n\t\tuser.setCreateDate(new Date());\n\t\t}\n\t\tSystem.out.println(user);\n\t\t\n//\t\tsession.flush();//刷新缓冲\n\t\ttx.commit();\n\t\tsession.close();\n\t}\n\t\n\t/**\n\t * save()方法以会立即为持久化对象设置主键，所有在任何时候会执行insert语句\n\t * persist()，如果在事务内部那么与save()一样，如果在事务外部，不会立即执行\n\t * insert语句\n\t */\n\tpublic static void save(){\n//\t\tUser user = new User(\"jack\",22,new Date());\n\t\tUser user = new User();\n\t\tuser.setName(\"jack\");\n\t\tSession session = HibernateUtil.getSession();\n//\t\tTransaction tx = session.beginTransaction();\n\t\tsession.save(user);\n//\t\tsession.persist(user);\n\t\t\n//\t\ttx.commit();\n\t\t\n\t\tsession.close();\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n//\t\tsave();\n//\t\tget();\n//\t\tUser user = load();\n//\t\tSystem.out.println(user);\n\t\t\n//\t\tupdate1();\n//\t\tupdate2();\n\t\t\n//\t\tdelete();\n//\t\tsaveOrUpdate();\n//\t\tmerge();\n//\t\tevict();\n\t\t\n//\t\tSystem.out.println(UUID.randomUUID().toString());\n\t}\n\n}\n\n\n```","mtime":1377913082000,"source":"_posts/hibernate1.md"},"xgwi765y4dmogxym":{"_id":"xgwi765y4dmogxym","content":"title: 银行支付控件之 自动随机(shuffle)密码键盘的实现算法\ndate: 2013-08-31 22:05:28\ntags: [技术]\ncategories: ios\n---\n为了广大用户的支付安全,输入密码的页面密码键盘要用随机排序,因为有版权问题无法把自己写的代码全部贴出 所以下面只把关键的洗牌算法贴出来\n\n##算法一\n```\nNSMutableArray *randSequence = [[NSMutableArray alloc] initWithCapacity:8];\nfor (int ii = 0; ii < 10; ++ii)\n    [randSequence addObject:[NSNumber numberWithInt:ii]];\n\nfor (int ii = 9; ii > -1; --ii) {\n    int r = arc4random() % 9\n    [randSequence exchangeObjectAtIndex:ii withObjectAtIndex:r];\n\n```\n##算法二\n```\n\n@interface NSMutableArray (Shuffling)\n- (void)shuffle;\n@end\n\n\n//  NSMutableArray_Shuffling.m\n\n#import \"NSMutableArray_Shuffling.h\"\n\n@implementation NSMutableArray (Shuffling)\n\n- (void)shuffle\n{\n    NSUInteger count = [self count];\n    for (NSUInteger i = 0; i < count; ++i) {\n        // Select a random element between i and end of array to swap with.\n        NSInteger nElements = count - i;\n        NSInteger n = (arc4random() % nElements) + i;\n        [self exchangeObjectAtIndex:i withObjectAtIndex:n];\n    }\n}\n\n@end\n```\n\n","mtime":1377958941000,"source":"_posts/ios11.md"},"s01k8on03xoxp5av":{"_id":"s01k8on03xoxp5av","content":"title: hibernate 笔记之 基础概念和配置\ndate: 2013-08-14 15:56:58\ntags: [技术]\ncategories: hibernate\n---\n## ORM 概念\n> ORM 解决主要的问题是对象-- 关系映射， 域模型是面向对象的，而关系模型数据是面向关系的，一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录。\n\n<!-- more -->\n\n### 对象的持久化\n\n• 狭义的理解,“持久化”仅仅指把对象永久保存到数据库中\n\n• 广义的理解,“持久化”包括和数据库相关的各种操作:\n\t\n* 保存:把对象永久保存到数据库中。\n\n* 更新:更新数据库中对象(记录)的状态。\n\n* 删除:从数据库中删除一个对象。\n\n* 查询:根据特定的查询条件,把符合查询条件的一个或多个对象从数据 库加载到内存中。\n\n* 加载:根据特定的OID,把一个对象从数据库加载到内 \n\t>' OID --->为了在系统中能够找到所需对象,需要为每一个对象分配一个唯一的标识号。 在关系数据库中称之为主键,而在对象术语中,则叫做对象标识(Object identifier-OID). '\n\n\n 标号  | 面向对象概念 | 面向关系概念 \n--- | --- | ---\n*1* | `对象` | **表的行（即记录）**\n2 | 属性 | 表的列（即字段）\n\n## 注意事项\n\n1. 有一个无参的构造器  反射时需要\n2.  类不能声明为final  如果声明就不能实现延迟加载了\n\n## hibernate 配置文件\n\n> hibernate.cfg.xml\n\n```\n<hibernate-configuration>\n\t<session-factory>\n\t\t<!-- 数据连接相关的配置 -->\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql://localhost:3306/test</property>\n\t\t<property name=\"hibernate.connection.username\">root</property>\t\t\t\n\t\t<property name=\"hibernate.connection.password\">1234</property>\n\t\t\t\n\t\t<!-- 执行操作时显示SQL语句 -->\n\t\t<property name=\"show_sql\">true</property>\n\n\t\t<!-- 格式化输出的SQL语句 -->\n\t\t<property name=\"format_sql\">true</property>\n\t\t\n\t\t<!-- 配置数据库方言 -->\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\t\n\t\t<property name=\"hibernate.hbm2ddl.auto\">update</property>\n\t\t\t\n\t\t<!-- 配置映射文件 -->\t\t\t\n\t\t<mapping resource=\"com/vince/entity/User.hbm.xml\"/>\t\n\t\t</session-factory>\t\n</hibernate-configuration>\n\n```\n\nhbm2ddl.auto:该属性可帮助程序员实现正向工程, 即由 java 代码生成数据库脚本, 进而生成具体的表结构. 。取值 create | update | create-drop | validate\n\n– create : 会根据 .hbm.xml 文件来生成数据表, 但是每次运行都会删 除上一次的表 ,重新生成表, 哪怕二次没有任何改变\n\n– create-drop:会根据.hbm.xml文件生成表,但是SessionFactory一关 闭, 表就自动删除\n\n– update:最常用的属性值,也会根据.hbm.xml文件生成表,但 若 .hbm.xml 文件和数据库中对应的数据表的表结构不同, Hiberante 将更新数据表结构,但不会删除已有的行和列\n\n– validate : 会和数据库中的表进行比较, 若 .hbm.xml 文件中的列在数 据表中不存在,则抛出异常\n\n* format_sql:是否将 SQL 转化为格式良好的 SQL . 取值 true | false\n\n------------------\n\n## hibernate 映射文件\n\n> User.hbm.xml\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE hibernate-mapping PUBLIC\n\t\"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n\n<hibernate-mapping package=\"com.vince.entity\">\n\t<class name=\"User\" table=\"USER_TABLE\" dynamic-update=\"true\" dynamic-insert=\"true\">\n\t\t<!-- 配置主键 -->\n\t\t<id name=\"id\" column=\"ID\">\n\t\t\t<!-- native表示使用本地数据库生成主键的方式 -->\n\t\t\t<generator class=\"native\"></generator>\n\t\t</id>\n\t\t<!-- 其它属性的配置 -->\n\t\t<property name=\"name\" column=\"NAME\" not-null=\"true\"></property>\n\t\t<property name=\"age\" column=\"AGE\"></property>\n\t\t<property name=\"createDate\" column=\"CREATE_DATE\"></property>\n\t</class>\n\n</hibernate-mapping>\n\n\n-------\n\n<hibernate-mapping package=\"com.vince.entity\">\n\t<class name=\"Emp\" table=\"EMP\" dynamic-insert=\"true\"\n\t\tdynamic-update=\"true\">\n\t\t<id name=\"id\" type=\"int\">\n\t\t\t<column name=\"ID\" />\n\t\t\t<generator class=\"native\" />\n\t\t</id>\n\t\t<property name=\"name\" type=\"java.lang.String\">\n\t\t\t<column name=\"NAME\" />\n\t\t</property>\n\t\t<property name=\"salary\" type=\"float\">\n\t\t\t<column name=\"SALARY\" />\n\t\t</property>\n\t\t<property name=\"age\" type=\"int\">\n\t\t\t<column name=\"AGE\" />\n\t\t</property>\n\t</class>\n</hibernate-mapping>\n\n```\n\n###主键生成策略\n\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7n5a834npj20x00lajw6.jpg\n  hiberate 主键生成策略 %}\n\n ------\n\n\n##SessionFactory 接口\n• 针对单个数据库映射关系经过编译后的内存镜像,是线程安 全的。\n\n• Configuration 对象根据当前的配置信息生成 SessionFactory 对象。SessionFactory 对象一旦构造完毕,即被赋予特定的 配置信息\n\n* Configuration cfg = new Configuration().configure();\n\n* SessionFactory sf = cfg.buildSessionFactory();\n\n• SessionFactory是生成Session的工厂:\n\n* Session session = sf.openSession();\n\n• 构造 SessionFactory 很消耗资源\n\n\n## hibernate.hbm2ddl.auto \n1. create-drop   每次启动重新创建 结束后删除\n2. create 每次启动都重新创建\n3. update 不一样就更新\n4. validate 仅仅验证\n\n\n\n## 如何使用\n\n### 使用范例\n\n\n```\npackage hufeng.test ;\n\nimport org.hibernate.Session ;\nimport org.hibernate.SessionFactory ;\nimport org.hibernate.cfg.Configuration ;\n\npublic class  Test{\n\tpublick static void main(String[] args){\n\t// 加载hibernate 配置文件 （默认加载classpath 下的hibernate.cfg.xml）\n\tConfiguration cfg = new Configuration().config();\n\t\n\t// 通过Configulation 对象创建SessionFactory 工厂\n\tSessionFactory factory = cfg.buildSessionFactory();\n \t\n \t//Session操作数据库的一次会话\n \t//线程不安全\n \tSession session = factory.openSession();\n\n\n \t//开启事务 --> 把很多操作组合成一个整体 让事物具有原子性\n \tTransaction tx =  session.beginTransation();\n\n\n \tCustomUser user = new CustomUser(\"jason\",20,new Date());\n\n \t//保存数据\n \tsession.save(user);\n\n \t//提交事物\n \ttx.commit();\n\n \t//关闭\n \tsession.close();\n \tfactory.close();\n }\n}\n\n```\n\n### 创建Hibernate 工具类\n\n```\npublic final class HibernateUtil{\n\tprivate static SessionFactory sessionFactory;\n\tprivate HibernateUtil(){}\n\n\tstatic {\n\t\tConfiguration cfg  = new Configuration().configure();\n\t\tsessionFactory = cfg.buildSessionFactory();\n\t}\n\n\t public static SessionFactory  getSesstionFactory()\n\t {\n\t \treturn sessionFactory;\n\t }\n\n\t public static Session getSession()\n\t {\n\t \treturn sessionFactory.openSession();\n\t }\n\n\t public static void save(Object obj)\n\t {\n\t \tSession session = getSession();\n\t \tTransaction tx = session.benginTransaction();\n\t \tsession.save(obj);\n\t \tsession.evict(obj);//把对象清理出esssion 避免批处理时session中的缓存过多 导致内存溢出\n\t \t//session.clear()；清楚session中所有的对象\n\t \ttx.commit();\n\t \tsession.close();\n\t }\n}\n\n```\n\n### 应用工具类后的代码\n\n\n```\npackage hufeng.test ;\n\nimport org.hibernate.Session ;\nimport org.hibernate.SessionFactory ;\nimport org.hibernate.cfg.Configuration ;\nimport org.util.HibernateUtil;\n\npublic class Test {\n\tpublic static void save()\n\t{\n\t\tUser user =new User(\"jack\",22,new Date()));\n\t\tHibernateUtil.save(user);\n\t}\n}\n\npublick static void main(String[] args)\n{\n\tsave();\n}\n\n```\n### 更加规范应用HQL的代码\n\n```\npublic final class HibernateUtil {\n\n\tprivate static SessionFactory sessionFactory;\n\n\tprivate HibernateUtil() {\n\t}\n\n\tstatic {\n\t\tConfiguration cfg = new Configuration().configure();\n\t\tsessionFactory = cfg.buildSessionFactory();\n\t}\n\n\tpublic static SessionFactory getSessionFactory() {\n\t\treturn sessionFactory;\n\t}\n\n\tpublic static Session getSession() {\n\t\treturn sessionFactory.openSession();\n\t}\n\n\tpublic static void save(Object obj) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\tTransaction tx = session.beginTransaction();\n\t\t\tsession.save(obj);\n\t\t\ttx.commit();\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t}\n\tpublic static void update(Object obj) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\tTransaction tx = session.beginTransaction();\n\t\t\tsession.update(obj);\n\t\t\ttx.commit();\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t}\n\t\n\tpublic static void delete(Object obj) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\tTransaction tx = session.beginTransaction();\n\t\t\tsession.delete(obj);\n\t\t\ttx.commit();\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t}\n\t\n\tpublic static Object get(Class clazz,Serializable id) {\n\t\tSession session = null;\n\t\ttry {\n\t\t\tsession = getSession();\n\t\t\treturn session.get(clazz, id);\n\t\t} catch (HibernateException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tsession.close();\n\t\t}\n\t\treturn null;\n\t}\n\n}\n\n--------\n@Override\n\tpublic List<Emp> list() throws Exception {\n\t\tSession session  = HibernateUtil.getSession();\n\t\t//hql针对对象查询语句\n\t\tString hql = \"from Emp\";//\n\t\t//创建查询(hql)\n\t\tQuery query = session.createQuery(hql);\n\t\tList<Emp> list = query.list();\n\t\tsession.close();\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic void add(Emp emp) throws Exception {\n\t\tHibernateUtil.save(emp);\n\t\t\n\t}\n\n\t@Override\n\tpublic List<Emp> listByName(String name) throws Exception {\n\t\tSession session  = HibernateUtil.getSession();\n\t\tString hql = \"from Emp e where e.name=?\";\n\t\tQuery query = session.createQuery(hql);\n\t\t//sql ？起始位置从1开始\n\t\t//hql ？起始位置从0开始\n\t\tquery.setString(0, name);\n\t\t\n\t\tList<Emp> list = query.list();\n\t\tsession.close();\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic List<Emp> listByAge(int age) throws Exception {\n\t\t\n\t\t\n\t\treturn null;\n\t}\n\n\t//使用别名代替?方式，可以不用考虑设置参数的顺序\n\t@Override\n\tpublic List<Emp> listByNameAge(String name, int age) throws Exception {\n\t\tSession session = HibernateUtil.getSession();\n\t\tString hql = \"from Emp e where e.age=:age and e.name=:name\";\n\t\tQuery query = session.createQuery(hql);\n//\t\tquery.setString(0, name);\n//\t\tquery.setInteger(1, age);\n\t\tquery.setString(\"name\", name);\n\t\tquery.setInteger(\"age\", age);\n\t\t\n\t\t//对分页的支持\n\t\tquery.setFirstResult(0);//设置查询的起始位置\n\t\tquery.setMaxResults(1);//设置每页的记录数\n\t\t\n\t\t\n\t\tList<Emp> emps = query.list();\n\t\t\n\t\t\n\t\t\n\t\t//iterate查询会执行 N+1条语句\n//\t\tIterator<Emp> emps = query.iterate();\n\t\t\n\t\tsession.close();\n\t\treturn emps;\n\t}\n\n\t@Override\n\tpublic List<Emp> listLikeName(String name) {\n\t\tSession session = HibernateUtil.getSession();\n\t\tString hql = \"from Emp e where e.name like :name\";\n\t\tQuery query = session.createQuery(hql);\n\t\tquery.setString(\"name\", \"%\"+name+\"%\");\n\t\tList<Emp> list = query.list();\n\t\tsession.close();\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic Emp getByName(String name) {\n\t\tString hql = \"from Emp e where e.name=:name\";\n\t\tSession session = HibernateUtil.getSession();\n\t\tQuery query = session.createQuery(hql);\n\t\tquery.setString(\"name\", name);\n\t\t//返回唯一的结果\n\t\tEmp emp = (Emp)query.uniqueResult();\n\t\tsession.close();\n\t\treturn emp;\n\t}\n\n\t//QBC检索方式(了解)\n\t@Override\n\tpublic Emp getById(int id) {\n\t\t\n\t\tSession session = HibernateUtil.getSession();\n\t\tCriteria criteria = session.createCriteria(Emp.class);\n\t\t//添加查询条件\n\t\tcriteria.add(Restrictions.eq(\"id\", id));\n\t\tEmp emp = (Emp)criteria.uniqueResult();\n\t\tsession.close();\n\t\treturn emp;\n\t}\n\n\t@Override\n\tpublic long countEmp() {\n\t\tString hql = \"select count(id) as id from Emp\";\n\t\tSession session = HibernateUtil.getSession();\n\t\tQuery query = session.createQuery(hql);\n\t\tlong count = (long)query.uniqueResult();\n\t\tsession.close();\n\t\treturn count;\n\t}\n\tpublic void countEmp2() {\n\t\tString hql = \"select count(id),avg(age) as id from Emp\";\n\t\tSession session = HibernateUtil.getSession();\n\t\tQuery query = session.createQuery(hql);\n\t\tList list = query.list();\n\t\tObject[] objs = (Object[])list.get(0);\n\t\tint count = (int)objs[0];\n\t\tint avg = (int)objs[1];\n\t\tsession.close();\n\t}\n\n\n```\n","mtime":1377913082000,"source":"_posts/hibernate0.md"},"2x07hj59q4igig4r":{"_id":"2x07hj59q4igig4r","content":"title: ios 开发之 序列化\ndate: 2013-08-31 22:26:47\ntags: [技术]\ncategories: ios\n---\n\n序列化\n\n参考原始文档：\n\nhttps://github.com/mystcolor/JTObjectMapping\n\n<!-- more -->\n使用方法\n\n========\n\n\n绝大多数情况下，需要用到的就是一个方法：\n\n[NSObject objectFromJSONObject:stateObject mapping:nil];\n\n其中，把NSObject换成我们想映射成的类的名字。\n\n\n稍微复杂一点，假设类的属性和JSON里的key名字不是一一对应的，那么就要写一个映射关系表作为mapping参数：\n\n    NSDictionary *mapping = [NSDictionary dictionaryWithObjectsAndKeys:\n\n                             @\"myState\", @\"state\",\n\n                             @\"movieList\", @\"movie\",\n\n                             nil];\n\n    [NSObject objectFromJSONObject:stateObject mapping:mapping];\n\n\n如果再复杂一点，我们需要映射一个数组，数组的每个元素映射到一个对象，那么就用到第2个方法：\n\n[NSObject mappingWithKey:@\"responseState\" mapping:nil]\n\n同样，把NSObject换成数组元素对应的类，key是用来存放整个数组的那个属性。\n\n\n\n注意\n\n====\n\nJSON里的字符串，是能自动映射成NSNumber或者int型的，不需要特别写代码。如果想把一个字符串日期，映射成NSDate型，请参考原始文档。\n\n\n\n具体举个例子\n\n===========\n\n\n假设我们有这样一段JSON：\n\n\n {\n\n \"state\":[\n\n {\n\n \"respCode\":\"0000\",\n\n \"respMsg\":\"1\"\n\n }\n\n ],\n\n \"movie\":[\n\n {\n\n \"body\":\"    一开始，这只是叶问的故事他生于佛山\",\n\n \"pics\":\"/images/jz/4779-1-20121225133147.jpg,/images/jz/4779-2-20121225133147.jpg\",\n\n \"name\":\"一代宗师\",\n\n \"movid\":\"4779\",\n\n \"length\":\"120\",\n\n \"hasplan\":\"1\",\n\n \"trailor\":\"/4779.m4v\",\n\n \"director\":\"梁朝伟 章子怡 张震 \",\n\n \"type\":\"动作/传记/剧情/IMAX\",\n\n \"url\":\"http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&w=140\",\n\n \"popularity\":\"6\"\n\n },\n\n {\n\n ...\n\n }\n\n ]\n\n }\n\n \n\n现在，想把它映射到自定义的对象中去。有几种情况：\n\n\n第一种情况，简单地把state数组里面的第一个元素映射成一个FGStateModel类\n\n那么就是，取出这个节点：\n\n    NSDictionary *stateObject = [[self.json objectForKey:@\"state\"] objectAtIndex:0];\n\n然后，执行映射：\n\n    self.state = [FGStateModel objectFromJSONObject:stateObject mapping:nil];\n\n\n第二种情况，把movie这个字典数组映射成一个数组，数组的每个元素是FGMovieModel\n\n    NSArray *movieObject = [self.json objectForKey:@\"movie\"];\n\n    self.movieList = [FGMovieModel objectFromJSONObject:movieObject mapping:nil];\n\n\n第三种情况，如果对象的属性和JSON名字不一样，可以使用映射表，例如我们想把上面整个json对象映射成一个 FGResponseModel 对象，其中，state数组映射成 responseState 属性，movie 数组映射成 movieList 属性。那么，我们需要告诉映射器这个数组里的元素要映射成什么对象。\n\n\n所以，通过 mapping 这个参数告诉它：“请把 JSON 里的 state 数组里的每个元素映射成一个 FGStateModel 对象，并且把最终的数组放到responseState这个属性里。另外，把 movie 这个数组映射成一个 FGMovieModel 数组，并且保存到 movieList 这个属性中。“\n\n\n    NSDictionary *mapping = [NSDictionary dictionaryWithObjectsAndKeys:\n\n                             [FGStateModel mappingWithKey:@\"responseState\" mapping:nil], @\"state\",\n\n                             [FGMovieModel mappingWithKey:@\"movieList\" mapping:nil], @\"movie\",\n\n                             nil];\n\n    self.response = [FGResponseModel objectFromJSONObject:self.json mapping:mapping];\n\n\n```\n#import <Foundation/Foundation.h>\n\n\n@interface FGMovieModel : NSObject\n\n\n@property (nonatomic, retain) NSString *body;\n\n@property (nonatomic, retain) NSString *pics;\n\n@property (nonatomic, retain) NSString *name;\n\n@property (nonatomic, assign) NSInteger movid;\n\n@property (nonatomic, retain) NSNumber *length;\n\n\n@end\n```\n\n\n```\n#import <Foundation/Foundation.h>\n\n\n@interface FGResponseModel : NSObject\n\n@property (nonatomic, retain) NSArray *responseState;\n\n@property (nonatomic, retain) NSArray *movieList;\n\n@end\n\n \n#import <Foundation/Foundation.h>\n\n\n@interface FGStateModel : NSObject\n\n\n@property (nonatomic, retain) NSString *respCode;\n\n@property (nonatomic, retain) NSString *respMsg;\n\n\n@end\n```","mtime":1385475973000,"source":"_posts/ios12.md"},"a1e2v9hwxvfpm901":{"_id":"a1e2v9hwxvfpm901","content":"title: 复杂页面消退的一个简单实例\ndate: 2013-08-31 22:42:52\ntags: [技术]\ncategories: ios\n---\n\n如图\n\n{% img left http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8680v5hirj20df09qglv.jpg  400 600 %}\n\n<!-- more -->\n实现上面的这个又两种实现方式 \n\n* 一种是给页面1 发广播通知 \n\n* 另外一种就是我要介绍的\n\n```\n [(UINavigationController*)self.parentViewController.presentingViewController\n\n     popToRootViewControllerAnimated:YES];\n\n    [self dismissModalViewControllerAnimated:YES];\n```\n","mtime":1378826228000,"source":"_posts/ios13.md"},"nad68b91arrhrw01":{"_id":"nad68b91arrhrw01","content":"title: 如何禁用禁用uwebiview 的反弹功能(bounces)\ndate: 2013-09-02 08:23:19\ntags: [技术]\ncategories: ios\n---\nUIWebView默认允许当网页内容处于最顶端时，用户可以用手指往下拖动，露出空白的背景\n如何禁用呢\n// iOS 5之前\n\n\tfor (id subview in webView.subviews)\n\t  if ([[subview class] isSubclassOfClass: [UIScrollView class]])\n\t    ((UIScrollView *)subview).bounces = NO;\n \n// iOS 5+\n\n\twebView.scrollView.bounces = NO;","mtime":1378081547000,"source":"_posts/ios15.md"},"1i1ago756hhlokq2":{"_id":"1i1ago756hhlokq2","content":"title: 如何清空 NSUserDefaults 下所有数据\ndate: 2013-09-02 08:18:20\ntags: [技术]\ncategories: ios\n---\n每个app 难免要在NSUserDefaults中记一些数据,但这些数据某些清空下药全部清空,比如系统版本升级啦,后台存储数据结构变更啦\n<!-- more -->\n下面给出的代码端就是清空NSUserDefaults的一个实现\n```\n  if (![[NSUserDefaults standardUserDefaults] boolForKey:@\"dontClearHXCache\"])\n\n    {\n\n        NSString *appDomainStr = [[NSBundle mainBundle] bundleIdentifier];\n\n        [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomainStr];\n\n        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"dontClearHXCache\"];\n\n       [[NSUserDefaults standardUserDefaults]synchronize];\n\n    }\n\n    else\n\n    {\n\n        [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@\"dontClearHXCache\"];\n\n        [[NSUserDefaults standardUserDefaults]synchronize];\n\n\n\n    }\n```","mtime":1378081323000,"source":"_posts/ios14.md"},"fwgp405dhbj0bzuq":{"_id":"fwgp405dhbj0bzuq","content":"title:  (NSDate) 时间 (time )比较\ndate: 2013-09-02 08:31:25\ntags: [技术]\ncategories: ios\n---\n做订餐app时对下单时间的时间判断\n下面是规则\n\n*   9:00-14:00 可以订餐\n*   14:00以后掌上餐厅仅接收晚餐订餐\n*   21:00以后掌上餐厅不接收订餐\n  \n{%img left http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87ve4c3ynj208q0abt9n.jpg 截图 300 400%}\n   \n<!-- more -->\n---\n##转换函数\n 将传入的小时和分钟 转换成当日的date\n\n 例如传入 8：00 的str 返回 2013-01-01 08：00 的nsdate\n\n```\n-(NSDate *)CurrentDayTime:(NSString *)dataStr\n\n{\n\n    //设置转换的format\n\n    NSDateFormatter *dateFormatter = [[[NSDateFormatteralloc]init]autorelease];\n\n    [dateFormatter setLocale:[NSLocalecurrentLocale]];\n\n    \n\n    [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm\"];\n\n    //获取当前年月日 \n\n    NSDate *currentdate = [NSDatedate];\n\n    NSCalendar *calendar = [NSCalendarcurrentCalendar];\n\n    NSDateComponents *components = [calendarcomponents:(\n\n                                                         NSYearCalendarUnit  |\n\n                                                         NSMonthCalendarUnit |\n\n                                                         NSDayCalendarUnit |\n\n                                                         NSHourCalendarUnit |\n\n                                                         NSMinuteCalendarUnit\n\n                                                         ) fromDate:currentdate];\n\n   NSInteger year = [components year];\n\n   NSInteger month = [components month];\n\n   NSInteger day = [components day];\n\n   NSString *strDate = [NSString stringWithFormat:@\"%d-%d-%d %@\",year,month,day,dataStr];\n\n   NSDate *date = [dateFormatter dateFromString:strDate];\n\n   return date;\n\n}\n```\n---\n##比较算法\n\n```\nNSLog(@\"%@\\n%@\",[selfCurrentDayTime:@\"18:00\"] ,[NSDatedate]);\n\n    NSDate *date = [NSDatedate];\n\n    if ([datecompare:[selfCurrentDayTime:@\"18:00\"]] ==NSOrderedDescending)\n\n    {\n\n        NSLog(@\"date1 is later than date2\");\n\n        \n\n    } else if ([datecompare:[selfCurrentDayTime:@\"18:00\"]] ==NSOrderedAscending)\n\n    {\n\n        NSLog(@\"date1 is earlier than date2\");\n\n        \n\n    } else\n\n    {\n\n        NSLog(@\"dates are the same\");\n\n        \n\n    }\n```\n##用法如下\n```\n-(BOOL)checkCanDinner\n\n{\n\n    NSDate *currentDate = [NSDatedate];\n\n    if ([currentDate compare:[selfCurrentDayTime:@\"08:59\"]] == NSOrderedDescending //late\n\n        && [currentDate compare:[selfCurrentDayTime:@\"13:59\"]] == NSOrderedAscending //early\n\n        )\n\n    {\n\n        //9:00-14:00 可以订餐\n\n        return YES;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"09:00\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"00:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        HFAlert(@\"因较多餐厅休息,9:00之前掌上餐厅不接收订餐，为您带来的不便请谅解。\");\n\n        return NO;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"17:59\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"14:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        HFAlert(@\"因较多餐厅休息,14:00以后掌上餐厅仅接收晚餐订餐,为您带来的不便请谅解。\");\n\n        return YES;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"21:00\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"18:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        //接受晚上的订单\n\n        return YES;\n\n    }\n\n    else if([currentDatecompare:[self CurrentDayTime:@\"23:59\"]] ==NSOrderedAscending //early\n\n            && [currentDate compare:[selfCurrentDayTime:@\"21:00\"]] ==  NSOrderedDescending//late\n\n            )\n\n    {\n\n        HFAlert(@\"因较多餐厅休息,21:00以后掌上餐厅不接收订餐,为您带来的不便请谅解。\");\n\n        return NO;\n\n    }\n\n    return YES;\n\n}\n```\n\n","mtime":1378083461000,"source":"_posts/ios17.md"},"jwt300hggcazdh6n":{"_id":"jwt300hggcazdh6n","content":"title: Block 定时器 让我们解放了\ndate: 2013-09-02 09:28:52\ntags: [技术]\ncategories: ios\n---\nBlock 没有出现前 ios写个定时器太麻烦了,好在Block的让我们小爽了一把,以后写timer 简单的要命了\n<!-- more -->\n\tdispatch_after(dispatch_time(DISPATCH_TIME_NOW, 0.5 * NSEC_PER_SEC), dispatch_get_current_queue(), ^{\n\n\t     [bgColorView removeFromSuperview];\n\n\t});\n\n\n或者\n\n\tdouble delayInSeconds = 2.0;\n\tdispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);\n\tdispatch_after(popTime, dispatch_get_main_queue(), ^(void){\n\t    <#code to be executed on the main queue after delay#>\n\t});","mtime":1378826228000,"source":"_posts/ios20.md"},"frcifbjiie55gmaj":{"_id":"frcifbjiie55gmaj","content":"title: 父View禁用touch 如何让子view还能获取touch event\ndate: 2013-09-02 09:14:30\ntags: [技术]\ncategories: ios\n---\n{%img left http://ww1.sinaimg.cn/mw690/a43af4ffjw1e87vwh4ocsj20a70dcjrp.jpg 300 400%}\n<!-- more -->\n如上图 当view2 包含在view1中,默认清空下 view1 的touch事件被禁用掉侯view2 肯定是接收不到touch事件的,那有没有什么办法能够让view2接收到touch事件呢?\n其实很简单hitTest 可以帮我们实现这个需求\n```\nuiview addition\n-(id)hitTest:(CGPoint)point withEvent:(UIEvent *)event {\n    id hitView = [super hitTest:point withEvent:event];\n    if (hitView == self) return nil;\n    else return hitView;\n}\n```","mtime":1378084698000,"source":"_posts/ios18.md"},"8lgujy5kyr0lmcxf":{"_id":"8lgujy5kyr0lmcxf","content":"title: 善用 NSAutoreleasePool 节约宝贵内存\ndate: 2013-09-02 08:26:20\ntags: [技术]\ncategories: ios\n---\nautorelease自动释放内存，并不会立即把内存释放掉，而是要等到下一个事件周期才会释放掉。问题是一些资源我们不得不使用autorelease类型，比如作为函数的返回值，而且系统api及项目是的大部分也都是这么做的，如果全都依靠我们手动释放很容易造成内存泄漏。\n<!-- more -->\n\n\t \tfor (int i = 0; i <= 10000; i ++) {\n\t  \n\t        //创建一个自动释放池\n\t  \n\t         NSAutoreleasePool *pool = [NSAutoreleasePool new];\n\t  \n\t         NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"hf\" ofType:@\"PNG\"];\n\t  \n\t         UIImage *image = [[UIImage alloc] initWithContentsOfFile:filePath];\n\t  \n\t         UIImage *scalimage = [image imageByScalingAndCroppingForSize:CGSizeMake(320, 640)];\n\t  \n\t         [image release];\n\t  \n\t        //将自动释放池内存释放，它会同时释放掉上面代码中产生的临时变量image2\n\t  \n\t         [pool drain];\n\t  \n\t     }","mtime":1378081691000,"source":"_posts/ios16.md"},"9haybpmg5wpggfpo":{"_id":"9haybpmg5wpggfpo","content":"title: ios笔记--block应该知道的那几件事\ndate: 2013-09-11 23:32:18\ntags: [技术]\ncategories: ios\n---\nblock 现在已经基本上已经使用非常普遍了,在引用中也又很多坑,下面把block开发中应该知道的那几件事总结下.\n<!-- more -->\n##:内联(inline)Block\n>内联block 说白了就是block被嵌入到一个函数中 \n例如:\n\n**typedef void (^HelloBlock)(void);**\n```\n- (void) BlockTest{\nHelloBlock myBlock= ^(void){\nNSLog(@\"Hello Block\");\n};\nmyBlock();\n}\n\n```\n\n##注意事项\n\n###1.内联的block中内部定义的变量 自己本身有读写权限\n\n###2.block内部要修改外部变量 需要将外部变量声明__block\n\n###3.Block retain是无效的，要想保留block生命周期，可以通过copy来实现，记得release\n\n###4.被block的应用的对象，retainCount会自动加一，为了打破这种 retain circle，可以在对象前加__block，这样block块就不会维护这个对象了\n\n 下面的写法如果不加上_block a无法dealloc\n\n```\n\n__block A  a =[ [[A alloc] init] withBlock:^{\n\n [a action];\n\n [ a release];\n\n}]; //这样A的dealloc方法就会调用\n\n```\n\n```\n\n@interface ViewController ： UIViewViewController \n {\n        NSString *_string;\n }\n\n __block ViewController *controller = self;   \n    _block = ^{\n         NSLog(@\"string %@\",controller->_string);\n    };\n\n```\n###5.在独立的block中不能引用self，如果需要访问可以使用参数传递的方法(可以把其考虑成c+中参数传入函数指针对应copy)**\n\n###6.不要随便用.语法\n\n```\n#import <UIKit/UIKit.h>   \n@interface AppDelegate : NSObject <UIApplicationDelegate>\n@property (nonatomic, strong) NSString *stringProperty;  \n@end  \n\n```\n\n```\n#import \"GCDAppDelegate.h\" \n@implementation AppDelegate \n@synthesize stringProperty;  \n- (void) BlockTestError{\nHelloBlock myBlock= ^(void){\n\tself.stringProperty = @\"Block Objects\"; \n\tNSLog(@\"String property = %@\", self.stringProperty);//运行错误\n};\nmyBlock();\n}}  \n\n- (void) BlockTestCorrect{\n\tHelloBlock myBlock= ^(void){\n\t\t[self setStringProperty:@\"Block Objects\"];\n\t    NSLog(@\"self.stringProperty = %@\", [self stringProperty]); //运行ok\n\t};\nmyBlock();\n}}  \n@end  \n```\n\n\n\n\n\n","mtime":1379221447000,"source":"_posts/ios22.md"},"yr4bl7d9d2til00u":{"_id":"yr4bl7d9d2til00u","content":"title:  在Finder标题栏上显示完整路径\ndate: 2013-09-02 09:57:17\ntags: [技术]\ncategories: [ios, mac]\n---\n打开终端，输入以下命令并回车：\n\n\tdefaults write com.apple.finder _FXShowPosixPathInTitle -bool YES\n\n然后再把finder关了再打开，你会发现路径栏变成这个样子了：\n","mtime":1378087321000,"source":"_posts/ios21.md"},"1u9jl4gm5cfxcymp":{"_id":"1u9jl4gm5cfxcymp","content":"title: 如何得到中英文混合下的NSString的长度?\ndate: 2013-09-02 09:21:21\ntags: [技术]\ncategories: ios\n---\n这个貌似很简单但却是把我跟招行的兄弟难为了好久,为毛?还不是因为招行信用卡中心的网络无法连接外网无法谷歌度娘最后我们只能查看文档写test\n下面是最后我们得到的两个方法\n<!-- more -->\n##方法一:\n\t- (int)getStringLength:(NSString*)strtemp\n\t{\n\n\tNSStringEncoding enc = CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);\n\n\t    NSData* da = [strtemp dataUsingEncoding:enc];\n\n\t    return [da length];\n\n\t}\n##方法二:\n\t- (int)convertToInt:(NSString*)strtemp\n\n\t{\n\n\t    int strlength = 0;\n\n\t    char* p = (char*)[strtemp cStringUsingEncoding:NSUnicodeStringEncoding];\n\n\t    for (int i=0 ; i<[strtemp lengthOfBytesUsingEncoding:NSUnicodeStringEncoding] ;i++) {\n\n\t        if (*p) {\n\n\t            p++;\n\n\t            strlength++;\n\n\t        }\n\n\t        else {\n\n\t            p++;\n\n\t        }\n\n\t        \n\n\t    }\n\n\t    return strlength;\n\n\t}\n\n","mtime":1378085239000,"source":"_posts/ios19.md"},"9htxoieisii2peul":{"_id":"9htxoieisii2peul","content":"title: ios笔记-- 多线程应该知道的那几件事 GCD NSThread NSOperation\ndate: 2013-09-14 13:58:20\ntags: [技术]\ncategories: ios\n---\n>iphone5s 出来了，CPU 升级到了64位 可以应用到更大的内存了，同时对多线程的处理吞吐能力也教之前提升了十几倍。下面着中总结下ios 下多线程的知识点\n<!-- more -->\n\n{% img left http://image.techweb.com.cn/edit/2013/0911/37841378870639.jpg 400 200 %}\n   \n\n##1：现有的几种多线程\n\n  概念 | 应用场景 | \n --- | --- | --- | \n NSThread | 苹果公司的Cocoa框架共支持三种多线程机制，分别为NSThread、GCD（Grand Central Dispatch）、Cocoa NSOperatio。NSThree是官方推荐的线程处理方式，它在处理机制上，需要开发者负责手动管理Thread的生命周期，包括子线程与主线程之间的同步等。线程共享同一应用程序的部分内存空间，它们拥有对数据相同的访问权限。你得协调多个线程 对同一数据的访问，一般做法是在访问之前加锁，这会导致一定的性能开销。在 iOS 中我们可以使用多种形式的 thread。 比其他两个轻量级 需要自己管理线程的生命周期，线程同步。 线程同步对数据的加锁会有一定的系统开销\n NSOperation | 如果需要让线程同时并行运行多个，可以将线程加入队列（Queue）中，NSOperationQueue类就是一个线程队列管理类，他提供了线程并行、队列的管理。可以认为NSOperationQueue就是一个线程管理器，通过addOperations方法，我们可以一次性把多个（数组形式）线程添加到队列中。同时，NSOperationQueue允许通过setMaxConcurrentOperationCount方法设置队列的并行（同一时间）运行数量  \n GCD | Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。该方法在Mac OS X 10.6雪豹中首次推出，并随后被引入到了iOS4.0中。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术，它看起来象就其它语言的闭包(Closure)一样，但苹果把它叫做blocks。\n\n一般移动平台上系统都会有一个专门的检查机制，看程序有没有很长时间被阻塞住，没有回来检查主消息队列。发现这种情况一般都是把程 序作为“无响应”干掉。iOS一般情况下是10秒为上限。10秒内程序没有回到主消息循环就被干掉。在前台后台切换时更严格，大概是5秒左右。[注释1](http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html)\n\n##2:简单的Demo\n因为GCD 是应用最广的 而且也是苹果现在极力鼓动开发者应用的 所以NSThread NSOperation 只做简单应用\n\n###1:NSThread\n\n###1.1 NSThread 有两种直接创建方式：\n\n第一个是实例方法--直接创建线程并且开始运行线程\n\t\n - (id)initWithTarget:(id)target selector:(SEL)selector object:(id)\n\n\n\n第二个是类方法--先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息\n\t\n + (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument\n\n\n*selector* :线程执行的方法，这个selector只能有一个参数，而且不能有返回值。   \n*target*  :selector消息发送的对象    \n*argument* :传输给target的唯一参数，也可以是nil    \n\n###1.2线程间通信\n\na 在应用程序主线程中做事情： \n\n```\nperformSelectorOnMainThread:withObject:waitUntilDone: performSelectorOnMainThread:withObject:waitUntilDone:modes:\n\n```\nb 在指定线程中做事情：\n```\nperformSelector:onThread:withObject:waitUntilDone: performSelector:onThread:withObject:waitUntilDone:modes:\n```\nc 在当前线程中做事情：\n```\nperformSelector:withObject:afterDelay:\nperformSelector:withObject:afterDelay:inModes:\n```\nd 取消发送给当前线程的某个消息\n\n```\ncancelPreviousPerformRequestsWithTarget: \ncancelPreviousPerformRequestsWithTarget:selector:object: \n```\n\n\n\n###2:NSOperation\n\n首先是建立NSOperationQueue和NSOperations。NSOperationQueue会建立一个线程管理器，每个加入到线程operation会有序的执行。  \n\n```\n\nNSOperationQueue *queue = [NSOperationQueue new];\nNSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doWork:) object:someObject]; \n[queue addObject:operation]; \n[operation release];\n\n```\n\n使用NSOperationQueue的过程：  \n    1.  建立一个NSOperationQueue的对象  \n    2.  建立一个NSOperation的对象  \n    3.  将operation加入到NSOperationQueue中  \n    4.  release掉operation  \n\nNSInvocationOperation，NSInvocationOperation是NSOperation的子类，允许运行在operation中的targer和selector\n\n###3：多线程互斥同步问题 \n[注释2](http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html)\n\n在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：\n\n* 方法一，@synchronized(id anObject),(最简单的方法)\n会自动对参数对象加锁，保证临界区内的代码线程安全\n\n```\n@synchronized(self) {\n        // 这段代码对其他 @synchronized(self) 都是互斥的\n        // self 指向同一个对象\n}\n\n```\n* 方法二，NSLock\n\nNSLock对象实现了NSLocking protocol，包含几个方法：\nlock，加锁\nunlock，解锁\ntryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO\nlockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO\n比如\n：\n\tNSLock *theLock = [[NSLock alloc] init]; \n\n\tif ([theLock lock]) {\n\n\t//do something here\n\n\t[theLock unlock]; \n\n\t} \n\n* 方法三，NSRecursiveLock，递归锁\n\nNSRecursiveLock，多次调用不会阻塞已获取该锁的线程。\n\n\n\tNSRecursiveLock *theLock = [[NSRecursiveLock alloc] init]; \n\tvoid MyRecursiveFunction(int value) { \n\t    [theLock lock]; \n\t    if (value != 0) { \n\t        –value; \n\t        MyRecursiveFunction(value); \n\t    }\n\t    [theLock unlock]; \n\t} \n\tMyRecursiveFunction(5);\n\n\n* 方法四，NSConditionLock，条件锁\n\nNSConditionLock，条件锁，可以设置条件\n\n\t//公共部分\n\tid condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA]; \n\n\t//线程一，生产者\n\twhile(true) { \n\n\t[condLock lockWhenCondition:NO_DATA]; \n\n\t//生产数据\n\t[condLock unlockWithCondition:HAS_DATA];\n\n\t}\n\n\t//线程二，消费者\n\twhile (true) { \n\n\t[condLock lockWhenCondition:HAS_DATA\n\n\t//消费\n\t[condLock unlockWithCondition:NO_DATA]; \n\t}\n\n\n* 方法五，NSDistributedLock，分布锁\n\nNSDistributedLock，分布锁，文件方式实现，可以跨进程\n用tryLock方法获取锁。\n用unlock方法释放锁。\n如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。\n\n**本章节(多线程互斥同步问题)参考自:http://blog.sina.com.cn/s/blog_72819b170101590n.html**\n\n##3:GCD多线程互斥同步问题(阻塞线程的方式去实现同步)\n\n\n[注释3](http://blog.devtang.com/blog/2012/02/22/use-gcd/)\n\n###1.串行队列 \n\n(1)GCD下的dispatch_queue队列都是FIFO队列,都会按照提交到队列的顺序执行.\n只是根据队列的性质,分为  \n<1>串行队列:用户队列、主线程队列 \n<2>并行队列. \n\n(2)同步(dispatch_sync)、异步方式(dispatch_async). 配合串行队列和并行队列使用.  \n同步队列直接提交两个任务就可以.\n// 串形队列\n    dispatch_queue_t serilQueue = dispatch_queue_create(\"com.quains.myQueue\", 0);\n    \n    //开始时间\n    NSDate *startTime = [NSDate date];\n    \n    \n    __block UIImage *image = nil;\n    \n    //1.先去网上下载图片\n    dispatch_async(serilQueue, ^{\n       //下载图片\n    });\n    \n    //2.在主线程展示到界面里\n    dispatch_async(serilQueue, ^{\n        \n        NSLog(@\"%@\",[NSThread currentThread]);\n        \n        // 在主线程展示\n        dispatch_async(dispatch_get_main_queue(), ^{\n          //显示图片\n    });\n    \n    //3.清理\n    dispatch_release(serilQueue);\n    [image release];\n\n**注意:**\n\n(1) __block变量分配在栈,retain下,防止被回收. \n\n(2)dispatch要手动create和release. \n\n(3)提交到主线程队列的时候,慎用同步dispatch_sync方法,有可能造成死锁.  因为主线程队列是串行队列,要等队列里的任务一个一个执行.所以提交一个任务到队列,如果用同步方法就会阻塞住主线程,而主线程又要等主线程队列里的任务都执行完才能执行那个刚提交的,所以主线程队列里还有其他的任务的话,但他已经被阻塞住了,没法先完成队列里的其他任务,即,最后一个任务也没机会执行到,于是造成死锁.\n\n(4)提交到串行队列可以用同步方式,也可以用异步方式. \n\n\n###2.并行队列\n采用并行队列的时候,可以采用同步的方式把任务提交到队列里去,即可以实现同步的方式\n\n//新建一个队列\n    dispatch_queue_t concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    \n    //记时\n    NSDate *startTime = [NSDate date];\n    \n    //加入队列\n    dispatch_async(concurrentQueue, ^{\n        __block UIImage *image = nil;\n        \n        //1.先去网上下载图片\n        dispatch_sync(concurrentQueue, ^{\n            //下载图片\n        });\n        \n        //2.在主线程展示到界面里\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            //显示图片\n        });\n    });\n\n两个同步的任务用一个异步的包起来,提交到并行队列里去,即可实现同步的方式.\n\n###3.使用分组方式\n\ngroup本身是将几个有关联的任务组合起来,然后提供给开发者一个知道这个group结束的点.\n虽然这个只有一个任务,但是可以利用group的结束点,去阻塞线程,从而来实现同步方式.\n\n例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用dispatch_group, dispatch_group_async 和 dispatch_group_notify来实现，示例如下：\n```\n dispatch_group_t group = dispatch_group_create();\n dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{\n      // 并行执行的线程一\n });\n dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{\n      // 并行执行的线程二\n });\n dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^{\n      // 汇总结果\n });\n```\n\n\tdispatch_group_t group = dispatch_group_create();\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    NSDate *startTime = [NSDate date];\n    \n    __block UIImage *image = nil;\n    \n    dispatch_group_async(group, queue, ^{\n        //1.先去网上下载图片\n        });\n    \n    // 2.等下载好了再在刷新主线程\n    dispatch_group_notify(group, queue, ^{\n        \n        //在主线程展示到界面里\n        dispatch_async(dispatch_get_main_queue(), ^{\n         //显示图片\n        });\n        \n    });\n    \n    // 释放掉\n    dispatch_release(group);\n\ndispatch_group 也要手动创建和释放.\ndispatch_notify()提供了一个知道group什么时候结束的点. 当然也可以使用dispatch_wait()去阻塞\n\n###4.信号量\n信号量 和 琐 的作用差不多,可以用来实现同步的方式. \n但是信号量通常用在 允许几个线程同时访问一个资源,通过信号量来控制访问的线程个数.\n\n// 信号量初始化为1\n    dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);\n    \n    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);\n    \n    NSDate *startTime = [NSDate date];\n    \n    __block UIImage *image = nil;\n    \n    \n    //1.先去网上下载图片\n    dispatch_async(queue, ^{\n        \n        // wait操作-1\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        // 开始下载\n        // signal操作+1\n        dispatch_semaphore_signal(semaphore);\n    });\n    \n  \n    // 2.等下载好了再在刷新主线程\n    dispatch_async(dispatch_get_main_queue(), ^{\n        \n        // wait操作-1\n        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n        //显示图片\n        // signal操作+1\n        dispatch_semaphore_signal(semaphore);\n    });\n\ndispatch_wait会阻塞线程并且检测信号量的值,直到信号量值大于0才会开始往下执行,同时对信号量执行-1操作.  \ndispatch_signal则是+1操作.\n\n###3.后台运行\n\nGCD的另一个用处是可以让程序在后台较长久的运行。在没有使用GCD时，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是在使用GCD后，app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。\n\n让程序在后台长久运行的示例代码如下：\n\n```\n// AppDelegate.h文件\n@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;\n\n// AppDelegate.m文件\n- (void)applicationDidEnterBackground:(UIApplication *)application\n{\n    [self beingBackgroundUpdateTask];\n    // 在这里加上你需要长久运行的代码\n    [self endBackgroundUpdateTask];\n}\n\n- (void)beingBackgroundUpdateTask\n{\n    self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{\n        [self endBackgroundUpdateTask];\n    }];\n}\n\n- (void)endBackgroundUpdateTask\n{\n    [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask];\n    self.backgroundUpdateTask = UIBackgroundTaskInvalid;\n}\n\n```\n\n\n----\n\n[1] http://www.cnblogs.com/linyawen/archive/2012/07/24/2606709.html\n\n[2] http://www.cnblogs.com/Quains/archive/2013/07/10/3182823.html\n\n[3] http://blog.devtang.com/blog/2012/02/22/use-gcd/\n\n\n\n\n\n\n\n","mtime":1379221447000,"source":"_posts/ios23.md"},"ebp4808ot8i4wr5n":{"_id":"ebp4808ot8i4wr5n","content":"title: What is the difference between Category and Class Extension?\ndate: 2013-09-15 13:39:07\ntags: [技术]\ncategories: ios\n---\n细心的人会发现当我们new 一个文件的时候会发现下图的部分.\n{% img http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8n5s8yocrj20km0e1766.jpg 400 300%}\n但是这个问题来了Category 和 Extension 就近又什么区别呢?\n<!-- more -->\n\n##1:什么是Category?\n实现这样一种场景,当我们用我们用NSArray的时候经常会遇到要去重的操作,可是自带的NSArray并没有这个方法,想要用你第一印象是自己写个类继承他,OC 给我们提供了一个方法可以直接在原有的基础上进行扩展.这就Category.分类能够做到的事情主要是：即使在你不知道一个类的源码情况下，向这个类添加扩展的方法。一个类可以有n+个分类,这些分类的实现可以在不同的文件中.\n\n下面是我写的一个分类\n\nNSArray+Unique.h\n\n\t@interface NSArray (Unique)\n\t- (NSArray *) uniqueMembers;\n\t- (NSArray *) unionWithArray: (NSArray *) array;\n\t@end\n\nNSArray+Unique.m\n\n\t@implementation NSArray (Unique)\n\t- (NSArray *) uniqueMembers\n\t{\n\t    NSMutableArray *copy = [self mutableCopy];\n\t    for (id object in self)\n\t    {\n\t        [copy removeObjectIdenticalTo:object];\n\t        [copy addObject:object];\n\t    }\n\t    return [copy autorelease];\n\t}\n\n\t- (NSArray *) unionWithArray: (NSArray *) anArray\n\t{\n\t    if (!anArray) return self;\n\t    return [[self arrayByAddingObjectsFromArray:anArray] uniqueMembers];\n\t}\n\n\t@end\n\n是不是很简单.但是应用Category还有如下\n\n###需要注意的问题：\n\n1. Category可以访问原始类的实例变量，但不能添加实例变量，如果想添加变量，那就通过继承创建子类来实现。  \n \n2. Category的优先级要高,当类中的方法跟原使类中的方法重名的时候是会重载原始类的方法. \n\n3. 和普通接口有所区别的是，在Category的实现文件中的实例方法只要你不去调用它你可以不用实现所有声明的所有方法。\n\n4. 不要在Category 调用 Super方法\n\n\n##2:什么是 Extension\n 扩展(Extension)人们往往以为就是匿名分类,因为他的语法看起来很像\n\n下面是一个Extension\n\n\t@interface ExtensionClass : NSObject  \n\t@property (retain, readonly) float value;\n\t@end  \n\t   \n\t   \n\t@interface ExtensionClass () { //注意此处：扩展  \n\t      \n\t}  \n\t@property (retain, readwrite) float value; \n\t- (void)setValue:(float)newValue;  \n\t@end  \n\t   \n\t@implementation ExtensionClass  \n\t   \n\t- (float)value {  \n\t    return value;  \n\t}  \n\t   \n\t- (void)setValue:(float)newValue {  \n\t    value = newValue;  \n\t}  \n\t   \n\t@end \n\n**虽然它们的语法的确很相似。虽然都可以用来为一个现有的类添加方法和属性，但它们的目的和行为却是不同的。**\n\n##Class extensions注意事项:\n\n1. 可以定义属性(实例变量)\n\n2. 在公共接口(类的声明中)中,开发者可以声明一个属性(实例变量)是只读的,随后在类扩展中声明为可写。这样，对外部代码而言,该属性(实例变量)将是只读的,而内部代码却可以使用它setter方法。\n\n3. 分类必须在第一个@interface中声明方法，并且在@implementation中提供实现，不然运行时出错。而类扩展的声明可以不在第一个@interface中去声明\n\n","mtime":1379226066000,"source":"_posts/ios24.md"},"6sp49vdwu60rre5h":{"_id":"6sp49vdwu60rre5h","content":"title: 阿里IOS面试题之多线程选用NSOperation or GCD\ndate: 2013-09-18 13:31:04\ntags: [技术]\ncategories: ios\n---\n今天早上接到了阿里从杭州打过来的电话面试.虽然近期面试了一些大中型的互联网企业,但是跟素有\"IT界的黄浦军校\"的阿里面试官接触还是不免紧张.\n<!-- more -->\n面试持续了三四十分钟吧,期间我手机信号不好挂断了一次,大部分问题都是更加简历上的项目经验而来的,个人感觉问的不算太难但是却很深入,很明显不是能够背几道面试题能够搞定的.而且每个题基本上都跟优化设计和性能相关.\n\n其中有一道是关于是问\"你平时上国外的一些网站吗?上那些网站呢?\"\n\n我平时大部分时间就是上stackoverflow.和cocoscontrol github 还有apple 的dev论坛.\n\n\"你们项目中为什么多线程用GCD 而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?\"\n\n一下子把我问懵了.我之所以用GCD 是因为GCD用起来比较简单.代码不用分散 比较集中维护度比较高.而且代码的执行效率也要比NSOperation快些. 但是至于国外的大牛们为什么那样做 我还真的不清楚. 后来挂完电话 正好搜狐的家明哥打电话过来 我问了下他.家明哥跟我说他包括他之前在新浪做项目时也是能用GCD的地方就用GCD 尽量减少NSOperation的使用,因为GCD在多核CPU上线程切换的时间比较短 效率相对高些,至于阿里为什么那样,可能每个公司对某个技术有着不同的理解吧.\n\n跟明哥挂了电话 我给对方回过去,到底为什么? 对方笑着问我:\"你用GCD在ASI上封装的那层网络请求 为什么后来有创建了自己的一个队列对维护这些请求?NSOperation是建立在GCD之上的 虽然使用起来比较复杂 但是在线程并发管理 优先级 上有着GCD 无法比拟的优势.\"\n\n但是对我来说 我还是倾向于用GCD,正如家明说的 每个公司对相同的技术有着不同的理解吧.\n","mtime":1379485951000,"source":"_posts/ios26.md"},"s6rpcqkqhnmv9qa2":{"_id":"s6rpcqkqhnmv9qa2","content":"title: ios开发之MPNowPlayingInfoCenter 锁屏显示正在播放的音乐\ndate: 2013-09-18 23:43:50\ntags: [技术]\ncategories: ios\n---\n今天在床上玩唱吧,听着歌锁屏了,当点亮屏幕的时候,锁屏页面出现了我正在听得歌曲 壁纸也换成了唱吧里面的歌手图片.做ios好几年了,从没有做过这个需求 于是好奇就翻看ios的[API文档](https://developer.apple.com/library/ios/documentation/mediaplayer/reference/MPNowPlayingInfoCenter_Class/Reference/Reference.html)找到了这个类.\n<!-- more -->\n如下图\n{%img http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8r3az0tbaj20g50litai.jpg 300 600%}\n   \n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8r3b00x7aj20gj05wq3e.jpg 300 200%}\n\n\n##MPNowPlayingInfoCenter 解释\n\n>即时播放中心能够用于播放APP中正在播放的媒体信息.\n播放的信息会显示在锁屏页面和多任务管理页面.如果用户是用airplay播放的话 会自动投射到相应的设备上.\n\n[下载源码](https://github.com/hufeng825/LockScreenInfo.git)\n\n\n##开始动手\n### 让App支持后台运行\n先创建工程,因为是audio 类型的app 需要支持后台播放 所以得要在plist 中声明属性.\n添加如下属性\n\nRequired background modes -> App plays audio\n如下图\n\n{%img left http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8r45ojlcuj20l80a2q4l.jpg 300 400 %}\n\n### 添加播放的Frame\n\n1. AVFoundation.framework\n2. MediaPlayer.framework\n\n{%img left http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8r4757worj208c03vq2z.jpg 300 400 %}\n\n\n### 开始代码吧\n \n首先创建一个ViewController 和一个用于播放的按钮 playButton\n\n\n\t@interface ViewController : UIViewController {\n\t \n\tIBOutlet UIButton *playButton;\n\t \n\t}\n\t \n\t@property (nonatomic, retain) IBOutlet UIButton *playButton;\n\t \n\t-(IBAction)playButtonPress:(id)sender;\n\n\n加入播放用的控件audioPlayer 和其相应的头文件\n\n\t#import <MediaPlayer/MPNowPlayingInfoCenter.h>\n\t#import <MediaPlayer/MPMediaItem.h>\n\t#import <AVFoundation/AVFoundation.h>\n\tMPMoviePlayerController *audioPlayer;\n\n\t@property (nonatomic, retain) MPMoviePlayerController *audioPlayer;\n\n\t@synthesize playButton, audioPlayer;\n\n\n在viewDidLoad 中 我们要把AudioPlayer 进行初始化 此处加载网络上的一首音频\n\n\t[[AVAudioSession sharedInstance] setDelegate: self];\n\t \n\tNSError *myErr;\n \n\t// Initialize the AVAudioSession here.\n\tif (![[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback error:&myErr]) {\n\t    // Handle the error here.\n\t    NSLog(@\"Audio Session error %@, %@\", myErr, [myErr userInfo]);\n\t}\n\telse{\n\t    // Since there were no errors initializing the session, we'll allow begin receiving remote control events\n\t    [[UIApplication sharedApplication] beginReceivingRemoteControlEvents];\n\t}\n\t \n\t    //initialize our audio player\n\t    audioPlayer = [[MPMoviePlayerController alloc] initWithContentURL:[NSURL URLWithString:@\"http://www.cocoanetics.com/files/Cocoanetics_031.mp3\"]];\n\t     \n\t    [audioPlayer setShouldAutoplay:NO];\n\t    [audioPlayer setControlStyle: MPMovieControlStyleEmbedded];\n\t    audioPlayer.view.hidden = YES;\n\t     \n\t    [audioPlayer prepareToPlay];\n\n点击按钮开始播放,注意因为MPNowPlayingInfoCenter只支持5.0+ 所以为了防止低版本使用 巧妙的应用了NSClassFromString进行了判断\n\n\t- (IBAction)playButtonPress:(id)sender {\n\t     \n\t    [audioPlayer play];\n\t     \n\t    Class playingInfoCenter = NSClassFromString(@\"MPNowPlayingInfoCenter\");\n\t     \n\t    if (playingInfoCenter) {\n\t \n\t         \n\t        NSMutableDictionary *songInfo = [ [NSMutableDictionary alloc] init];\n\t         \n\t        \n\t        MPMediaItemArtwork *albumArt = [ [MPMediaItemArtwork alloc] initWithImage: [UIImage imagedNamed:@\"AlbumArt\"] ];\n\t         \n\t        [ songInfo setObject: @\"Audio Title\" forKey:MPMediaItemPropertyTitle ];\n\t        [ songInfo setObject: @\"Audio Author\" forKey:MPMediaItemPropertyArtist ];\n\t        [ songInfo setObject: @\"Audio Album\" forKey:MPMediaItemPropertyAlbumTitle ];\n\t        [ songInfo setObject: albumArt forKey:MPMediaItemPropertyArtwork ];\n\t        [ [MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:songInfo ];\n\t    }\n\t}\n\n---\n[参考 http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/](http://jaysonlane.net/tech-blog/2012/04/lock-screen-now-playing-with-mpnowplayinginfocenter/)\n\n\n\n\n\n","mtime":1379525636000,"source":"_posts/ios28.md"},"gyrznydkh83xgint":{"_id":"gyrznydkh83xgint","content":"title: 再谈涉及模式\ndate: 2013-09-17 23:09:18\ntags: [技术]\ncategories: ios\n---\n某某曰:设计模式这东西,没有好坏之分，只有合适于不合适\n<!-- more -->\n\n今天去面试很有意思,技术考官指着最后一道二选一的编程题说,这是昨天晚上专门为你新加的.当时我听后倍感惭愧. 虽然当时在纸上把大概思路和设计说了下.为了感谢主考官的重视程度.我现在也亲自在电脑上把这个设计实现出来.\n题目大概是这个意思: 一个咖啡店卖好几种咖啡:摩卡,布列夫,拿铁等等  咖啡有很多搭配:方糖,鲜牛奶,奶油,盐等. 试设计计算出咖啡(+搭配)的单价模型.\n\n\n下面来谈谈我的想法\n\n##一:虚基类 Coffee\n首先 我抽象出了一个虚基类 Coffee, 什么摩卡 布列夫 拿铁都继承这个类\n\n这个类包含什么呢\n{\n. 咖啡的单价(不含 方糖 奶等 调味料) -->price\n. 一个存放调味料的容器 -->ecoratorRelishChain\n. 一个可以得到总价的方法 --> getTotalPrices\n}\n\n下面是代码\n\n基类咖啡.h\n\n\t //abstract 咖啡基类\n\t @class DecoratorChain;\n\n\t @interface  Coffee: NSObject\n\t @property ( nonatomic,strong ) DecoratorChain *ecoratorRelishChain;//用来存储 奶 方糖 等等的调料 可以把它想象成一个调味盒 \n\t @property ( nonatomic,strong ) NSDecimalNumber *price;//单价 不含配料\n\n\t -(NSDecimalNumber *) getTotalPrices;//得到总价\n\n\t @end\n\n基类咖啡.m\n\n\t@interface Coffee()\n\t@property(nonatomic,strong) NSString * _coffeeName;\n\t@end\n\n\t@implementation Coffee\n\n\t@synthesize _coffeeName,price,ecoratorRelishChain;\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        _coffeeName=@\"咖啡名称\";\n\t        price = [[NSDecimalNumber alloc] initWithString:@\"20\"];\n\t    }\n\t    return self;\n\t}\n\n\t-(NSDecimalNumber *)getTotalPrices\n\t{\n\t    \n\t    return [self.price decimalNumberByAdding: [ecoratorRelishChain getCountPrice]];\n\t}\n\n\t@end\n\n\n------\n\n##二: 虚基类 EcoratorRelish\n  \nEcoratorRelish 是 方糖 奶油  牛奶 盐 等等的抽象类 这个继承在button  点击的时候 可以自动将自己加入到chain (调料盘中)\n\n这个类包含什么呢\n{\n. 自身的单价 -->price\n. 可以修改价钱的策略 --> configPrivilege\n}\n\n方糖 等抽象出来的基类EcoratorRelish.h\n\n\t@interface  EcoratorRelish: UIButton\n\t@property(nonatomic,strong)  NSDecimalNumber *price;//单价 \n\t//Overload\n\t-(void)configPrivilege;//可以配置优惠策略\n\t-(DecoratorChain *)getComponentCoffee;\n\t@end\n\nEcoratorRelish.m\n\n\n\t@implementation  EcoratorRelish\n\t@synthesize  price;\n\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        [self addTarget:self action:@selector(addDecoratorChain) forControlEvents:UIControlEventTouchUpInside];\n\t    }\n\t    return self;\n\t}\n\t//Overload\n\t-(void)configPrivilege\n\t{\n\t    //可以配置优惠策略 \n\t}\n\n\t//获取当前的辅料坐在的ViewController\n\t- (UIViewController *)getViewController {\n\t    Class vcc = [UIViewController class];\n\t    UIResponder *responder = self;\n\t    while ((responder = [responder nextResponder]))\n\t        if ([responder isKindOfClass: vcc])\n\t            return (UIViewController *)responder;\n\t    return nil;\n\t}\n\n\t//获取要装饰的咖啡的调味盒(chain)\n\t-(DecoratorChain *)getEcoratorRelishChain\n\t{\n\t   return  [self getViewController].coffee.ecoratorRelishChain;\n\t}\n\n\t//将自己加到咖啡的调味盒(chain)\n\t-(void)addDecoratorChain\n\t{\n\t    [[self getEcoratorRelishChain] addDecoratorRelish:self];\n\t}\n\n\t@end\n\n------\n\n##三: 调料盒 DecoratorChain\n\nDecoratorChain.h\n\n\t//用于保存配料的chain\n\t@interface  DecoratorChain: NSMutableArray\n\t-(void)addDecoratorRelish:(EcoratorRelish*)ecoratorRelish;\n\t@end\n\n\nDecoratorChain.m\n\n\t@interface DecoratorChain()\n\t@property(nonatomic,strong) NSDecimalNumber * _countPrice;\n\t@end\n\n\t@implementation DecoratorChain\n\t@synthesize _countPrice;\n\n\t- (id)init\n\t{\n\t    self = [super init];\n\t    if (self) {\n\t        _countPrice = [[NSDecimalNumber alloc]init];\n\t    }\n\t    return self;\n\t}\n\n\t-(void)addDecoratorRelish:(EcoratorRelish*)ecoratorRelish\n\t{\n\t    [self addObject:ecoratorRelish];\n\t}\n\n\t//得到当前所有chain 里面的总价\n\t-(NSDecimalNumber*)getCountPrice\n\t{\n\t    for (EcoratorRelish *tmp  in self ) {\n\t        [_countPrice decimalNumberByAdding:tmp.price];\n\t    }\n\t    return _countPrice;\n\t}\n\n\t@end\n\n下面的实现代码大家应该都会写了吧. 其实回头看下 中间应用到的设计模式 最明显的是 装饰 和 组合 策略\n","mtime":1379437605000,"source":"_posts/ios25.md"},"qwg3e8jiwak1bymm":{"_id":"qwg3e8jiwak1bymm","content":"title: ios7之Sprite Kit vs Cocos2D\ndate: 2013-09-22 19:50:03\ntags: [技术]\ncategories: ios\n---\n>Xcode5正式版发布了，全新的ui当然带来了全新的功能。今天阿峰就给大家来介绍下Sprite Kit。\n\n{%img center 500 400 http://ww1.sinaimg.cn/mw690/a43af4ffjw1e8vnf9f1k4j20jt0d3abu.jpg %}\n\n<!-- more --> \n\n##一、什么是Sprite Kit\n\n打开app store 下载最多的的是2D 游戏。比较有名比如 愤怒的小鸟 割绳子啦。 这些游戏之所以能够如此受欢迎跟他们 出色的粒子特效 物理引擎 炫酷的动画 还有漂亮的界面和声音效果离不开。\n\n在ios7 发布之前 想要做出这样的游戏 只能依靠第三方的游戏引擎库，比较有名的就是Cocos2d 以及衍生的Cocos2d-X。现在ios7发布了 我们可以不借助第三方工具就可以实现了。Sprite Kit 提供了 包括 动画精灵，形状，粒子（火焰，烟雾），动画，物理效果，音频 视频等。Xcode5 还提供支持了纹理包和粒子设计哦。\n\nSprite Kit 可以在逻辑上分为以下的三个部分\n\n###Scenes(场景) \n\n在cocos2d的游戏场景的视觉层。他提供了物体（如树木，汽车，飞机，头像等）的背景。\n\n###Actions(动作)\n\n流畅的动画是游戏的重要组成部分。苹果设计的Actions非常简洁。他可以让你实现你想要做的任何事情。比如说一些常见的动作:移动 淡入淡出 缩放 旋转 动画纹理 组动画等等。 如果这些你还不满足，你可以自己创建一个代码块来实现自己想要的动作来操控对象。\n\n###Physics(物理引擎)\n\n你想让你一个游戏具有很强的现实感，那物理引擎你一定用的到。 不然射出的子弹永远不会落地，橡胶球落地不会弹起来哈。\n\n---\n\n##二、选择Sprite Kit的理由\n\n###性能\n\n苹果自家推出的东西在自家平台上肯定有着得天独厚的优势（尽管很多游戏开发商需要让他们的游戏在不同的系统上运行）。但是苹果在系统和硬件上累计的经验足够说服开发商选用自家的游戏引擎了。\n\n###平台集成\n\n如上所述。Sprite Kit 跟Xcode 5 集成的天衣无缝。Xcode5 为游戏提供了很多开发组件。\n\n\n###版本升级\n\n使用第三方库或者游戏引擎编写游戏肯定会有这方面的担忧。我们永远不知道将来的对系统的兼容性如何。不如说已死的Tree20 等等。 ios 每出一个版本都会有API的变动。虽然会有开源社区对其第三方库进行维护 但是这需要时间哈。用苹果自家的东西 就不用担心这方面了。\n\n随着Sprite Kit的退出。苹果已经提供了一套工具，以确保开发的游戏代码能够在任何苹果版本和机型正常运行。 注意的是Sprite Kit 并不只是ios的框架。 开发人员也可以来开发OS X 上的游戏。\n\n###友好的开发接口\n\ncocos2d之所以成功离不开其较低的门槛。相比起OpenGL ES 那些晦涩的接口 恼人的实现来说cocos2d ,简直太方便了。\n\nSprite Kit遵循了这点。其提供的接口非常简洁方便。另外其文档也非常详细 设计工具也很棒。甚至连cocos2d的首席开发工程师也在”此处和谐 国外被墙聊天工具“上感慨说\n>prite Kit is very good. With less features than Cocos2D, but better. I like the physics integration.\n\n---\n\n##三、Sprite Kit & Cocos2D Features\n\n\n特性  | Sprite Kit | Cocos2D\n--- | --- | ---\nOpen Source | `No` | Yes\nObjective-C  Native Support\t| Yes |\tYes\nGraphics Engine\t| Yes |\tYes\nAnimations\t| Yes |\tYes\nPhysics Simulation\t | Yes (Integrated) |\t`No (Requires Box2D or Chipmunk)`\nParticle Effects | Yes | Yes\nXcode Native Integration | Yes\t| `No`\nAutomatic Atlas Creation | Yes | `No`\nBuilt-In Particle Editor | Yes | `No`\nShaders\t| `No` | Yes\nCamera | `No` | Yes\n\n\n---\n\n##四、项目对比\n\n对比 Sprite Kit  和  Cocos2D 区别 还是看代码比较合适\n[Sprite Kit 工程](http://cdn.tutsplus.com/mobile.tutsplus.com/uploads/2013/09/ios7SpriteKit.zip)\n[Cocos2D 工程](http://cdn.tutsplus.com/mobile.tutsplus.com/uploads/2013/09/ios7cocos2d.zip)\n\n##五、代码比较\n\n下面我们将从概念上来比较两者的不同\n\n###CClayer vs. SKScene\n\nCCLayer或SkScene 是最主要的对象用来绘制其他的对象。 你可以把他想象成默认的一个view，这个view 可以接收所有的对象，动画或者touch 事件。\n\n在Cocos2d进行场景切换 需要下面几步：\n\n\tGameScene* gameScene = [[GameScene alloc] init];\n\t[ [CCDirector sharedDirector] replaceScene:gameScene ];\n\n注意GameScene.h 中 必须继承CCLayer 且初始化一个CCScene\n\n\t@interface GameScene : CCLayer {}\n\t+(CCScene *) scene;\n\n在 GameScene.m, 初始化:\n\n\t+(CCScene *)scene\n\t{\n\t    CCScene *scene = [CCScene node];\n\t    GameScene *layer = [GameScene node];\n\t    [scene addChild: layer];\n\t    return scene;\n\t}\n\t-(id) init{\n\t    if( (self=[super init] )) {\n\t        // Your code here\n\t    }\n\t    return self;\n\t}\n\n在 Sprite Kit 中只需要如下\n \n\tGameScene* gameScene = [ [GameScene alloc] initWithSize:CGSizeMake(1024, 768) ];\n\t[ self.scene.view presentScene:gameScene ];\n\t}\n\nGameScene 必须继承 SKScene , 调用如下 -(id)initWithSize:(CGSize)size 初始化:\n\n\t-(id)initWithSize:(CGSize)size\n\t{\n\t    if (self = [super initWithSize:size])\n\t    {\n\t        // Your code\n\t    }\n\t    return self;\n\t}\n\n###CCSprite vs. SKSpriteNode\n\n精灵对象通常用来显示某种图形。他有如下几种属性：旋转 缩放 位移 框架 等等。Cocos2D 实现如下：\n\n\tCCSprite* aSprite;\n\taSprite = [CCSprite spriteWithFile:@\"player.png\"];\n\taSprite.scale = .5;\n\taSprite.position = ccp(_size.width/1.30, _size.height/1.25);\n\t[self addChild:aSprite];\n\nSprite Kit 实现如下：\n\n\tSKSpriteNode* planeShadow = [SKSpriteNode spriteNodeWithImageNamed:@\"player.png\"];\n\tplaneShadow.scale = 0.5;\n\tplaneShadow.position = CGPointMake(CGRectGetMidX(self.frame)+100,CGRectGetMidY(self.frame)+200);\n\t[self addChild:planeShadow];\n\n###CCLabelTTF vs. SKLabelNode\n\nLabel对象用于显示文字。它可以有几个属性，包括文字，文字大小，文字颜色，位置等等。Cocos2D和Sprite Kit是相似的。\nCocos2D：\n\n\tCCLabelTTF *label = [CCLabelTTF labelWithString:@\"Hello World\" fontName:@\"Marker Felt\" fontSize:64];\n\t// ask director for the window size\n\tCGSize size = [[CCDirector sharedDirector] winSize];\n\tlabel.position =  ccp( size.width /2 , size.height/2 );\n\t[self addChild: label];\n\nSprite Kit:\n\n\tSKLabelNode* gameScene = [SKLabelNode labelNodeWithFontNamed:@\"Chalkduster\"];\n\t[gameScene setText:@\"New Game\"];\n\t[gameScene setFontSize:18];\n\tgameScene setPosition:CGPointMake(CGRectGetMidX(self.frame)+5,CGRectGetMidY(self.frame)-40)];\n\t[self addChild:gameScene];\n\n###CCMenu and CCMenuItem vs. Sprite Kit Menu\n\nCocos2D中创建菜单需要两个对象：CCMenu 和 CCMenuItem. 下面是创建两个菜单项的例子\n\n\tCGSize size = [[CCDirector sharedDirector] winSize];\n\t[CCMenuItemFont setFontSize:28];\n\tCCMenuItem *itemNewGame = [CCMenuItemFont itemWithString:@\"New Game\" block:^(id sender) {\n\t    // Your code\n\t}];\n\tCCMenuItem *itemOptions = [CCMenuItemFont itemWithString:@\"Options\" block:^(id sender) {\n\t    NSLog(@\"Second item\");\n\t}];\n\tCCMenu *menu = [CCMenu menuWithItems:itemNewGame, itemOptions, nil];\n\t[menu alignItemsHorizontallyWithPadding:20];\n\t[menu setPosition:ccp( size.width/2, size.height/2 - 50)];\n\t[self addChild:menu];\nSpite Kit不包括任何类型的菜单的特定对象。\n下面的例子我们用了 SKLabelNode作为 menu item. 首先我们定义 SKLabelNode:\n\n\tSKLabelNode*  gameScene = [SKLabelNode labelNodeWithFontNamed:@\"Chalkduster\"];\n\t[gameScene setText:@\"New Game\"];\n\t[gameScene setFontSize:18];\n\t[gameScene setPosition:CGPointMake(CGRectGetMidX(self.frame)+5,CGRectGetMidY(self.frame)-40)];\n\t[self addChild:gameScene];\n\n在 **-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event** 方法里面 我们创建截获事件\n\n\tfor (UITouch *touch in touches)\n\t{\n\t    CGPoint location = [touch locationInNode:self];\n\t    if ([gameScene containsPoint:location]) {\n\t        // Scene Transition Animation\n\t        SKTransition* reveal = [SKTransition revealWithDirection:SKTransitionDirectionDown duration:1];\n\t        GameScene* gameScene = [[GameScene alloc] initWithSize:CGSizeMake(1024, 768)];\n\t        [self.scene.view presentScene:gameScene transition:reveal];\n\t        NSLog(@\"Touched gameScene!!!!\");\n\t    }\n\t} \n上面代码做了下面几件事情\n\n1. 激活触摸时间\n2. 将敲击的坐标转换成内部坐标\n3. 验证敲击的坐标是否在SKLabelNode的动画场景内\n4. 创建过渡动画\n5. 转换场景\n\n###Action vs. SKAction\n区别最大的是Action 。SKAction是一个较复杂的对象。Action在Cocos2D 仅仅是一个动作。程序员必须定义 调用 创建。 \n但是Sprite Kit中，SKAction 提供了如下的开发比如旋转 缩放 重复, 消失 播放声音 等等。 SKaction是一个抽象类能够处理任何种类的动作。\n在cocos2d 我们需要定义一个调节调用的自定义方法\n\t[self schedule:@selector(addSprite:) interval:1];\n然后在自定义的方法中添加我们自定义的动画:\n\n\t- (void) addSprite:(ccTime)dt\n\t{\n\t    CCSprite* aMovableSprite = [CCSprite spriteWithFile:@\"frankenstein.png\"];\n\t    aMovableSprite.scale = .8;\n\t    [self addChild:aMovableSprite];\n\t    CGSize winSize = [CCDirector sharedDirector].winSize;\n\t    int minX = aMovableSprite.contentSize.width / 2;\n\t    int maxX = winSize.width - aMovableSprite.contentSize.width/2;\n\t    int rangeX = maxX - minX;\n\t    int actualY = (arc4random() % rangeX) + minX;\n\t    CCCallBlockN * actionMoveDone = [CCCallBlockN actionWithBlock:^(CCNode *node) {\n\t        NSLog(@\"Sprite free!\");\n\t    }];\n\t    NSMutableArray *arrayBezier = [[NSMutableArray alloc] init];\n\t    ccBezierConfig bezier;\n\t    id bezierAction1;\n\t    float splitDuration = 6 / 6.0;\n\t    for(int i = 0; i< 6; i++){\n\t        if(i % 2 == 0){\n\t            bezier.controlPoint_1 = ccp(actualY+100,winSize.height-(100+(i*200)));\n\t            bezier.controlPoint_2 = ccp(actualY+100,winSize.height-(100+(i*200)));\n\t            bezier.endPosition = ccp(actualY,winSize.height-(200+(i*200)));\n\t            bezierAction1 = [CCBezierTo actionWithDuration:splitDuration bezier:bezier];\n\t        }\n\t        else{\n\t            bezier.controlPoint_1 = ccp(actualY-100,winSize.height-(100+(i*200)));\n\t            bezier.controlPoint_2 = ccp(actualY-100,winSize.height-(100+(i*200)));\n\t            bezier.endPosition = ccp(actualY,winSize.height-(200+(i*200)));\n\t            bezierAction1 = [CCBezierTo actionWithDuration:splitDuration bezier:bezier];\n\t        }\n\t        [arrayBezier addObject:bezierAction1];\n\t    }\n\t    [arrayBezier addObject:actionMoveDone];\n\t    id seq = [CCSequence actionsWithArray:arrayBezier];\n\t    [aMovableSprite runAction:seq];\n\t}\n\n在Sprite Kit中 我们使用SKAction来控制对象开始和结束的运行状况\n\n\tSKSpriteNode* playerSprite = [SKSpriteNode spriteNodeWithImageNamed:@\"player.png\"];\n\t[playerSprite setScale:0.4];\n\tSKAction *movement =[SKAction moveTo:CGPointMake(900, 500) duration:5];\n\tSKAction *remove = [SKAction removeFromParent];\n\t[playerSprite runAction:[SKAction sequence:@[movement,remove]]];\n\t[self addChild:playerSprite];\n\n但是我们定义一个自定义的动画然后用SKAction来激活这个动作。下面的例子说明了贝塞尔运动。\n\n\tSKAction *wait = [SKAction waitForDuration:1];\n\tSKAction *callEnemies = [SKAction runBlock:^{\n\t    [self sendNewSKSpriteNode];\n\t}];\n\tSKAction *updateSKSpriteNodeOnScreen = [SKAction sequence:@[wait,callEnemies]];\n\t[self runAction:[SKAction repeatActionForever:updateSKSpriteNodeOnScreen]]; \n\n\n下面的sendNewSKSpriteNode将处理自定义对象的运动。\n\n\n\t-(void) sendNewSKSpriteNode{\n\t    CGRect screenRect = [[UIScreen mainScreen] bounds];\n\t    // Custom SKAction\n\t    SKSpriteNode* enemy = [SKSpriteNode spriteNodeWithImageNamed:@\"frankenstein.png\"];\n\t    enemy.scale = 0.6;\n\t    CGMutablePathRef cgpath = CGPathCreateMutable();\n\t    //random values\n\t    float xStart = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];\n\t    float xEnd = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];\n\t    //ControlPoint1\n\t    float cp1X = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];\n\t    float cp1Y = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.height ];\n\t    //ControlPoint2\n\t    float cp2X = [self getRandomNumberBetween:0+enemy.size.width to:screenRect.size.width-enemy.size.width ];\n\t    float cp2Y = [self getRandomNumberBetween:0 to:cp1Y];\n\t    CGPoint s = CGPointMake(xStart, 1024.0);\n\t    CGPoint e = CGPointMake(xEnd, -100.0);\n\t    CGPoint cp1 = CGPointMake(cp1X, cp1Y);\n\t    CGPoint cp2 = CGPointMake(cp2X, cp2Y);\n\t    CGPathMoveToPoint(cgpath,NULL, s.x, s.y);\n\t    CGPathAddCurveToPoint(cgpath, NULL, cp1.x, cp1.y, cp2.x, cp2.y, e.x, e.y);\n\t    SKAction *planeDestroy = [SKAction followPath:cgpath asOffset:NO orientToPath:YES duration:5];\n\t    [self addChild:enemy];\n\t    SKAction *remove2 = [SKAction removeFromParent];\n\t    [enemy runAction:[SKAction sequence:@[planeDestroy,remove2]]];\n\t    CGPathRelease(cgpath);\n\t}\n\n###CCParticleExplosion vs. Emitter\n\nCocos2D中并没例子编辑器。必须使用外部应用程序创建例子 然后用特定的 CCParticleExplosion来改变其属性行为。在xcode中 你可以这样子来使用了:\n\n\tCCParticleExplosion* _particleExplosion;\n\tparticleExplosion = [[CCParticleExplosion alloc] initWithTotalParticles:800];\n\tparticleExplosion.texture = [[CCTextureCache sharedTextureCache] addImage:@\"texture.png\"];\n\tparticleExplosion.life = 0.0f;\n\tparticleExplosion.lifeVar = 0.708f;\n\tparticleExplosion.startSize = 40;\n\tparticleExplosion.startSizeVar = 38;\n\tparticleExplosion.endSize = 14;\n\tparticleExplosion.endSizeVar = 0;\n\tparticleExplosion.angle = 360;\n\tparticleExplosion.angleVar = 360;\n\tparticleExplosion.speed = 243;\n\tparticleExplosion.speedVar = 1;\n\tCGPoint g = CGPointMake(1.15, 1.58);\n\tparticleExplosion.gravity = g;\n\tccColor4F startC =  {0.89f, 0.56f, 0.36f, 1.0f};\n\tparticleExplosion.startColor = startC;\n\tccColor4F endC = {1.0f,0.0f,0.0f,1.0f};\n\tparticleExplosion.endColor = endC;\n\t[self addChild:_particleExplosion];\n\tparticleExplosion.position = ccp(_size.width/5, _size.height/5);\n\t[particleExplosion resetSystem];\n\n发射器使用Sprite Kite粒子套件产生。 为了使用他们 你需要在项目中添加粒子。New -> File -> Resource -> Sprite Kit Particle File 命名并且选择粒子类型（火 烟 雪 等等）。\n如下图\n{%img  http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8vnfhjmlgj20en07a3yz.jpg 400 500 %}\n\n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e8vnflpm16j206o05ft8q.jpg 300 500  %}\n\n 现在你会看到有两个新文件在xcode 中：\n\n{%img 200 300 http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8vnls9m7bj203q018a9v.jpg%}\n  \n\n\tSKEmitterNode* smokeTrail;\n\tNSString *smokePath = [[NSBundle mainBundle] pathForResource:@\"MyParticle\" ofType:@\"sks\"];\n\tsmokeTrail = [NSKeyedUnarchiver unarchiveObjectWithFile:smokePath];\n\tsmokeTrail.position = CGPointMake(CGRectGetMidX(self.frame)+40,CGRectGetMidY(self.frame)-100);\n\t[self addChild:smokeTrail];\n\n###SimpleAudioEngine vs. Sprite Kit Sound\n\n任何游戏应该都离不开多媒体吧，在cocos2d 我们要实现 需要两部\n1：\n\t#import \"SimpleAudioEngine.h\"\n2：\n\n\t[[SimpleAudioEngine sharedEngine] playBackgroundMusic:@\"sound.caf\" loop:YES];\n\t[[SimpleAudioEngine sharedEngine] setEffectsVolume:0.4f];\n\n**有时，Xcode中并没有自动包括“Copy Bundle Resources”中的音乐文件。如果发生这种情况，你应该手动添加。**\n\n在Sprite Kit中 你能够很简单的添加声音\n\n\tSKAction* soundAction = [SKAction playSoundFileNamed:@\"preview.mp3\" waitForCompletion:NO];\n\t[self runAction:soundAction];\n\n下面是实现的一个火焰效果图\n{% img  http://ww4.sinaimg.cn/mw690/a43af4ffjw1e8vnfvcmmdj20d80k8jro.jpg 200 400 %}\n\n## 结束语\n\n通过上面的分析 你会发现cocos2d 和Sprite kit 有很多相似之处。在易用性上 笔者觉得Spring kit 对ios开发者来说更加具有诱惑性。\n\n\n","mtime":1379862110000,"source":"_posts/ios29.md"},"i3ppg7lh7k2nt817":{"_id":"i3ppg7lh7k2nt817","content":"title: ios 清理工程中没有用到的图片\ndate: 2013-08-29 16:43:14\ntags: [技术]\ncategories: \n- ios\n- mac\n---\n>发布前往往需要清理工程中没有用到的图片，这些图片可能是测试图片也可能是以往版本中替换遗留下来的图片\n\n<!-- more -->\n\n##使用方法\n1. 将下面代码保存成**.sh 然后chomd 777 使其可执行\n2. 将**.sh 拷贝到工程根目录下\n3. ./执行**.sh \n4.  再同级目录下会生成一个imge.txt 结果文件\n\n 如下图  \n\n{% img http://ww3.sinaimg.cn/mw690/a43af4ffjw1e83pb1zvo7j215q0pq7bz.jpg 300 500 %}\n\n##源码 \n\n```\n#!/bin/sh\n\necho \"删除有风险 下手需谨慎 如需再次确认图片是否被引用到\"\n\necho \"Defult.png 和例如[UIImage imageNamed:@‘img.png'] 可能会误报\"\n\n\nread -n1 -p  \"【Y】查阅如何确认 【N】直接进行图片检索\" \n\ncase $answer in \n\n\"Y\"|\"y\") \n\nopen -a Safari \"http://blog.csdn.net/hufeng825/article/details/8533647\"\n\necho -n \"按任意键开始程序\";\n\nread var\n\n;;\n\n\"N\"|\"n\") \n\necho \"命令执行时终端会输入结果 搜索完毕后 会在当前路径下自动生成imag.txt的结果报告\"\n\n;;\n\n*) \n\n;;\n\nesac\n\n\n\n\nPROJ=`find .  ! -name '*.xib' -o -name '*.[mh]' -o -name '*.storyboard' -o -name '*.mm' -o -name '*.html' `\n\n\necho \"~~~~~~~~~~~~开始搜索~~~~~~~~~~~~\" >>'./image.txt';\n\nfor png in `find . -name '*.png'`\ndo\n\n   name=`basename -s .png $png`\n   name=`basename -s @2x $name`\n   if ! grep -qhs \"$name\" \"$PROJ\"; then\n        echo \"$png 可能没引用\" \n        echo \"$png 可能没引用\"  >>'./image.txt' ;\n   fi\ndone\n\nfor jpg in `find . -name '*.jpg'`\ndo\n   name=`basename -s .jpg $jpg`\n   name=`basename -s @2x $name`\n   if ! grep -qhs \"$name\" \"$PROJ\"; then\n        echo \"$png 可能没引用\" \n        echo \"$jpg 可能没引用\"  >>'./image.txt';\n   fi\ndone\n\necho \"~~~~~~~~~~~~结束搜索~~~~~~~~~~~~\" >>'./image.txt';\n<<EOF\n\n```","mtime":1378826228000,"source":"_posts/ios3.md"},"y38fnbi78mhkd0jm":{"_id":"y38fnbi78mhkd0jm","content":"title: IOS 开发之 CocoaPods讲解\ndate: 2013-10-11 00:53:01\ntags: [技术]\ncategories: ios\n---\n## 什么是CocoaPods? \n\n看看你的项目吧,肯定会用到很多第三方的开源库,比如ASI,SBJson,MBProgressHUD等等.\n<!-- more -->\n\n比如下面这款APP\n\n{% img http://ww4.sinaimg.cn/mw690/a43af4ffjw1e9gkhrfkupj207g0bgdgc.jpg 200 300 %}\n\n  \n用到的库就包含如下这样多 \n   \n{% img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9gki1ovsqj205p09cgm3.jpg 200 300 %}\n\n随着你的工程越来越大,你引入的第三方的开源库可能会越来越多.这些依赖的开源库维护管理越久越来越困难.于是CocoaPods出现了,它可以帮助管理Xcode项目的依赖关系。(说到这做过java的同学应该想到了maven了吧).\n你可以定义一个非常简单的文本来管理配置这些依赖 .\n\n------\n\n##安装步骤\n\n###1.前期工作\n\n 因为CocoaPods是基于Ruby的 介于天朝的特殊国情,你如果直接gem install 安装的话 肯定会遇到问题的所以首先你需要吧你的源换下. 换成什么呢?还是感谢下阿里吧.阿里给我们搭建了一个RubyGems 镜像.\n\n>由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。所以你会与遇到 gem install rack 或 bundle install 的时候半天没有响应，具体可以用 gem install rails -V 来查看执行过程。\n这是一个完整 rubygems.org 镜像，你可以用此代替官方版本，同步频率目前为15分钟一次以保证尽量与官方服务同步。\n\n\t$ gem sources --remove https://rubygems.org/\n\t$ gem sources -a http://ruby.taobao.org/\n\t$ gem sources -l\n\t*** CURRENT SOURCES ***\n\n\thttp://ruby.taobao.org\n\t# 请确保只有 ruby.taobao.org\n\n###2.开始安装\n\n\t$ [sudo] gem install cocoapods\n\t$ pod setup\t\n\n-----\n\n##如何使用\n\n###1.创建配置文件 \n首先在你的工程下(我创建的是CocoaPodsTest)创建一个空的Podfile文件,这个文件就是用来配置依赖的\n\n\t$ vi Podfile\n\n###2. 保存退出\n\n\t$ wq\n\n###3. 安装 pod\n\n\t$ pod install\n\n如果成功后您会看到如下信息\n   \n{%img http://ww3.sinaimg.cn/mw690/a43af4ffjw1e9gkg71ll2j20dh06cq3y.jpg 300 200%}\n\n并且在你的工程下如多出如下文件\n    \n    \n{%img http://ww4.sinaimg.cn/mw690/a43af4ffjw1e9gkht6s51j205n048mxa.jpg%}\n\n###4. 查询确认你要引用的库 \n比如我要引入SBJson 为了确认CocoaPods能不能导入这个库 我需要执行\n\n\t$ pod search SBJson\n\n结果返回了如下信息 则证明可以引入\n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9gkftzdavj20i104bq3r.jpg 350 300 %}\t\n\n###5. 加入引入的库\n\n打开Podfile配置文件 加上如下内容保存\n\n\tplatform :ios\n\tpod 'SBJson'\n\n当然你也可以指定特定的版本 例如 \n\tpod 'SBJson', '~> 3.2'\n\n###6. 保存更新\n\n\t$ pod update\n\n更新成功后出现如下信息\n\n\tAnalyzing dependencies\n\tDownloading dependencies\n\tInstalling SBJson (3.2)\n\tGenerating Pods project\n\tIntegrating client project \n打开CocoaPodsTest.xcworkspace  此刻会发现已经把我们想要的库下载好了\n如图\n{% img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9gkhxhn3ej207109mwf0.jpg 300 400%}\n\n\n6:设置Target头文件索引,第一次使用 需要配置下相应的头文件索引,不然他们虽然在一个工作区下 但是不在同一个项目中也无法直接使用 因此您需要\n按着下图,进行相应的配置 \n\n{%img  http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9gkjbu1t8j20pu06qwfm.jpg %}\n\n7:ok 大功告成 以后你只要更执行如下命令 就可以更新你引入的所有第三方库了\n\n\t$ pod update\n\n-----\n\n更详细的内容可以看下cocoapods的官网哈.\nhttp://docs.cocoapods.org/guides/getting_started.html\n\n\n\n","mtime":1381426125000,"source":"_posts/ios30.md"},"dsnw2zz7or28y3w6":{"_id":"dsnw2zz7or28y3w6","content":"title: 如何建立基于CocoaPods的ReactiveCocoa工程\ndate: 2013-10-13 22:23:32\ntags: [技术]\ncategories: ios\n---\nReactiveCocoa 和  CocoaPods 一样也是目前很流行的 能方便和提高效率的框架.\n<!-- more -->\n\n其实不光ios 学习任何一门语音最快最直接的方法就是上手. 如果单单是看看文档只能是走马观花得到一个感性认识罢了.前两天之前一个公司的测试人员跟我联系说如何学习JAVA,我问他是怎么学的,他说从网上下了好多视频教程,一直在看视频教程,也买了一些书. 我问他敲了多少代码,他说很少. 其实跟他一样的人不少. 我觉得任何事情都不简单,因为看起来简单的事情自己没有实际做过的话 往往会遇到各种各样的问题. 这也是为什么在工作中制定项目进度计划的时候 我尽量给自己和团队中的人多争取时间的最主要的一个因素.  \n\n好了,自己一些啰嗦和感悟. 下面开始正式.\n\n------\n##What is Reactive Cocoa?\n RAV is an Object-C framework for Functional Reavtive Programming;\n 两个关键点:\n 1:framework 既然是framework 那就跟你用的其他framework没什么区别 无非就是加到工程中引用罢了.不做多余解释\n 2:Functional Reavtive Programming 实时响应式编程\n\n虾米引用被阿里收购后现在先上的mac版本的虾米音乐就是用Reactive Cocoa开发的.用阿里人自己的话来说就是\n>好东西啊，以前我们用 KVO 或 Notification 来自动绑定数据，改用 ReactiveCocoa 写以后，代码结构更佳简单清晰，同时代码行数直接减少 60% 以上\n\n\n来点直观的对比吧,比如我们想要实现一个需求:当变量中的字符串改变后即时做出相应的反馈 我们用KVO 需要如下这样做\n```\n// In your viewDidLoad/awakeFromNib/init\n[self addObserver:self \n       forKeyPath:@\"someString\" \n          options:NSKeyValueObservingOptionNew \n          context:&someStringChangeContext];\n\n// In dealloc\n[self removeObserver:self \n          forKeyPath:@\"someString\" \n             context:&someStringChangeContext];\n\n// Elsewhere in your class\n- (void)observeValueForKeyPath:(NSString *)keyPath \n                      ofObject:(id)object \n                        change:(NSDictionary *)change \n                       context:(void *)context\n{\n    if (context == &someStringChangeContext) {\n        if ([keyPath isEqualToString:@\"someString\"]) {        \n            // Do a bunch of stuff here\n        }\n    }\n}\n\n```\n上面一坨代码 在应用Reactive Cocoa后 只有短短一行\n\n```\n[RACObserve(self, someString) distinctUntilChanged] subscribeNext:^(NSString *string) {\n    // Do a bunch of things here, just like you would with KVO\n}];\n```\n\n\n##开始动手\n\n因为我之前安装了[CocoaPods](http://hufeng825.github.io/2013/10/11/ios30/),所以我这次写的ReactiveCocoaDemo 是基于CocoaPods的.如果没有安装的可以童鞋,可以直接从github上下载[ReactiveCocoa](https://github.com/ReactiveCocoa/ReactiveCocoa)\n\n###前期工作:\n\n1.打开xcode 创建一个工程,我命名的工程名为ReactiveCocoaDemo,\n\n2.终端到工程路径下\n\n\tcd ReactiveCocoaDemo/\n\tpod search ReactiveCocoa\n\n3.配置依赖文件\n\n\tvi Podfile\n\t\tplatform :ios,'5.0'\n\t\tpod 'ReactiveCocoa'\n\twq\n\n4.下载文件  \n\n \tpod install /update\n\n5:打开\"Build Phases\" 选中相应的target, 添加 RAC 到 \"Link Binary With Libraries\".加上libReactiveCocoa-iOS.a\n\n如下图\n\n6:在Header Search Paths 中添加$(BUILD_ROOT)/../IntermediateBuildFilesPath/UninstalledProducts/include\" \n\n7:在  \"Other Linker Flags\" 添加 -ObjC \n\n8:在ReactiveCocoaDemo-Prefix.pch 将RAC的头文件加进去 \n\n\t#import \"ReactiveCocoa.h\"\n\n\n###现在要实现如下功能\n\n两个输入框 一个提示的Lable 一个按钮,\n1.当两个输入框的内容相同时 提示文字显示\"成功\" 按钮可以点击\n2.当任意一个输入框没有输入内容时 提示文字显示\"请输入\"  按钮不可点击\n3.当输入框非空且两个输入内容不同时 提示\"请重新输入\"  按钮不可点击\n\n\n下面是部分实现代码:\n\n```\n@weakify(self);\n[[RACObserve(self, warningText)\n  filter:^(NSString *newString) {\n      self.resultLabel.text = newString;\n      return YES;\n//          return [newString hasPrefix:@\"Success\"];\n  }]\n subscribeNext:^(NSString *newString) {\n     @strongify(self);\n     self.bt.enabled = [newString hasPrefix:@\"Success\"];\n }];\n\n\nRAC(self,self.warningText) = [RACSignal combineLatest:@[\nRACObserve(self,self.input.text),RACObserve(self, self.verifyInput.text)]\nreduce:^(NSString *password, NSString *passwordConfirm)\n{\n    if ([passwordConfirm isEqualToString:password])\n    {\n        return @\"Success\";\n    }\n    else if([password length] == 0 || [passwordConfirm length] ==0 )\n    {\n        return @\"Please Input\";\n    }\n    else\n    return @\"Input Error\";\n}\n  ];\n\n\n```\n对应关系如下图所示\n\n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9k2n3lrisj20kf0960ty.jpg %}\n\n学过C++ 的应该觉得这个很类似于Qt中的信号槽机制\n\n**需要说明的是** 因为RAC很大程度上是依赖于Block的.所以在RAC前面我们加上@weakify(my_variable) 避免循环引用,然后在每一个\nRAC块中为了防止提前释放我们需要用@strongify(my_variable)来对对象进行持有.[详情点击](https://github.com/jspahrsummers/libextobjc/blob/master/extobjc/EXTScope.h)\n\n运行效果图如下\n\n{%img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9k2zoesjqj208e069t8m.jpg %}\n\n\n\n----\n\n##文档附录\n\n### Subscription\n\nThe [-subscribe…][RACSignal] methods give you access to the current and future values in a signal:\n\n```objc\nRACSignal *letters = [@\"A B C D E F G H I\" componentsSeparatedByString:@\" \"].rac_sequence.signal;\n\n// Outputs: A B C D\n[letters subscribeNext:^(NSString *x) {\n    NSLog(@\"%@\", x);\n}];\n```\n\nFor a cold signal, side effects will be performed once _per subscription_:\n\n```objc\n__block unsigned subscriptions = 0;\n\nRACSignal *loggingSignal = [RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n    subscriptions++;\n    [subscriber sendCompleted];\n    return nil;\n}];\n\n// Outputs:\n// subscription 1\n[loggingSignal subscribeCompleted:^{\n    NSLog(@\"subscription %u\", subscriptions);\n}];\n\n// Outputs:\n// subscription 2\n[loggingSignal subscribeCompleted:^{\n    NSLog(@\"subscription %u\", subscriptions);\n}];\n```\n\nThis behavior can be changed using a [connection][Connections].\n\n### Injecting effects\n\nThe [-do…][RACSignal+Operations] methods add side effects to a signal without actually\nsubscribing to it:\n\n```objc\n__block unsigned subscriptions = 0;\n\nRACSignal *loggingSignal = [RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n    subscriptions++;\n    [subscriber sendCompleted];\n    return nil;\n}];\n\n// Does not output anything yet\nloggingSignal = [loggingSignal doCompleted:^{\n    NSLog(@\"about to complete subscription %u\", subscriptions);\n}];\n\n// Outputs:\n// about to complete subscription 1\n// subscription 1\n[loggingSignal subscribeCompleted:^{\n    NSLog(@\"subscription %u\", subscriptions);\n}];\n```\n\n## Transforming streams\n\nThese operators transform a single stream into a new stream.\n\n### Mapping\n\nThe [-map:][RACStream] method is used to transform the values in a stream, and\ncreate a new stream with the results:\n\n```objc\nRACSequence *letters = [@\"A B C D E F G H I\" componentsSeparatedByString:@\" \"].rac_sequence;\n\n// Contains: AA BB CC DD EE FF GG HH II\nRACSequence *mapped = [letters map:^(NSString *value) {\n    return [value stringByAppendingString:value];\n}];\n```\n\n### Filtering\n\nThe [-filter:][RACStream] method uses a block to test each value, including it\ninto the resulting stream only if the test passes:\n\n```objc\nRACSequence *numbers = [@\"1 2 3 4 5 6 7 8 9\" componentsSeparatedByString:@\" \"].rac_sequence;\n\n// Contains: 2 4 6 8\nRACSequence *filtered = [numbers filter:^ BOOL (NSString *value) {\n    return (value.intValue % 2) == 0;\n}];\n```\n\n## Combining streams\n\nThese operators combine multiple streams into a single new stream.\n\n### Concatenating\n\nThe [-concat:][RACStream] method appends one stream's values to another:\n\n```objc\nRACSequence *letters = [@\"A B C D E F G H I\" componentsSeparatedByString:@\" \"].rac_sequence;\nRACSequence *numbers = [@\"1 2 3 4 5 6 7 8 9\" componentsSeparatedByString:@\" \"].rac_sequence;\n\n// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9\nRACSequence *concatenated = [letters concat:numbers];\n```\n\n### Flattening\n\nThe [-flatten][RACStream] operator is applied to a stream-of-streams, and\ncombines their values into a single new stream.\n\nSequences are [concatenated](#concatenating):\n\n```objc\nRACSequence *letters = [@\"A B C D E F G H I\" componentsSeparatedByString:@\" \"].rac_sequence;\nRACSequence *numbers = [@\"1 2 3 4 5 6 7 8 9\" componentsSeparatedByString:@\" \"].rac_sequence;\nRACSequence *sequenceOfSequences = @[ letters, numbers ].rac_sequence;\n\n// Contains: A B C D E F G H I 1 2 3 4 5 6 7 8 9\nRACSequence *flattened = [sequenceOfSequences flatten];\n```\n\nSignals are [merged](#merging):\n\n```objc\nRACSubject *letters = [RACSubject subject];\nRACSubject *numbers = [RACSubject subject];\nRACSignal *signalOfSignals = [RACSignal createSignal:^ RACDisposable * (id<RACSubscriber> subscriber) {\n    [subscriber sendNext:letters];\n    [subscriber sendNext:numbers];\n    [subscriber sendCompleted];\n    return nil;\n}];\n\nRACSignal *flattened = [signalOfSignals flatten];\n\n// Outputs: A 1 B C 2\n[flattened subscribeNext:^(NSString *x) {\n    NSLog(@\"%@\", x);\n}];\n\n[letters sendNext:@\"A\"];\n[numbers sendNext:@\"1\"];\n[letters sendNext:@\"B\"];\n[letters sendNext:@\"C\"];\n[numbers sendNext:@\"2\"];\n```\n\n### Mapping and flattening\n\n[Flattening](#flattening) isn't that interesting on its own, but understanding\nhow it works is important for [-flattenMap:][RACStream].\n\n`-flattenMap:` is used to transform each of a stream's values into _a new\nstream_. Then, all of the streams returned will be flattened down into a single\nstream. In other words, it's [-map:](#mapping) followed by [-flatten](#flattening).\n\nThis can be used to extend or edit sequences:\n\n```objc\nRACSequence *numbers = [@\"1 2 3 4 5 6 7 8 9\" componentsSeparatedByString:@\" \"].rac_sequence;\n\n// Contains: 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9\nRACSequence *extended = [numbers flattenMap:^(NSString *num) {\n    return @[ num, num ].rac_sequence;\n}];\n\n// Contains: 1_ 3_ 5_ 7_ 9_\nRACSequence *edited = [numbers flattenMap:^(NSString *num) {\n    if (num.intValue % 2 == 0) {\n        return [RACSequence empty];\n    } else {\n        NSString *newNum = [num stringByAppendingString:@\"_\"];\n        return [RACSequence return:newNum]; \n    }\n}];\n```\n\nOr create multiple signals of work which are automatically recombined:\n\n```objc\nRACSignal *letters = [@\"A B C D E F G H I\" componentsSeparatedByString:@\" \"].rac_sequence.signal;\n\n[[letters\n    flattenMap:^(NSString *letter) {\n        return [database saveEntriesForLetter:letter];\n    }]\n    subscribeCompleted:^{\n        NSLog(@\"All database entries saved successfully.\");\n    }];\n```\n\n## Combining signals\n\nThese operators combine multiple signals into a single new [RACSignal][].\n\n### Sequencing\n\n[-then:][RACSignal+Operations] starts the original signal,\nwaits for it to complete, and then only forwards the values from a new signal:\n\n```objc\nRACSignal *letters = [@\"A B C D E F G H I\" componentsSeparatedByString:@\" \"].rac_sequence.signal;\n\n// The new signal only contains: 1 2 3 4 5 6 7 8 9\n//\n// But when subscribed to, it also outputs: A B C D E F G H I\nRACSignal *sequenced = [[letters\n    doNext:^(NSString *letter) {\n        NSLog(@\"%@\", letter);\n    }]\n    then:^{\n        return [@\"1 2 3 4 5 6 7 8 9\" componentsSeparatedByString:@\" \"].rac_sequence.signal;\n    }];\n```\n\nThis is most useful for executing all the side effects of one signal, then\nstarting another, and only returning the second signal's values.\n\n### Merging\n\nThe [+merge:][RACSignal+Operations] method will forward the values from many\nsignals into a single stream, as soon as those values arrive:\n\n```objc\nRACSubject *letters = [RACSubject subject];\nRACSubject *numbers = [RACSubject subject];\nRACSignal *merged = [RACSignal merge:@[ letters, numbers ]];\n\n// Outputs: A 1 B C 2\n[merged subscribeNext:^(NSString *x) {\n    NSLog(@\"%@\", x);\n}];\n\n[letters sendNext:@\"A\"];\n[numbers sendNext:@\"1\"];\n[letters sendNext:@\"B\"];\n[letters sendNext:@\"C\"];\n[numbers sendNext:@\"2\"];\n```\n\n### Combining latest values\n\nThe [+combineLatest:][RACSignal+Operations] and `+combineLatest:reduce:` methods\nwill watch multiple signals for changes, and then send the latest values from\n_all_ of them when a change occurs:\n\n```objc\nRACSubject *letters = [RACSubject subject];\nRACSubject *numbers = [RACSubject subject];\nRACSignal *combined = [RACSignal\n    combineLatest:@[ letters, numbers ]\n    reduce:^(NSString *letter, NSString *number) {\n        return [letter stringByAppendingString:number];\n    }];\n\n// Outputs: B1 B2 C2 C3\n[combined subscribeNext:^(id x) {\n    NSLog(@\"%@\", x);\n}];\n\n[letters sendNext:@\"A\"];\n[letters sendNext:@\"B\"];\n[numbers sendNext:@\"1\"];\n[numbers sendNext:@\"2\"];\n[letters sendNext:@\"C\"];\n[numbers sendNext:@\"3\"];\n```\n\nNote that the combined signal will only send its first value when all of the\ninputs have sent at least one. In the example above, `@\"A\"` was never\nforwarded because `numbers` had not sent a value yet.\n\n### Switching\n\nThe [-switchToLatest][RACSignal+Operations] operator is applied to\na signal-of-signals, and always forwards the values from the latest signal:\n\n```objc\nRACSubject *letters = [RACSubject subject];\nRACSubject *numbers = [RACSubject subject];\nRACSubject *signalOfSignals = [RACSubject subject];\n\nRACSignal *switched = [signalOfSignals switchToLatest];\n\n// Outputs: A B 1 D\n[switched subscribeNext:^(NSString *x) {\n    NSLog(@\"%@\", x);\n}];\n\n[signalOfSignals sendNext:letters];\n[letters sendNext:@\"A\"];\n[letters sendNext:@\"B\"];\n\n[signalOfSignals sendNext:numbers];\n[letters sendNext:@\"C\"];\n[numbers sendNext:@\"1\"];\n\n[signalOfSignals sendNext:letters];\n[numbers sendNext:@\"2\"];\n[letters sendNext:@\"D\"];\n```\n\n\n\n\n\n\n\n\n\n\n\n","mtime":1381687546000,"source":"_posts/ios31.md"},"78suca84muhe5pnh":{"_id":"78suca84muhe5pnh","content":"title: removeFromSuperview添加动画使其更加高雅美观\ndate: 2013-08-29 18:29:40\ntags: [技术]\ncategories: ios\n---\n>程序中难免使用removeFromSuperview，但是view控件直接从界面突然消失会显得非常不友好，作为一个高端大气上档次的app细节处处应该注意，\n<!-- more -->\n添加一个简单的动画给用户的感觉立刻不一样了。废话不说直接上代码\n```\n   [UIView animateWithDuration:0.2\n\n                     animations:^{_logViewController.view.alpha = 0.0;}\n\n                     completion:^(BOOL finished)\n\n                                { [_logViewController.view removeFromSuperview]; }\n\n     ];\n\n\n\n```\n","mtime":1377913082000,"source":"_posts/ios4.md"},"ex7d3ztxv8pw37j7":{"_id":"ex7d3ztxv8pw37j7","content":"title: ios 通过当前view得到所在的viewcontroller\ndate: 2013-08-29 18:35:01\ntags: [技术]\ncategories: ios\n---\nlong long ago ，带过的小弟遇到了一个问题，需要从当前的控件（一般是uiview）获取当前所在的viewcontroller\n<!-- more -->\n当时给出他的解决办法\n```\n@implementation UIView (GetVCAdditions)\n- (UIViewController *)GetiewController {\n    Class vcc = [UIViewController class];\n    UIResponder *responder = self;\n    while ((responder = [responder nextResponder]))\n        if ([responder isKindOfClass: vcc])\n            return (UIViewController *)responder;\n    return nil;\n}\n\n\n```\n","mtime":1377913082000,"source":"_posts/ios5.md"},"dpi0vwe0h7i7zi60":{"_id":"dpi0vwe0h7i7zi60","content":"title: 快速清除subviews之 隐私循环\ndate: 2013-08-29 18:48:47\ntags: [技术]\ncategories: ios\n---\n\n> 问：如何快速把当前view下的所有子view 及其子子view们删除掉\n<!-- more -->\n解答这个问题前先介绍下 NSArray \n\nNSArray 类定义的方法\n\n1.  makeObjectsPerformSelector:@select（aMethod）\n\n简介：让数组中的每个元素 都调用 aMethod \n\n2. makeObjectsPerformSelector:@select（aMethod）\n\n   　　　　              withObject:oneObject\n\n**ps：让数组中的每个元素 都调用 aMethod  并把 withObject 后边的 oneObject 对象做为参数传给方法aMethod**\n\n因此可以利用隐私循环来快速清除subviews\n\n[[self.view subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];","mtime":1378826228000,"source":"_posts/ios7.md"},"ks2018xs7tkg02im":{"_id":"ks2018xs7tkg02im","content":"title: ios iphone5 适配 之 如何使app 适用不通分辨率\ndate: 2013-08-29 18:44:36\ntags: [技术]\ncategories: ios\n---\niphone5适配 有如下集中种思路\n\n<!-- more -->\n\n1：利用自身的autoresize 加上代码实现\n\n2：写两套xib\n\n3：利用ios5+ 以上的autolayout\n\n前两种方式应用比较广泛 ，因为毕竟国内还有部分应用ios4.3的用户\n\n下面给第二种方式应用下的部分代码\n\n```\n- (id)init\n{\n\n    NSString    *clssName = NSStringFromClass([self class]);\n    NSString    *xibName = is4InchScreen() ?[NSString stringWithFormat:@\"%@_4inch\", clssName] : clssName;\n    self = [super initWithNibName:xibName bundle:nil];\n    if (self) {}\n    return self;\n\n}\n\n```\n\n","mtime":1378826228000,"source":"_posts/ios6.md"},"o9ttqx0hz05uw97a":{"_id":"o9ttqx0hz05uw97a","content":"title: ios UIKit Dynamics 系列教程之Gravity+Collision\ndate: 2013-11-06 14:16:04\ntags: [技术]\ncategories: ios\n---\nios7推出好久了,但是最近忙着工作的时间现在才抽时间自己看了WWDC2013,很是惭愧.最客户端其实最有趣的莫过于动画.ios7给我最大的惊喜就是UIKit Dynamics的到来,想想两年前写招行掌上生活首页的时候,那时候没有现成的物理引擎,写的动画非常生硬,套用现在流行的话就是\"既视感\"不强.\n<!-- more -->\n\n理论性的东西不太擅长.引用[onevcat](http://onevcat.com/2013/06/uikit-dynamics-started/)老师的博客.\n\n##UIKitUIKit动力架构：\n\n###1 UIDynamicItem；\n\nDynamic的协议对象\n\n###2 UIDynamicBehavior：\n\n动力行为的描述，用来指定UIDynamicItem应该如何运动，即定义适用的物理规则；\n\n其下面又有几种行为\n\n1. 吸附行为（UIAttachmentBehavior）： 有一个对象UIAttachmentBehavior，该对象用来指定两个动力项（项或点）之间的连接，当一个项或者点移动时，吸附的项也随之移动。当然，这个连接并不是完全是静态的（static），吸附的项有两个属性damping(阻尼)和oscillation(震荡)，这两个属性决定了吸附项的行为是如何随时间而变化的。\n \n2. 碰撞行为（UICollisionBehavior）： 通过对象UICollisionBehavior指定一个边界，并且让各个动力项，在该边界内参与碰撞。UICollisionBehavior对象还可以指定这些动力项适当的回应碰撞。\n \n3. 重力行为（UIGravityBehavior）： 通过对象UIGravityBehavior给动力项指定一个重力矢量，具有重力矢量的动力项，会在重力矢量的方向上一直加速，直到与别的动力项产生了冲突或者，遇到了边界。\n \n4. 推动行为（UIPushBehavior）： 通过对象UIPushBehavior给动力项指定一个持续的或者瞬时的力（force vector）。\n \n5. 捕捉行为（UISnapBehavior）： 通过对象UISnapBehavior给动力项指定一个捕捉点。动力项会根据配置的效果，来抓住这一捕捉点。\n\n当动力行为被添加到animator（UIDynamicAnimator类的实例对象）时，动力行为就被激活。animator为动力行为的执行提供了上下文。动力项可以以组合形式出现,只要添加到同一个animator中即可。\n\n###3 UIDynamicAnimator；\n\n动画的播放者，动力行为（UIDynamicBehavior）的容器，添加到容器内的行为将发挥作用；\n\n###4 ReferenceView：\n\n等同于力学参考系，\n\n只有当想要添加力学的UIView是ReferenceView的子view时，动力UI才发生作用。\n\n\n----------- \n\n下面开始动手来做\n比如我们要实现下面的功能\n\n{%image center http://ww3.sinaimg.cn/mw690/a43af4ffjw1eadmdoeir3g208z0d8x4h.gif%}\n\n\n1. 首先创建 我们的animatior\n\n```\nUIDynamicAnimator *animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];\n\n```\n2. 对你想要进行动画的 item 添加上想要的物理行为 下面 我对square1 分别添加了 重力和碰撞还有吸附引擎.\n\n```\nUIGravityBehavior *gravityBeahvior = [[UIGravityBehavior alloc] initWithItems:@[self.square1]];\nUICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc] initWithItems:@[self.square1]];\n\nCGPoint anchorPoint = CGPointMake(self.square1.center.x, self.square1.center.y - 110.0);\nUIAttachmentBehavior *attachmentBehavior = [[UIAttachmentBehavior alloc] initWithItem:self.square1 attachedToAnchor:anchorPoint];\n\n//anchorPoint 为描点 及Beahvior相对应的作力点\n\n```\n3. 激活碰撞引擎的边界属性\n\n```\ncollisionBehavior.translatesReferenceBoundsIntoBoundary = YES;\n\n```\n\n他的边界是针对于你设置的animator中的referenceView而定的,即self.view  当然我们也可以自定义某一个区域作为碰撞边界\n\n```\n[collisionBehavior setTranslatesReferenceBoundsIntoBoundaryWithInsets:UIEdgeInsetsMake(0, 0, 100.0, 100.0)];\n\n```\n这样子还不能满足你的需求 cocoa 还提供了添加UIBezierPath的方法 addBoundaryWithIdentifier:forPath:和添加一条线段为边界的 addBoundaryWithIdentifier:fromPoint:toPoint 方法\n\n4: 为了方便显示 我们给square1添加一个imageView, 然后设置图片的渲染属性 这样子我们可以很方便的改变图片的颜色用以\n\nself.square1ImageView.image = [self.square1ImageView.image imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];\n\n5:设置震荡频率和阻尼\n\n```\n// These parameters set the attachment in spring mode, instead of a rigid\n// connection.\n[attachmentBehavior setFrequency:.5];\n[attachmentBehavior setDamping:0.2];\n\n```\n\n6: 为了更清楚的显示描点 和 item 显示的作用力 我们用绳子来展示\n\n实现机制很简单 就是用绳子图片进行拼接 然后KVO 描点和item的运动轨迹 动态刷新 \n\n```\n- (void)trackAndDrawAttachmentFromView:(UIView*)attachmentPointView toView:(UIView*)attachedView withAttachmentOffset:(CGPoint)attachmentOffset\n{\n    if (!self.attachmentDecorationLayers)\n        // First time initialization.\n    {\n        self.attachmentDecorationLayers = [NSMutableArray arrayWithCapacity:4];\n        for (NSUInteger i=0; i<4; i++)\n        {\n            UIImage *dashImage = [UIImage imageNamed:[NSString stringWithFormat:@\"DashStyle%i\", (i % 3) + 1]];\n            \n            CALayer *dashLayer = [CALayer layer];\n            dashLayer.contents = (__bridge id)(dashImage.CGImage);\n            dashLayer.bounds = CGRectMake(0, 0, dashImage.size.width, dashImage.size.height);\n            dashLayer.anchorPoint = CGPointMake(0.5, 0);\n            \n            [self.layer insertSublayer:dashLayer atIndex:0];\n            [self.attachmentDecorationLayers addObject:dashLayer];\n        }\n    }\n    \n    // A word about performance.\n    // Tracking changes to the properties of any id<UIDynamicItem> involved in\n    // a simulation incurs a performance cost.  You will receive a callback\n    // during each step in the simulation in which the tracked item is not at\n    // rest.  You should therefore strive to make your callback code as\n    // efficient as possible.\n    \n    [self.attachmentPointView removeObserver:self forKeyPath:@\"center\"];\n    [self.attachedView removeObserver:self forKeyPath:@\"center\"];\n    \n    self.attachmentPointView = attachmentPointView;\n    self.attachedView = attachedView;\n    self.attachmentOffset = attachmentOffset;\n    \n    // Observe the 'center' property of both views to know when they move.\n    [self.attachmentPointView addObserver:self forKeyPath:@\"center\" options:0 context:NULL];\n    [self.attachedView addObserver:self forKeyPath:@\"center\" options:0 context:NULL];\n    \n    [self setNeedsLayout];\n}\n\n//| ----------------------------------------------------------------------------\n- (void)layoutSubviews\n{\n    [super layoutSubviews];\n    \n    if (self.attachmentDecorationLayers)\n    {\n        // Here we adjust the line dash pattern visualizing the attachement\n        // between attachmentPointView and attachedView to account for a change\n        // in the position of either.\n        \n        const NSUInteger MaxDashes = self.attachmentDecorationLayers.count;\n        \n        CGPoint attachmentPointViewCenter = CGPointMake(self.attachmentPointView.bounds.size.width/2, self.attachmentPointView.bounds.size.height/2);\n        attachmentPointViewCenter = [self.attachmentPointView convertPoint:attachmentPointViewCenter toView:self];\n        CGPoint attachedViewAttachmentPoint = CGPointMake(self.attachedView.bounds.size.width/2 + self.attachmentOffset.x, self.attachedView.bounds.size.height/2 + self.attachmentOffset.y);\n        attachedViewAttachmentPoint =  [self.attachedView convertPoint:attachedViewAttachmentPoint toView:self];\n        \n        CGFloat distance = sqrtf( powf(attachedViewAttachmentPoint.x-attachmentPointViewCenter.x, 2.0) +\n                                 powf(attachedViewAttachmentPoint.y-attachmentPointViewCenter.y, 2.0) );\n        CGFloat angle = atan2( attachedViewAttachmentPoint.y-attachmentPointViewCenter.y,\n                              attachedViewAttachmentPoint.x-attachmentPointViewCenter.x );\n        \n        NSUInteger requiredDashes = 0;\n        CGFloat d = 0.0f;\n        \n        // Depending on the distance between the two views, a smaller number of\n        // dashes may be needed to adequately visualize the attachment.  Starting\n        // with a distance of 0, we add the length of each dash until we exceed\n        // 'distance' computed previously or we use the maximum number of allowed\n        // dashes, 'MaxDashes'.\n        while (requiredDashes < MaxDashes)\n        {\n            CALayer *dashLayer = self.attachmentDecorationLayers[requiredDashes];\n            \n            if (d + dashLayer.bounds.size.height < distance) {\n                d += dashLayer.bounds.size.height;\n                dashLayer.hidden = NO;\n                requiredDashes++;\n            } else\n                break;\n        }\n        \n        // Based on the total length of the dashes we previously determined were\n        // necessary to visualize the attachment, determine the spacing between\n        // each dash.\n        CGFloat dashSpacing = (distance - d) / (requiredDashes + 1);\n        \n        // Hide the excess dashes.\n        for (; requiredDashes < MaxDashes; requiredDashes++)\n            [self.attachmentDecorationLayers[requiredDashes] setHidden:YES];\n        \n        // Disable any animations.  The changes must take full effect immediately.\n        [CATransaction begin];\n        [CATransaction setAnimationDuration:0];\n        \n        // Each dash layer is positioned by altering its affineTransform.  We\n        // combine the position of rotation into an affine transformation matrix\n        // that is assigned to each dash.\n        CGAffineTransform transform = CGAffineTransformMakeTranslation(attachmentPointViewCenter.x, attachmentPointViewCenter.y);\n        transform = CGAffineTransformRotate(transform, angle - M_PI/2);\n        \n        for (NSUInteger drawnDashes = 0; drawnDashes < requiredDashes; drawnDashes++)\n        {\n            CALayer *dashLayer = self.attachmentDecorationLayers[drawnDashes];\n            \n            transform = CGAffineTransformTranslate(transform, 0, dashSpacing);\n            \n            [dashLayer setAffineTransform:transform];\n            \n            transform = CGAffineTransformTranslate(transform, 0, dashLayer.bounds.size.height);\n        }\n        \n        [CATransaction commit];\n    }\n}\n\n\n//| ----------------------------------------------------------------------------\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context\n{\n    if (object == self.attachmentPointView || object == self.attachedView)\n        [self setNeedsLayout];\n    else\n        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];\n}\n\n\n```\n\n6: 为了让程序更有意思点 我们可以用UICollisionBehaviorDelegate来处理碰撞回掉 比如碰到边界 我们改变下颜色\n\n```\n\n- (void)collisionBehavior:(UICollisionBehavior*)behavior beganContactForItem:(id<UIDynamicItem>)item withBoundaryIdentifier:(id<NSCopying>)identifier atPoint:(CGPoint)p\n{\n    // Lighten the tint color when the view is in contact with a boundary.\n    [(UIView*)item setTintColor:[UIColor redColor]];\n\n}\n\n//| ----------------------------------------------------------------------------\n//  This method is called when square1 stops contacting a collision boundary.\n//  In this demo, the only collision boundary is the bounds of the reference\n//  view (self.view).\n//\n- (void)collisionBehavior:(UICollisionBehavior*)behavior endedContactForItem:(id<UIDynamicItem>)item withBoundaryIdentifier:(id<NSCopying>)identifier\n{\n    // Restore the default color when ending a contcact.\n    [(UIView*)item setTintColor:[UIColor greenColor]];\n\n}\n\n```\n\n7: 添加手势 这样子才能够让方框指哪打哪\n\n- (IBAction)handleSpringAttachmentGesture:(UIGestureRecognizer*)gesture\n{\n   [self.attachmentBehavior setAnchorPoint:[gesture locationInView:self.view]];\n   self.attachmentView.center = self.attachmentBehavior.anchorPoint;\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","mtime":1383893952000,"source":"_posts/iosdynamics0.md"},"q44zo3nkijm5ak1k":{"_id":"q44zo3nkijm5ak1k","content":"title: ios 开发笔记之图片 Image\ndate: 2013-08-20 09:29:39\ntags: [技术]\ncategories: ios\n---\n\n##关于图片资源\nios 程序会把图片资源编译成二进制文件，程序运行时会把这些图片从磁盘加载直接到内存，如果图片很大，加载速度就会很慢。\n<!-- more -->\n为了优化提高性能，需要尽量压缩图片资源。（ps 苹果公司的UIKit 开发者Andy Matuschak指出：使用resizable image是最快的方法。）\n\n\n##关于图片资源的压缩\n如果不需要用半透明的图片 则尽量不要用png 格式的图片。相应的可以用jpg格式的。另外谷歌最新推出的一种格式webp\n  \n###1 WebP是什么\nWebP是Google推出的一种同时提供了有损压缩与无损压缩的图片格式。目前互联网上传输的数据有65%都是图片，WebP就是出于减少数据量、加速网络传输的目的而开发的。WebP希望能够达到和JPEG同水平的图片质量，但是更小的文件，以减少图片的传送时间。\n在有损压缩的状况下，WebP比同样画质的JPEG少了25% ～ 34%的文件大小 。而在无损压缩的情形中，比起用libpng产生的PNG图片，WebP少了34%的文件大小，也比用pngout再处理过的PNG图片少了26%的文件大小。\n###2 WebP的使用\nwebp图片压缩率会比jpeg、png更高，因此下载图片会更省流量，特别适合在mobile app上使用。 比如iOS app上，可以把webp编译生成framework，然后加入引用就可以是使用了。强烈推荐。\n这iOS解析时，可以直接使用 WebPImage。\nNSData *imageData = [NSData dataWithContentsOfURL:url];\nUIImage *tmpImage = [[WebPImage alloc] loadWebPFromData:imageData];\nSDWebImage最近也提供了对webp的支持，起先不支持自己写了一个分类，现在可以直接用他的UIImage+WebP\n\n\n##关于加载方式\n  imageNamed每次都读图片到缓存中，只适合频繁使用的图片，\ninitWithContentsOfFile的方法加载图片后，不缓存，适合加载不常使用的图片。 \n引导图片一般情况下只会启动一次而且图片也一般情况下比较大所以用imageNamed 会非常， 如果用initWithContentsOfFile:，这些图片所占用内存可以很快被释放\n\n>资料参考by wufawei stackoverflow\n\n\n\n","mtime":1377913082000,"source":"_posts/iosimage.md"},"9lt8geg15r2va2fn":{"_id":"9lt8geg15r2va2fn","content":"title: mac 下 git svn 的代理设置\ndate: 2013-09-02 08:10:34\ntags: [技术]\ncategories: [git, svn]\n---\n所干的工作 因为涉及到金融行业网络安全性比较高 公司的网络设置了代理 这导致了git svn 双双挂了。 \n<!-- more -->\n废话少说 下面介绍如何对git svn 设置代理\n\n1. $HOME 下 我的路径为/Users/jason:\n\n2. 进入$HOME/.subversion \n\n   编辑servers 文件 添加\n\n\t   [global]\n\t    http-proxy-host = XX.XX.XX.XX\n\t    http-proxy-port = XXXX\n\t   [groups]\n\n3. 编辑$HOME/.gitconfig\n\n\t   [http]        \n\n\t        proxy = http://XX.XX.XX.XX:XXXX\n\n\t   [https]\n\t         proxy = http://XX.XX.XX.XX:XXXX\n\n4. 或者直接用命令\n\n\t\tgit config --global http.proxy http://XX.XX.XX.XX:XXXX\n\t\tgit config --global https.proxy http://XX.XX.XX.XX:XXXX\n","mtime":1378826228000,"source":"_posts/mac1.md"},"vxwe02tpua9u1rjy":{"_id":"vxwe02tpua9u1rjy","content":"title: Xcode的持续集成指南\ndate: 2013-08-31 21:11:39\ntags: [技术]\ncategories: ios\n---\n\n##采用持续集成工作流\n\n设置MAC作为服务器，在其上运行Xcode的服务。然后确保你的本地项目，发布源代码库。要完成设立一个持续集成的工作流程，配置的机器人，不知疲倦地进行集成和时间表。\n<!-- more -->\n\n##OS X Server的安装和配置的Xcode服务\n要运行的Xcode的服务，您必须先安装运行的是Mac OS X v10.9开发者预览版OS X Server的预览。您还必须在服务器上安装Xcode开发者预览。自动构建，分析，测试，和归档您的产品，您将使用Xcode的服务。\n\n###要安装和运行Xcode的服务\n1. 转到http://developer.apple.com/downloads的，并获得OS X v10.9开发者预览版，OS X Server的预览，和Xcode开发者预览版的预发布版本。\n\n2. 安装OS X v10.9开发者预览版，Mac OS X Server的预览，和Xcode开发者预览版的Mac上，你会运行Xcode的服务。\n\n3. 启动服务器应用程序/应用。\n\n4. 在服务器应用程序边栏中，选择的Xcode的服务。\n\n5. 当您第一次打开Xcode的服务在一个特定的服务器上，该服务会询问您确定的Xcode版本，它应该用来执行其任务。\n\n6. 点击选择的Xcode，并选择使用的Xcode版本。\n\n7. 点击On / Off开关打开服务\n\n接下来，添加你的服务器允许访问Xcode的服务团队，如资产配置的配置文件和签名证书为iOS设备构建产品开发团队。你必须是一个管理员或开发团队的代理，这样才能把服务器加进来。\n\n###要添加您的服务器开发团队\n\n1. 在服务器应用程序边栏中，选择的Xcode的服务。\n\n2. 在“设置”窗格中，单击“添加”按钮，旁边的开发团队标签。\n\n3. 输入您的Apple开发者证书，并选择一个团队。\n\n加入团队后，Xcode的服务，您可以添加iOS开发设备运行单元测试时使用。\n\n###要添加一个iOS开发设备的Xcode服务\n\n1. 在服务器应用程序边栏中，选择的Xcode的服务。\n\n2. 将设备连接到服务器，并等待，直到它出现在设备列表中。\n\n3. 点击“加入队伍”按钮旁边的列表中的设备。\n\n添加帐户资料库和您的服务器配置开发的Mac。你会写你的Mac上的使用Xcode代码，你就会让OS X服务器进行持续集成。您还必须发布或您当地的项目转移到资料库，可通过Xcode的服务。\n\n###你开发的Mac OS X Server的帐户添加到Xcode\n\n1. 在Xcode的开发Mac上，单击“帐户”首选项“窗口。\n\n2. 点击添加按钮（+），并选择“添加服务器”。\n\n3. 从服务器列表中选择服务器，输入服务器地址，然后单击“下一步”按钮。\n\n4. 指定您的连接到服务器的凭据，然后单击“添加”。\n\n您可以添加到您的帐户资料库，加快结帐操作。（你也可以添加库到您的清单后，当您检查的项目）。\n\n###要添加存储库到您的帐户\n\n1. 在Xcode的开发Mac上，单击“帐户”首选项“窗口。\n\n2. 点击添加按钮（+），并选择“添加库。\n\n3. 在文本字段中，输入库添加的地址，然后单击“完成”按钮。\n\n##Xcode的服务和团队成员共享项目\n对于Xcode的服务，您的项目进行集成，它必须包含这些项目的存储库的访问。启用访问托管Git仓库在服务器上运行的Xcode服务或Git或Subversion版本库，包含你的项目添加连接信息。\n\n如果同一个团队开发，持续集成涉及到整个团队。谁的作品在产品上的人都必须能够访问所有产品的资源，使任何人都可以引起谁都可能解决问题。如果你有一个不保持源代码库中的项目或工作区，你必须检查你的文件到存储库，让其他团队成员可以在这些产品上。\n\n**您可以在服务器上创建一个Xcode服务器，托管Git仓库**\n开发团队可以共享更改产品OS X服务器托管在一个Git仓库。创建一个Xcode服务器托管Git仓库之前，你必须：\n\n1. 确保都有谁应该能够访问存储库服务器上的用户帐户。\n\n2. 打开系统偏好设置中的服务器上的远程登录服务。\n\n\n###要创建一个Xcode服务器托管您的服务器上的Git仓库\n\n1. 在服务器应用程序边栏中，选择Xcode的服务，然后单击“存储库”按钮。\n\n2. 点击添加按钮（+），并指定存储库的信息：\n\n\t* 选择“主机一个Git仓库。”\n\t* 名称：输入资料库的名称（例如，项目名称）。\n\t* 访问：确定允许用户访问存储库。\n\n3. 单击“创建”。\n\n\t新的资料库资料库列表中出现。如果你有一个发展的Mac上现有的Git管理的项目，你可以把你的变化，这个新的储存库，将其配置为远程，如未来。\n\n###从发展的Mac，您可以共享现有的Git管理项目\n\n当您共享一个项目，其中包含一个Git仓库，是当地发展的Mac，Xcode的服务可以检查出来进行集成。共享一个项目之前，你必须：\n\n1. 作为OS X服务器运行Xcode的服务的管理员进行身份验证。\n2. 确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。\n\n####要共享项目\n\n1. 打开项目发展的Mac上，并选择源控制> PROJECT_NAME >配置PROJECT_NAME。\n\n2. 按一下远程控制。\n\n3. 点击“添加”按钮（+）。\n\n4. 选择“创建新的远程。\n\n5. 选择一台服务器。\n\n6. 输入远程名称。\n\n7. 单击“创建”。\n\n8. 单击“完成”。\n\n9. 这使得共享资源库的上游库项目存​​储库。\n\n###您可以创建一个新项目开发的Mac OS X服务器和主机守则\n\n当您创建您的开发Mac上的项目，你可以创建一个共享库。创建一个共享的项目之前，你必须：\n\n1. 作为OS X服务器运行Xcode的服务的管理员进行身份验证。\n2. 确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。\n\n####要创建共享项目\n\n1. 选择“文件”>“新建”>“项目。\n\n2. 为您的项目中选择一个模板。\n\n3. 指定项目的选项，并单击“下一步”。\n\n4. 指定的位置。\n\n5. 选择“创建git仓库”选项。\n\n6. 确定服务器。\n\n单击“创建”。\n\n\n您可以使用Git来管理你的开发Mac上的非托管的工作区目录\n当你创建一个Xcode的工作区或项目，你必须包括一个Git仓库中生成的工作区目录的选项。如果您没有选择该选项，您的工作区目录不包括一个Git仓库。与他人使用Git版本控制系统要共享工作区目录，在该目录中，你必须初始化一个Git仓库。\n\n您可以使用Subversion的管理项目\nXcode的服务可以连接你的Subversion版本库，并从它的检查项目。\n\n\n##使用搜索引擎来生成，运行静态分析，测试和存档\n您可以运行一个项目的集成通过三个计划行动：\n\n1. 分析，进行静态分析。\n2. 测试，运行一组测试案例。\n3. 存档，建立一个归档的产品，计划建成。\n\n您可以手动执行这些操作，为您做出更改产品。然而，手动集成可以是乏味且容易出错。例如，你可能会忘记发布一个小的变化，打破你的队友的单元测试之前进行测试操作。Xcode的服务提供了一个具有成本效益的方式自动执行集成：机器人。机器人会自动执行你的集成：\n\n1. 每次更改发布到存储库。\n2. 上定期（比如说，每天进行集成，需要很长的时间才能完成）。\nÂ 机器人运行通过Xcode的服务，以在资源库中的项目的当前版本进行集成，是一个过程。包括一个集成构建，分析，测试，归档产品上。可以是成功的积分（即，所有的整合动作传递没有问题）的或不成功的。计划中定义的集成自动化，您必须共享该方案，并创建一个或多个机器人来执行这些集成。\n\n\n要充分利用您的产品开发流程的持续集成环境中，遵循以下做法：\n\n1. 制定适当的单元测试套件和测试用例，显影单元测试后，包括他们在你的机器人运行计划。要了解关于单元测试的更多信息，请参见Xcode的单元测试指南\n为了帮助确保您所做的更改都破不了您或其他人后，你应​​该配合这些变化与单元测试，确定是否规定一种或一组序列功能的方法。有些球队在它的头把这种方法首先开发测试，通过测试的方法，然后执行。\n\n2. 执行静态分析，你应该在您的集成包括静态分析。\n静态分析是深刻检查你的代码，下面的代码路径，您的应用程序可能不遵循正常的发展过程中。这个过程揭示难以发现的编码错误，还确定了在你的代码不遵循建议的API的用法，比如基金会和AppKit的成语。\n\n3. 确保您的产品建立和正确打包。您您的产品作出了重大变化，特别是结构性的变化，如添加或删除文件后，应归档。让你的机器人自动为您归档。\n当您的产品中包含的结构性问题，Xcode可以创建一个归档它为你的团队成员之间共享或提交到App Store。建立和归档产品的能力是你的代码更改的正确性的主要指标。\n\n\n\n##分享计划\n共享的计划被确定为在一个项目中共享和发布共享资源库，以及与其他共享项目文件。你可以分享计划之前，你必须检查的项目。\n\n \n###要共享计划\n\n1. 开发的Mac上，打开的项目，其中包含共享的计划。\n\n2. 选择产品>计划>管理计划。\n\n3. 分享的计划，选择共享选项，并单击“确定”。\n\n4. 选择源控制>提交。\n\n5. 选择共享的资料夹。\n\n6. 指定你提交的信息：\n\n\t* 在文本字段中输入你的提交信息。\n\t* 选择“推到远程”选项（如果您的项目使用Git管理）。\n\n7. 点击“提交文件”按钮。\n\n\n##创建机器人\n\n共享计划后，你可以创建一个机器人来执行持续集成。\n\n \n要创建一个僵尸\n\n开发的Mac上，打开的项目，其中包含计划，定义的行动，以自动化。\n\n选择产品>创建BOT，指定机器人的标识属性，并单击“下一步”。\n\n与指定库凭据机器人，并单击“下一步”。\n\n指定的整合时间表，行动的机器人来执行，以及是否清洁产品前建设。\n\n附表：指定往往机器人集成。\n\n定期：整合每小时，每天或每周。\n在提交更改时集成发布到存储库。\n手册：机器人不会自动整合。\n操作：选择机器人作为整合的一部分执行的行动。\n\n清洁：指定机器人是否重用以前的版本。\n\n单击“下一步”。\n\n如果您选择创建机器人执行第一次整合，整合的结果，出现在日志中的导航仪。\n\n","mtime":1385476005000,"source":"_posts/ios9.md"},"rx1f95eo3tqfkb3a":{"_id":"rx1f95eo3tqfkb3a","content":"title: xcode 5.0 的持续继承\ndate: 2013-08-31 20:41:27\ntags: [技术]\ncategories: ios\n---\n>\nXcode的支持持续集成通过Xcode的服务流程。Xcode的服务，可在OS X服务器，自动一体化建设过程中，您的应用程序的分析，测试和归档。<!-- more -->从开发的Mac，您可以创建机器人上运行一个单独的服务器，在那里他们执行这些集成。机器人可以帮助确保您的产品始终处于释放状态，当有故障时，服务会通知你的人或代码变化引起的故障。\n\n{%img left http://img.blog.csdn.net/20130617220248765 400 600%}\n\n---------\n\n##概览\n\n按照本文档中列出的步骤，建立一个持续集成的工作流程，使用Xcode和Xcode服务。\n\t注：持续集成工作流程通常依赖于一个或多个开发Mac上运行Xcode和一个独立的OS X服务器运行Xcode的服务。但是，您可以安装开发的Mac OS X Server的。这样的配置可以有助于评估如何采用持续集成。之后，你会发现它有一个专门的OSX服务器运行Xcode的托管服务，你的资料库，并远程执行集成更多有用的。\n\n---------\n\n##设置和自定义的Xcode服务\n\t即使你从来没有架设一台服务器，你会发现OSX服务器上设立了Xcode服务是简单的过程。后服务运行起来，你可以添加开发设备，配置机器人，并指定发布标准。\n\n[有关章节： “采用持续集成工作流”](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/200-Adopting_a_Continuous_Integration_Workflow/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1)\n\n---------\n\n##创建和运行僵尸\n\t\n\t机器人的自动化工作流程的心脏。机器人构建和测试产品与您选择的方案。随着Xcode的服务能够访问你的项目的源代码库中，您可以创建并安排定期运行或在每个源代码提交的机器人。您也可以设定机器人发送邮件通知其集成的成功或失败。\n\n[有关章节： “配置机器人执行连续集成”](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1)\n\n\n##监控和​​管理集成\n\n\t机器人的自动化工作流程的心脏。机器人构建和测试您的产品，您所选择的计划。Xcode的服务提供了日志管理机器人，查看测试结果，并读取整合日志导航。该服务还提供了通过一个网页，在那里您可以查看bot活动的总结以及集成细节的结果。\n   \n[有关章节： “工作与机器人”](https://daw.apple.com/cgi-bin/WebObjects/DSAuthWeb.woa/wa/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&path=%2F%2Flibrary%2Fprerelease%2Fios%2Fdocumentation%2FIDEs%2FConceptual%2Fxcode_guide-continuous_integration%2F300-Working_with_Bots%2Fview_integration_results%2Ehtml#//apple_ref/doc/uid/TP40013292-CH4-SW1)\n\n\n\n\n\n\n","mtime":1377956566000,"source":"_posts/ios8.md"},"w9i38xqahaxvdwaq":{"_id":"w9i38xqahaxvdwaq","content":"title: mac下如何看凤凰卫视直播\ndate: 2013-10-16 22:23:30\ntags: [技术]\ncategories: mac\n---\n本人算是凤凰卫视的直播控吧,之前通过[360电视直播](http://360kan.pptv.com/live/ahws/?site=pptv)看凤凰卫视,但是因为版权现在360直播现在把凤凰给下线了.\n<!-- more -->\n##攻城狮的方法\n于是跟在凤凰的兄弟要了他们的直播源,然后充分发挥自己攻城狮的优势动手编写了一个mac上的应用.\n程序没什么技术含量,对我来说够用就行.\n[代码上传到csdn上了](http://download.csdn.net/detail/hufeng825/6410419)有需要的朋友可以去看看.\n\n运行效果如图:\n\n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9ngc18tzyj20ev0cxgn0.jpg%}\n\n##mac小白可以用的方法\n其实可以不用像我这样麻烦可以直接用ALC这个播放器\n具体步骤如下图\n1:commadn + N 在打开的界面把直播的源地址添加进去\n\n{%img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9nghxpcbcj20j40ect9w.jpg%}\n\n2:打开属性 可以修改频道名称如图\n\n{%img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e9ngc3ppxej20ky0i40uo.jpg%}\n\n3:ok 可以播放了\n\n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e9ngc8k2juj20ky0i4q4a.jpg%}\n\n\n\n\n\n\n","mtime":1381938857000,"source":"_posts/mac5.md"},"hrp0ce92wycltpkz":{"_id":"hrp0ce92wycltpkz","content":"title: Markdown \ndate: 2013-08-14 16:13:21\ntags: [技术]\ncategories: hexo\n---\n本文简单介绍下 Markdown 语法\n<!-- more -->\n\n###什么是Markdown\n\nMarkdown是一个将文本转化为HTML的工具。简单来说，Markdown是一个兼顾可读性与易用性的轻量级标记体系。Markdown并不追求大而全，它只关心HTML里最常用的几个标记，对于一些不常用的标记它允许直接将HTML标记插入文本。\n\n****\n\n##表格\n\n标号  | 面向对象概念 | 面向关系概念 \n--- | --- | ---\n*1* | `对象` | **表的行（即记录）**\n2 | 属性 | 表的列（即字段）\n\n代码如下\n\n```\n标号  | 面向对象概念 | 面向关系概念 \n--- | --- | ---\n*1* | `对象` | **表的行（即记录）**\n2 | 属性 | 表的列（即字段）\n\n```\n\n****\n\n##标题\n\nMarkdown提供了两种方式（Setext和Atx）来显示标题。\n\n代码如下\n\n```\nSetext方式\n标题1\n=================\n\n标题2\n-----------------\n\nAtx方式\n# 标题1\n## 标题2\n###### 标题6\n\n```\n****\n\n##换行\n\n在文字的末尾使用两个或两个以上的空格来表示换行。\n\n代码如下\n\n```\n> 这是一个引用，\n> 这里木有换行，   \n> 在这里换行了。\n> > 内部嵌套\n\n```\n****\n\n##列表\n\n###无序列表使用*、+或-后面加上空格来表示。\n\n代码如下 \n\n```\n* Item 1\n* Item 2\n* Item 3\n\n+ Item 1\n+ Item 2\n+ Item 3\n\n- Item 1\n- Item 2\n- Item 3\n\n```\n\n\n###有序列表使用数字加英文句号加空格表示。\n\n\n代码如下 \n\n```\n1. Item 1\n2. Item 2\n3. Item 3\n\n\n```\n\n****\n\n##代码区域\n\n行内代码使用反斜杠`表示。 \n代码段落则是在每行文字前加4个空格或者1个缩进符表示。\n\n****\n\n\n##强调\n\nMarkdown使用\\*或\\_表示强调。\n\n\n代码如下 \n\n```\n\n单星号 = *斜体*\n单下划线 = _斜体_\n双星号 = **加粗**\n双下划线 = __加粗__\n\n```\n\n链接\n\nMarkdown支持两种风格的链接：Inline和Reference。\n\n语法：\n\nInline：以中括号标记显示的链接文本，后面紧跟用小括号包围的链接。如果链接有title属性，则在链接中使用空格加“title属性”。\nReference：一般应用于多个不同位置使用相同链接。通常分为两个部分，调用部分为[链接文本][ref]；定义部分可以出现在文本中的其他位置，格式为[ref]: http://some/link/address (可选的标题)。 \n注：ref中不区分大小写。\n\n代码如下 \n\n```\n\n这是一个Inline[示例](http://www.baidu.com \"可选的title\")。\n这是一个Reference[示例][ref]。\n[ref]: http://www.baidu.com \n\n```\n\n****\n\n## 图片\n\n图片的使用方法基本上和链接类似，只是在中括号前加叹号。 \n注：Markdown不能设置图片大小，如果必须设置则应使用HTML标记<img>。\n\n代码如下 \n\n```\n{% img right http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg 300 400 可选的title %}\nInline示例：![替代文本](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\")\nReference示例：![替代文本][pic]\n[pic]: http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\"\nHTML示例：<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" alt=\"替代文本\" title=\"标题文本\" width=\"200\" />\n\n```\n效果\n\n{% img right http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg 300 400 可选的title %}\nInline示例：![替代文本](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg \"可选的title\")\nReference示例：![替代文本][http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg]\n[pic]: /assets/images/ship.jpg \"可选的title\"\nHTML示例：<img src=\"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg\" alt=\"替代文本\" title=\"标题文本\" width=\"200\" />\n\n****\n\n\n## 自动链接\n\n使用尖括号，可以为输入的URL或者邮箱自动创建链接。如test@test.com。\n\n## 分隔线\n\n在一行中使用三个或三个以上的*、-或_可以添加分隔线，其中可以有空白，但是不能有其他字符。\n\n## 转义字符\n\nMarkdown中的转义字符为\\，可以转义的有：\n```\n\\\\ 反斜杠\n\\` 反引号\n\\* 星号\n\\_ 下划线\n\\{\\} 大括号\n\\[\\] 中括号\n\\(\\) 小括号\n\\# 井号\n\\+ 加号\n\\- 减号\n\\. 英文句号\n\\! 感叹号\n\n```\n\n\n\n","mtime":1377913082000,"source":"_posts/markdown.md"},"5vljqniplew9vnlu":{"_id":"5vljqniplew9vnlu","content":"title: MAC OS X 下快速切换代理 \ndate: 2013-09-03 13:20:05\ntags: [技术]\ncategories: \n- ios\n- mac\n---\n\n因为行业原因 在公司上网必须通过代理安装，所以每天上下班开电脑第一件事 就是开关代理。于是做了一个软件 利用shell进行切换代理。\n\n{% img left  http://ww2.sinaimg.cn/mw690/a43af4ffjw1e898v6vmwdj20dk06bwep.jpg 300 400 运行效果图 %}\n  \n  <!-- more-->\n    \n{% img left http://ww4.sinaimg.cn/mw690/a43af4ffjw1e898wixkiej207q020dfu.jpg 200 300 软件 %}\n\n    \n\n下面是主要源码\n\n```\ntell application \"System Events\"\n\nset proxy_dialog to display dialog \"代理模块(Ethernet版本):\" buttons {\"打开代理模式1\", \"打开代理模式2\", \"关闭代理\"} default button \"打开代理模式1\" with title \"华夏基金开发环境快速切换代理App\"\n\nset proxy_interface to button returned of proxy_dialog\n\nend tell\n\n\nif proxy_interface is \"打开代理模式1\" then\n\ndo shell script \"networksetup -setwebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setsecurewebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setwebproxystate Ethernet on&&networksetup -setsecurewebproxystate Ethernet on\" with administrator privileges\n\nend if\n\n\nif proxy_interface is \"打开代理模式2\" then\n\ndo shell script \"networksetup -setwebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setsecurewebproxy Ethernet XXX.XXX.XXX.XX XXXX&&networksetup -setwebproxystate Ethernet on&&networksetup -setsecurewebproxystate Ethernet on\" with administrator privileges\n\nend if\n\n\nif proxy_interface is \"关闭代理\" then\n\ndo shell script \"networksetup -setwebproxystate Ethernet off&&networksetup -setsecurewebproxystate Ethernet off\" with administrator privileges\n\nend if\n\n```\n\n","mtime":1379221447000,"source":"_posts/mac3.md"},"q5lyhlty30qhgy2y":{"_id":"q5lyhlty30qhgy2y","content":"title: mac 下更新DNS 缓存\ndate: 2013-09-03 17:14:30\ntags: [技术]\ncategories: [ios ,mac]\n---\n\n开始的时候难免遇到修改host的时候，但是host后没有即刻生效，可使用终端命令手动清除DNS缓存：\n\n```\ndscacheutil -flushcache\n```","mtime":1379221447000,"source":"_posts/mac4.md"},"k9018b2q2cxzujg3":{"_id":"k9018b2q2cxzujg3","content":"title: MQ 笔记之 JMS 简介 （什么是JMS）\ndate: 2013-08-21 21:22:00\ntags: [技术]\ncategories: MQ\n---\n##一：JMS基本概念\n\n###1.      JMS的目标\n\n为企业级的应用提供一种智能的消息系统，JMS定义了一整套的企业级的消息概念与工具，\n<!-- more -->\n\n尽可能最小化的Java语言概念去构建最大化企业消息应用。统一已经存在的企业级消息系\n\n统功能。\n\n###2.      JMS提供者\n\nJMS提供者是指那些完全完成JMS功能与管理功能的JMS消息厂商，理论上JMS提供者完成 \n\nJMS消息产品必须是100%的纯Java语言实现，可以运行在跨平台的架构与操作系统上，当前\n\n一些JMS厂商包括IBM,Oracle, JBoss社区 (JBoss Community), Apache 社区(ApacheCommunity)。\n\n###3.      JMS应用程序, 一个完整的JMS应用应该实现以下功能：\n\n* JMS 客户端 – Java语言开发的接受与发送消息的程序\n\n* 非JMS客户端 – 基于消息系统的本地API实现而不是JMS\n\n* 消息 – 应用程序用来相互交流信息的载体\n\n* 被管理对象–预先配置的JMS对象，JMS管理员创建，被客户端运用。如链接工厂，主题等\n\n* JMS提供者–完成JMS功能与管理功能的消息系统\n\n##二: JMS 规范\n\n\n### 连接工厂\n连接工厂是GUST用来创建连接的对象，例如ActiveMQ提供的ActiveMQConnectionFactory。\n\n### 连接\nJMS Connection封装了客户与JMS提供者之间的一个虚拟的连接。\n\n### 会话\nMS Session是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。\n\n### 目的地\n目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2 规范中定义了两种消息传递域\n\n####点对点的消息模式(Point to Point Messaging)\n{%img http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7umekfemwj20is06o0tb.jpg  300  200 点对点 %}\n\n***\n\n下面的JMS对象在点对点消息模式中是必须的：\n\n* 队列(Queue) – 一个提供者命名的队列对象，客户端将会使用这个命名的队列对象\n\n* 队列链接工厂(QueueConnectionFactory) – 客户端使用队列链接工厂创建链接队列ConnectionQueue来取得与JMS点对点消息提供者的链接。\n\n* 链接队列(ConnectionQueue) – 一个活动的链接队列存在在客户端与点对点消息提供者之间，客户用它创建一个或者多个JMS队列会话(QueueSession)\n\n* 队列会话(QueueSession) – 用来创建队列消息的发送者与接受者(QueueSenderandQueueReceiver)\n\n* 消息发送者(QueueSender 或者MessageProducer)– 发送消息到已经声明的队列\n\n* 消息接受者(QueueReceiver或者MessageConsumer) – 接受已经被发送到指定队列的消息\n\n**注意如下：**\n\n* 每个消息只能有一个消费者。\n* 消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。\n\n#### 发布订阅模式(publish – subscribe Mode)\n\n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7umpp9onwj20is0ayjsk.jpg  200  300 发布者 %}\n***\n* 主题Topic(Destination) – 一个提供者命名的主题对象，客户端将会使用这个命名的主题对象\n\n* 主题链接工厂(TopciConnectionFactory) – 客户端使用主题链接工厂创建链接主题 ConnectionTopic来取得与JMS消息Pub/Sub提供者的链接\n\n* 链接主题(ConnectionTopic) – 一个活动的链接主题存在发布者与订阅者之间\n\n* 会话(TopicSession) – 用来创建主题消息的发布者与订阅者 (TopicPublisher  and TopicSubscribers)\n\n* 消息发送者MessageProducer) – 发送消息到已经声明的主题\n\n* 消息接受者(MessageConsumer) – 接受已经被发送到指定主题的消息\n\n**注意如下：**\n\n* 每个消息可以有多个消费者。\n* 生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。\n\n****\n>本系列博文参考自whitesock  淮少吧 贾志刚\n\n","mtime":1377913082000,"source":"_posts/mq2.md"},"zkvrrnb988voegdf":{"_id":"zkvrrnb988voegdf","content":"title: MQ 笔记之 消息持久化\ndate: 2013-08-21 23:43:37\ntags: [技术]\ncategories: MQ\n---\n>在broker中设置属性persistent=”true”(默认是true)，同时发送的消息也应该是persitent类型的。ActiveMQ消息持久化有三种方式：AMQ、KahaDB、JDBC。\n配置文件在config/jetty.xml\n<!-- more -->\n\n##一、AMQ\nAMQ是一种文件存储形式，它具有写入速度快和容易恢复的特点。消息存储在一个个文件中，文件的默认大小为32兆，如果一条消息的大小超过了32兆，那么这个值必须设置大点。当一个存储文件中的消息已经全部被消费，那么这个文件将被标识为可删除，在下一个清除阶段，这个文件被删除。默认配置如下：\n\n```   \n<persistenceAdapter>\n  <amqPersistenceAdapter directory=\"activemq-data\" maxFileLength=\"32mb\"/>\n</persistenceAdapter>\n\n```\n\n属性名称\t| 默认值\t| 描述\n--- | --- | ---\ndirectory\t| activemq-data\t | 消息文件和日志的存储目录\nuseNIO\t| true\t| 使用NIO协议存储消息\nsyncOnWrite |\tfalse |\t同步写到磁盘，这个选项对性能影响非常大\nmaxFileLength\t| 32mb\t| 一个消息文件的大小\npersistentIndex\t| true\t| 消息索引的持久化，如果为false，那么索引保存在内存中\nmaxCheckpointMessageAddSize\t| 4kb\t| 一个事务允许的最大消息量\ncleanupInterval\t| 30000\t| 清除操作周期，单位ms\nindexBinSize\t| 1024\t| 索引文件缓存页面数，缺省为1024，当amq扩充或者缩减存储时，会锁定整个broker，导致一定时间的阻塞，所以这个值应该调整到比较大，但是代码中实现会动态伸缩，调整效果并不理想。\nindexKeySize\t| 96\t| 索引key的大小，key是消息ID\nindexPageSize\t| 16kb\t| 索引的页大小\ndirectoryArchive\t| archive |\t存储被归档的消息文件目录\narchiveDataLogs\t| false\t| 当为true时，归档的消息文件被移到directoryArchive,而不是直接删除\n\n--------\n\n##二、 KahaDB\n\nKahaDB是基于文件的本地数据库储存形式，虽然没有AMQ的速度快，但是它具有强扩展性，恢复的时间比AMQ短，从5.4版本之后KahaDB做为默认的持久化方式。默认配置如下\n\n```\n <persistenceAdapter>\n        <kahaDB directory=\"activemq-data\" journalMaxFileLength=\"32mb\"/>\n </persistenceAdapter>\n\n```\nKahaDB的属性：\n\nproperty name\t| default value\t| Comments\n--- | --- | ---\ndirectory\t| activemq-data\t| 消息文件和日志的存储目录\nindexWriteBatchSize\t| 1000\t| 一批索引的大小，当要更新的索引量到达这个值时，更新到消息文件中\nindexCacheSize\t| 10000\t| 内存中，索引的页大小\nenableIndexWriteAsync |\tfalse |\t索引是否异步写到消息文件中\njournalMaxFileLength\t| 32mb\t| 一个消息文件的大小\nenableJournalDiskSyncs\t| true\t| 是否讲非事务的消息同步写入到磁盘\ncleanupInterval\t| 30000\t| 清除操作周期，单位ms\ncheckpointInterval\t| 5000\t| 索引写入到消息文件的周期，单位ms\nignoreMissingJournalfiles\t| false | \t忽略丢失的消息文件，false，当丢失了消息文件，启动异常\ncheckForCorruptJournalFiles\t| false\t|检查消息文件是否损坏，true，检查发现损坏会尝试修复\nchecksumJournalFiles\t| false |\t产生一个checksum，以便能够检测journal文件是否损坏。\n`5.4版本之后有效的属性:`\t | |\t\narchiveDataLogs\t| false\t| 当为true时，归档的消息文件被移到directoryArchive,而不是直接删除\ndirectoryArchive\t| null\t| 存储被归档的消息文件目录\ndatabaseLockedWaitDelay\t| 10000\t| 在使用负载时，等待获得文件锁的延迟时间，单位ms\nmaxAsyncJobs\t| 10000 |\t同个生产者产生等待写入的异步消息最大量\nconcurrentStoreAndDispatchTopics |\tfalse\t| 当写入消息的时候，是否转发主题消息\nconcurrentStoreAndDispatchQueues | true\t| 当写入消息的时候，是否转发队列消息\n5.6版本之后有效的属性:\t | |\t\narchiveCorruptedIndex\t| false |\t是否归档错误的索引\n\n从5.6版本之后，有可能发布通过多个kahadb持久适配器来实现分布式目标队列存储。什么时候用呢？如果有一个快速的生产者和消费者，当某一个时刻生产者发生了不规范的消费，那么有可能产生一条消息被存储在两个消息文件中，同时，有些目标队列是危险的并且要求访问磁盘。在这种情况下，你应该用通配符来使用mKahaDB。如果目标队列是分布的，事务是可以跨越多个消息文件的。\n\n每个KahaDB的实例都可以配置单独的适配器，如果没有目标队列提交给filteredKahaDB，那么意味着对所有的队列有效。如果一个队列没有对应的适配器，那么将会抛出一个异常。配置如下：\n\n```\n<persistenceAdapter>\n  <mKahaDB directory=\"${activemq.base}/data/kahadb\">\n    <filteredPersistenceAdapters>\n      <!-- match all queues -->\n      <filteredKahaDB queue=\">\">\n        <persistenceAdapter>\n          <kahaDB journalMaxFileLength=\"32mb\"/>\n        </persistenceAdapter>\n      </filteredKahaDB>\n      \n      <!-- match all destinations -->\n      <filteredKahaDB>\n        <persistenceAdapter>\n          <kahaDB enableJournalDiskSyncs=\"false\"/>\n        </persistenceAdapter>\n      </filteredKahaDB>\n    </filteredPersistenceAdapters>\n  </mKahaDB>\n </persistenceAdapter>\n\n```\n如果filteredKahaDB的perDestination属性设置为true，那么匹配的目标队列将会得到自己对应的KahaDB实例。配置如下\n\n```\n<persistenceAdapter>\n  <mKahaDB directory=\"${activemq.base}/data/kahadb\">\n    <filteredPersistenceAdapters>\n      <!-- kahaDB per destinations -->\n      <filteredKahaDB perDestination=\"true\" >\n        <persistenceAdapter>\n          <kahaDB journalMaxFileLength=\"32mb\" />\n        </persistenceAdapter>\n      </filteredKahaDB>\n    </filteredPersistenceAdapters>\n  </mKahaDB>\n </persistenceAdapter>\n\n```\n\n##三、 JDBC\n\n配置JDBC适配器\n\n```\n<persistenceAdapter>\n        <jdbcPersistenceAdapter dataSource=\"#mysql-ds\" createTablesOnStartup=\"false\" />\n</persistenceAdapter>\n\n```\ndataSource指定持久化数据库的bean，createTablesOnStartup是否在启动的时候创建数据表，默认值是true，这样每次启动都会去创建数据表了，一般是第一次启动的时候设置为true，之后改成false。\n\nMYSQL持久化bean\n\n```\n<bean id=\"mysql-ds\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n    <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n    <property name=\"url\" value=\"jdbc:mysql://localhost/activemq?relaxAutoCommit=true\"/>\n    <property name=\"username\" value=\"activemq\"/>\n    <property name=\"password\" value=\"activemq\"/>\n    <property name=\"poolPreparedStatements\" value=\"true\"/>\n</bean>\n\n```\nSQL Server持久化bean\n\n```\n <bean id=\"mssql-ds\" class=\"net.sourceforge.jtds.jdbcx.JtdsDataSource\" destroy-method=\"close\">\n   <property name=\"serverName\" value=\"SERVERNAME\"/>\n   <property name=\"portNumber\" value=\"PORTNUMBER\"/>\n   <property name=\"databaseName\" value=\"DATABASENAME\"/>\n   <property name=\"user\" value=\"USER\"/>\n   <property name=\"password\" value=\"PASSWORD\"/>\n </bean>\n\n```\nOracle持久化bean\n\n```\n<bean id=\"oracle-ds\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n\t<property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/>\n\t<property name=\"url\" value=\"jdbc:oracle:thin:@10.53.132.47:1521:activemq\"/>\n\t<property name=\"username\" value=\"activemq\"/>\n\t<property name=\"password\" value=\"activemq\"/>\n\t<property name=\"maxActive\" value=\"200\"/>\n\t<property name=\"poolPreparedStatements\" value=\"true\"/>\n</bean>\n\n```\nDB2持久化bean\n\n```\n<bean id=\"db2-ds\" class=\"org.apache.commons.dbcp.BasicDataSource\"  destroy-method=\"close\">\n      <property name=\"driverClassName\" value=\"com.ibm.db2.jcc.DB2Driver\"/>\n      <property name=\"url\" value=\"jdbc:db2://hndb02.bf.ctc.com:50002/activemq\"/>\n      <property name=\"username\" value=\"activemq\"/>\n      <property name=\"password\" value=\"activemq\"/>\n      <property name=\"maxActive\" value=\"200\"/>\n      <property name=\"poolPreparedStatements\" value=\"true\"/>\n</bean>\n\n```\n\n\n-----\n>本博文from 淮少吧 \n\n\n","mtime":1377913082000,"source":"_posts/mq3.md"},"8yyf6ku7px2w0zti":{"_id":"8yyf6ku7px2w0zti","content":"title: 工作四年多了\ndate: 2013-08-08 17:16:03\ntags: [情感]\ncategories: 情感\n---\n##工作好几年了 谈谈自己的一些感想吧\n\n最近几件事情触动挺大的，\n<!--more-->\n\n1：跟侯的差距越来越远了， 不到三年 侯做到了很多我没做到的事情1-)自考了北大计算机系 2-)结识了年薪几十万的漂亮嫂子 3-）拿到了驾照 4-）在燕郊买了房子\n\n虽然彼此间还是隔三差五的聚聚，但是间隔越来越长了，大家都在忙，而我是真的在瞎忙 忙的没有任何意义。\n\n2：家里的压力，家里的压力从催着找女朋友结婚 到现在的赶紧攒首付买房子，之前很天真的甚至有些自私的想 不结婚不要孩子，可是现在觉得真的很对不起两个老人的\n\n3：同事和朋友，现在还记得几年前 sally姐说的那句话 同事永远成不了朋友。 有一次跟周妈谈起旺哥为什么不喜欢带新人，周妈谈了一口气说 旺旺是被现在这个社会伤的太深了了。虽然不太清楚在旺哥身上发生过什么 但是 回想这几年发生在自己身上的事情 也能体会的到写。现在这年头 不要期待着知恩图报 祈求不要恩将仇报就好了。 \n\n4：多一事不如少一事。  自己的经历应该放到有价值的人和事上面。 \n\n5：金钱虽然不是唯一的判断标准 但是却是最有效的衡量一个人的办法。\n\n6：珍惜零散的时间 \n\n7：英语 very important\n\n8：一些事情心里明白就行了 不要说出来\n\n{% img right profile http://img.my.csdn.net/uploads/201101/25/3619941_1295933551y8U4.jpg 300 500 昔日的小伙伴 %} ","mtime":1377913082000,"source":"_posts/mood.md"},"fi9g1v227s4tkhkw":{"_id":"fi9g1v227s4tkhkw","content":"title: svn错误：SVN remains in conflict?\ndate: 2013-09-03 13:49:56\ntags: [技术]\ncategories: \n- svn\n---\n\n解决如下:\n\n```\nsvn remove --force yourfilename\nsvn resolve --accept=working  yourfilename\nsvn commit -m \"\"\n\n```","mtime":1379221447000,"source":"_posts/svn3.md"},"0praus6pt5ecae09":{"_id":"0praus6pt5ecae09","content":"title: 读 林锐博士的项目管理 笔记1\ndate: 2013-09-09 16:07:57\ntags: [技术]\ncategories: 项目管理\n---\n##软件挣钱难的问题\n\n<!-- more -->\n###一、承接合同项目，为甲方开发软件系统。\n\n1. 市场上能够承接到的合同项目，利润很小。而高利润的项目则被有权势的人或机构掌控。 \n\n2. 项目需求和验收受制于客户。开发过程中，客户会不断变更需求，导致开发方不断修改软件，项目验收被不断地延后，开发方成本（包括机会成本）越来越高。\n\n3. 缺乏规模复制效益。由于合同项目都是针对特定客户（甲方）的特定需求而签订的，即使做成功了一个合同项目，也很难“复制这个项目”直接卖给下一个客户。\n\n###二、开发并销售通用软件产品\n\n1. 凡是面向个人的通用软件产品，由于盗版原因，几乎无法靠卖软件来挣钱。\n\n2. 只有企业级软件产品不容易被大量盗版，可以走“通用软件产品盈利模式”，难度非常高。开发方必须把自己打造成为“企业级应用的领导者”，否则客户不信任你的方法和产品，产品就无法通用。于是客户提出的个性化需求越来越多，回到了“合同项目盈利模式”。 \n\n###三、运营模式\n\n1. 互联网公司的业务太容易被模仿，同质化竞争严重。每个领域都死掉了成千上万的相同业务的互联网公司，最终只有少数几家可以活下来，极大地浪费社会财富。\n\n2. 互联网公司的另一个大缺点是太浮躁，过分追求快而导致根基不扎实，国内绝大多数互联网公司的软件研发管理，要比传统软件公司混乱得多。\n\n---\n\n>软件企业要想多挣钱，靠“开源节流”。“开源”主要靠优化盈利模式，使得现有的技术和资源产生更高的效益。“节流”主要靠改进管理，使企业的所有经营环节更加合理，减少不必要的成本，省下来的钱也就成了利润","mtime":1379221447000,"source":"_posts/project0.md"},"wehgpu3v8ifrislh":{"_id":"wehgpu3v8ifrislh","content":"title: MQ 笔记之 mac 下安装环境\ndate: 2013-08-20 17:47:34\ntags: [技术]\ncategories: MQ\n---\n##下载\n[从下载地址中下载包](http://www.apache.org/dyn/closer.cgi?path=/activemq/apache-activemq/5.8.0/apache-activemq-5.8.0-bin.tar.gz)\n解压包然后把包放到一个自己不会手一抖就删掉的位置，此处我放到了本地的document下\n如下图\n<!-- more -->\n{% img left http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7uav8h7lbj20o80gkjtw.jpg 200 300 图片%}\n## 添加环境到path \n把/你的保存路径/apache-activemq-5.8.0/bin/activemq 添加到 PATH 中 \n\n0. cd \n1. 执行 vi .profile \n2. 输入 i \n3. 插入 export MQ=/你的路径/apache-activemq-5.8.0/bin/macosx/activemq\n4. wq\n5. source .profile\n\n## 启动mq\n$Mq start\n输入账号 admin 密码  admin\n\n**注意** 如果用代理上网 请把网络环境设置下 如下图\n{% img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubcv9nx0j20oa08egmc.jpg 200 300 网络配置 %}\n\n##查看启动效果\n{% img http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubfs7cg1j21ga0oe0yw.jpg 200 300 启动效果 %}\n\n## 基本配置\nconf/jetty.xml\n```\n<bean id=\"securityConstraint\">\n \n        <property name=\"name\" value=\"BASIC\" />\n \n        <property name=\"roles\" value=\"admin\" />\n \n        <property name=\"authenticate\" value=\"false\" />\n \n</bean>\n\n```\n此处可以配置登陆用户权限\n\n\n```\n <property name=\"connectors\">\n            <list>\n                <bean id=\"Connector\" class=\"org.eclipse.jetty.server.nio.SelectChannelConnector\">\n                    <property name=\"port\" value=\"8161\" />\n                </bean>\n            </list>\n </property>\n\n```\n此处用来修改端口号\n\n\n\n\n\n","mtime":1377913082000,"source":"_posts/mq1.md"},"bweoadqme17dz6ht":{"_id":"bweoadqme17dz6ht","content":"title: MQ 笔记之 发送接受实例\ndate: 2013-08-23 10:27:45\ntags: [技术]\ncategories: MQ\n---\n> mq 支持多种发送格式  BytesMessage  MapMessage ObjectMessage TextMessage StreamMessage等\n<!-- more -->\n\n本文章以 MapMessage 和 ObjectMessage 为例\n\n**注意 发送ObjectMessage时  接受实例必须相同类名**\n\n\n##发送实例\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n\npublic class Send {\n\n\n public static void main(String[] args) throws Exception {\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n\n        Connection connection = connectionFactory.createConnection();\n        connection.start();\n\n        Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);\n        Destination destination = session.createQueue(\"hf\");\n\n        MessageProducer producer = session.createProducer(destination);\n       for(int i=0; i<3; i++) {\n//            MapMessage message = session.createMapMessage();\n//           message.setLong(\"count\", new Date().getTime());\n//            message.setObject(\"hf\",new SendData());\n      ObjectMessage message = session.createObjectMessage();\n      message.setObject(new SendData());\n//           message.setBytes(\"count\", getTestData(1));\n            Thread.sleep(1);\n            //通过消息生产者发出消息\n            producer.send(message);\n        }\n        session.commit();\n        session.close();\n        connection.close();\n    }\n}\n\n\n##接收实例\n\n```\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\npublic class Recive {\n\npublic static void main(String[] args) throws Exception {\n    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();\n\n    Connection connection = connectionFactory.createConnection();\n    connection.start();\n\n    final Session session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);\n    Destination destination = session.createQueue(\"hf\");\n\n    MessageConsumer consumer = session.createConsumer(destination);\n/*//listener 方式\nconsumer.setMessageListener(new MessageListener() {\n\n    public void onMessage(Message msg) {\n        MapMessage message = (MapMessage) msg;\n        //TODO something....\n        System.out.println(\"收到消息：\" + new Date(message.getLong(\"count\")));\n        session.commit();\n    }\n\n});\nThread.sleep(30000);\n\t*/\n\tint i=0;\n\twhile(i<100) {\n\ti++;\n\t//            MapMessage message = (MapMessage) consumer.receive();\n\tObjectMessage message = (ObjectMessage) consumer.receive();\n\n\tsession.commit();\n\n\t//TODO something....\n\t//             System.out.println(\"收到消息：\" + arrayToString(message.getBytes(\"count\")));\n\n\tSystem.out.println(\"收到消息：\" + ((SendData) message.getObject()).getDateStr());\n\t}\n\n\tsession.close();\n\tconnection.close();\n}\n\n//    public static final String arrayToString(byte[] bytes)\n//    {\n//        StringBuffer buff = new StringBuffer();\n//        for (int i = 0; i < bytes.length; i++)\n//        {\n//            buff.append(bytes[i] + \" \");\n//        }\n//        return buff.toString();\n//    }\n}\n\n```\n\n##传递参数\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * Created with IntelliJ IDEA.\n * User: jason\n * Date: 13-8-22\n * Time: 下午5:21\n * To change this template use File | Settings | File Templates.\n */\npublic class SendData  implements Serializable {\n\n//    private  static  final  long serialVersionUID = -23235245213533L;\n\n    private  byte[] buffer;\n\n    private String dateStr;\n\n    public SendData() {\n        setBuffer(null);\n        setDateStr(null);\n    }\n\n    public byte[] getBuffer() {\n        return buffer;\n    }\n\n    public String getDateStr() {\n        return dateStr;\n    }\n\n    public void setDateStr(String dateStr) {\n        this.dateStr = String.valueOf(new Date().getTime());\n    }\n\n    public void setBuffer(byte[] buffer) {\n        System.out.print(\"begin \\n\");\n        byte [ ] buffers = new byte[1024*1];\n        for (int i=0 ;  i< buffers.length ;i++)\n            buffers[i] = Byte.parseByte(\"2\");\n        System.out.print(\"end \\n\");\n        this.buffer = buffers;\n    }\n\n\n}\n\n","mtime":1377913082000,"source":"_posts/mq5.md"},"y5069mh39losg1kd":{"_id":"y5069mh39losg1kd","content":"title: MQ 笔记之 游标 及其游标优化\ndate: 2013-08-22 09:38:51\ntags: [技术]\ncategories: MQ\n---\n\n##概观 \n>在ActiveMQ的Broker中，光标用来持有一批在内存等待发送目标地址的消息。默认情况下这小消息被从存储器取出只想一个cursor(存储光标)  \n<!-- more -->\n5.0.0版本后，Activemq实现了一种新的内存模型来防止慢消费者阻塞快速生产者。通常消息在未消费或者发送后未收到消费者的确认信息时都会持久保存消息到存储中。当有消费者来消费消息时，broker会分页一批一批的从存储中取出消息，放入消息处理队列。游标就是指向下次批量获取消息时的存储位置。   \n\nctiveMQ有另一种游标实现，VM cursor，在某些情境下非常快。VM cursor是，进入的消息直接关联cursor，同时存储到消息存储器中。（关联cursor的同时存储到消息存储器中）。如果消费者（consumer）非常快，可以跟的上消息流的话，VM cursor会工作的非常好。但是，对于慢消费者，这个策略就不是那么有效了。VMcursor被积压的消息填满，同时它可能会去调用流控制去抑制producer生产message。\n\n##根据游标的保存方式不同，可分为三种类型：\n\n###Store-based cursors \nbroker默认采用的游标。它将游标信息保存在存储中。针对速度不同的消费者，这种游标机制采取的方式不同。对于快速消费者，因为消费速度很快，存储中 的消息数量会很少，所以不需要游标。这时，消息发送到broker时，先保存在持久存储中，然后直接发送给了消费者。而对于慢消费者，消息的持久存储中会 保存大量的消息，所以需要使用游标来指定下一次批量读取消息的位置。  \n\n{% img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v81y31hnj20ip04qaaj.jpg  Store-based实现原理图 300 200 %}\n **图一：**\n\n \t消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedHashMap，如果没有可用内存，则走路径2，当需要消息的时候，直接从消息存储的介质里每次读取一批消息，然后存入LinkedHashMap。\n\n### VM cursors \n若消费者能跟上生产者生产的速度，这时持久存储中消息虽然不是很多，但是若能也能在内存中保存一些游标，对获取存储中的消息的性能会有很大的提升。 \n那么VM Cursors在ActiveMQ4.x中是如何工作的呢？发送消息保存在内存中，并在需要的时候传递给调度队列。这可以是非常快的，但也有不利的一面，不能够处理非常缓慢的消费者或消费者已经很长一段时间处于非活动状态：   \n{%img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v878r0ahj20iu04tjrr.jpg  file实现原理图 300 200%}\n  **图二：**\n\n\t消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedList，如果没有可用内存，则走路径2，把消息写入临时文件中，当需要消息的时候，直接从临时文件中读写一批，然后送入LinkedList。\n\n\n### File-based cursors \n对VM cursors 的一种改进。当内存中的游标达到一定限额后，就会将一些游标存储到磁盘上的临时文件中。使用这种类型的游标时，消息储存可能会变慢，但消费者处理一般都会更快。通过缓冲到磁盘，它可以让消息代理来处理不受内存限制的大量消息，而生产者发送消息的速度会受到影响：\n **图三**\n\n {%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7v8airx6dj20it04sjrl.jpg vm 实现原理 300 200%}\n \t消息接收后，首先完成消息存储的工作，如(1)所示，然后直接把消息存放在内存中的LinkedList。\n\n\n###Paging for Non-Persistent Messages（非持久性的消息分页调度）\nStore based cursor也可以处理非持久性的消息，也就是没有存储在磁盘中的消息，非持久性消息被直接传递给游标，所以Store based cursor也只是嵌入了File based cursor的功能。\n\n\n## 3种消息cursor的比较\n消息cursor类型 | 性能 |稳定性 | 最佳使用场景\n---| --- | --- | --- |\nStore-based | 当内存不够时，需要进行1次消息存储操作，性能在3种方式中居中 | 最好 | activeMQ默认使用该cursor，因为它能满足大部分场景需要\nFile | 当内存不够时，需要进行2次消息存储操作，并且在删除消息的时候也就相应的要删除2次，性能在3种方式中最差 | 居中 | 主要用在当消息存储慢(如消息是放在数据库里)，并且消费者相对快的情况下\nVM | 在内存够的情况下，3种message cursor性能一样 | 最容易出现内存溢出的问题 | 很快，但不能处理慢消息消费者\n \n###基于存储的消息指针_测试结果\n\n测试方法 | 结果说明 | 是否通过 | 备注\n--- | --- | --- | --- |\n开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送,不接收，因为是默认的，所以不用在服务器端配置。 | 1．对于非持久化消息，一定数量之后，也会产生临时文件。 2．对于持久化的消息，则适用该方式的消息指针，直到达到磁盘空间的设置上限。 |  是 | \n\n###VM消息指针_测试结果\n\n测试方法 | 结果说明 | 是否通过 | 备注 \n--- | --- | --- | --- |\n开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：cursore 队列中存储到一定量消息的时候，broker不再接收生产者发送过来的消息，56W左右，broker也不报错，客户端也不报错。 |  是  | 若设置producerflowControl=false，则消息数量持续增长，直到broker报错：WARN  AMQMessageStore  - Message could not be added to long term store: Java heap space java.lang.OutOfMemoryError: Java heap space \n\n\n###基于文件的消息指针_测试结果\n\n测试方法 | 结果说明 | 是否通过 | 备注\n--- | --- | --- | --- |\n开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：fileQueueCursor | 一段时间之后，broker打印出一信息：INFO MonetStore - Monet Store using data directory \"C:\\Activemq 5.1\\bin\\..  \\data\\localhost\\tmp_storage\"  临时文件被放置在tmp_storage目录下 | 是 |\n \n \n \n\n \n \n \n \n\n\n-----------\n\n##Configuring Cursors\nActivemq默认使用store-based游标。当然也可为不同的Destination修改游标策略。通过修改destinationPolicy节点来更改默认配置。  \ndestinationPolicy节点包含多ge policyMap节点。  \npolicyMap包含一个policyEntries节点，policyEntries节点包含多个policyEntry 节点。policyEntry就是具体的一个游标策略了。  \nTopics的消费者分为持久订阅者和临时订阅者，所以有两套配置。Queues只有一类消费者，所以只有一套配置。\n对于持久订阅者可以使用PendingDurableSubscriberMessageStoragePolicy来指定游标策略。可配置的策略有vmDurableCursor和fileDurableSubscriberCursor. \n\n\n**对于临时订阅者可以使用pendingSubscriberPolicy 来指定。可配置的策略有vmCursor和fileCursor。下面是关于Topics的一些xml配置：**\n\n```\n<beans ... >\n<broker ...>\n    ...\n<destinationPolicy>\n<policyMap>\n<policyEntries>\n<policyEntrytopic=\"com.iona.>\">\n            ...\n<pendingSubscriberPolicy>\n<vmCursor/>\n</pendingSubscriberPolicy>\n<PendingDurableSubscriberMessageStoragePolicy>\n<fileDurableSubscriberPolicy/>\n</PendingDurableSubscriberMessageStoragePolicy>\n            ...\n</policyEntry>\n          ...\n</policyEntries>\n</policyMap>\n</destinationPolicy>\n    ...\n</broker>\n  ...\n</beans>\n\n```\n\n**Queues 同样也有vm和file两种类型的游标存储策略。pendingQueuePolicy 节点的可配置子节点有vmQueueCursor和fileQueueCursor**\n\n```\n<beans ... >\n<broker ...>\n        ...   \n<destinationPolicy>\n<policyMap>\n<policyEntries>\n<policyEntryqueue=\"com.iona.>\">  \n                ...   \n<pendingQueuePolicy>\n<vmQueueCursor/>\n</pendingQueuePolicy>\n                ...   \n</policyEntry>\n              ...   \n</policyEntries>\n</policyMap>\n</destinationPolicy>\n        ...   \n</broker>\n      ...   \n</beans>\n\n```\n\n\n### 配置vmcursor：\n下面配置了一个borker的所有topic和queue都使用了vmCursor\n\n```\n<broker ... >\n  ...\n  <destinationPolicy>\n    <policyMap>\n      <policyEntries>\n        <policyEntry topic=\">\">\n          <pendingSubscriberPolicy>\n            <vmCursor />\n          </pendingSubscriberPolicy>\n        </policyEntry>\n        <policyEntry queue=\">\">\n          <pendingSubscriberPolicy>\n            <vmCursor />\n          </pendingSubscriberPolicy>\n        </policyEntry>\n      </policyEntries>\n    </policyMap>\n  </destinationPolicy>\n  ...\n</broker>\n\n```\ntopic和queue都使用了通配符【>】,这个匹配所有的目标名称。你可以根据情况指定一些选择目标的模式。但是VM Cursor仅仅适用于那些消费者可以跟得上目标消息节奏的这种情况。\n\n\n-------\nhttp://www.cnblogs.com/kaka/archive/2012/07/24/2606699.html\nhttp://netcomm.iteye.com/blog/470585\n","mtime":1377913082000,"source":"_posts/mq4.md"},"u4p5qnl0haor2pb3":{"_id":"u4p5qnl0haor2pb3","content":"title: svn 打 tag\ndate: 2013-09-03 14:04:29\ntags: [技术]\ncategories: \n- svn\n---\n```\nsvn cp . http://svnserver/svn/pingan/client/iPhone2/tags/appstore_v1.010_rc01  -m \"1.010\"\n\n```","mtime":1379221447000,"source":"_posts/svn7.md"},"6z05cinggcrmpftn":{"_id":"6z05cinggcrmpftn","content":"title: svn 回退版本\ndate: 2013-09-03 14:02:35\ntags: [技术]\ncategories: \n- svn\n---\n```\nsvn merge -r rHEAD:4367 http://svnserver/svn/pingan/client/iPhone2/trunk/\n\n```\n本地回退\n\n```\nsvn ci -m \"提交\"\n\n```","mtime":1379221447000,"source":"_posts/svn6.md"},"k3kujcre27np6so0":{"_id":"k3kujcre27np6so0","content":"title: svn  临时 切换用户 命令\ndate: 2013-09-03 13:56:11\ntags: [技术]\ncategories: \n- svn\n---\n作为team leader  有时候需要帮别人解决技术问题，尝尝再别人的电脑上改了某些代码，提交的时候遇到了问题，就是怎样临时用自己的账户提交，提交完后 用不影响同事的电脑原有的svn账号\n<!-- more -->\n\n下面的可以解决这个问题\n\n在所有命令下强制加上--username 和--password选项。 \n\n例如：\n\nl```\nsvn ci --username hufeng --password ####\n\n```\n","mtime":1379221447000,"source":"_posts/svn5.md"},"bhr015nfjivvr64p":{"_id":"bhr015nfjivvr64p","content":"title: svn 版本恢复命令行操作（转）\ndate: 2013-09-03 13:51:18\ntags: [技术]\ncategories: \n- svn\n---\n\nsvn没有恢复旧版本的直接功能，不过可以使用svn merge命令恢复。\n比如说当前HEAD为14，而我要恢复成10版本，怎么做？用svn merge：\n<!-- more -->\n```\nsvn update\nsvn merge --revision 14:10\nsvn commit -m \"restore to revision 10\"\n\n```\n可能会很奇怪，因为不理解为什么合并能恢复旧版本。\n\n这里要理解一个关键点，就是svn merge的原理。merge是比较指定版本的差异，然后把这些差异应用到本地工作副本，而-r后的14:10，是指相对于版本14来说版本10的变化（注意，这个版本的次序很重要。），也就是相对版本14，我版本10添加了哪些文件或目录，以及哪些文件添加了哪些行删除了哪些行。\n\n由于在客户端提交应用程序时的误操作，导致修改了基线版本，此处利用两个命令来进行恢复：\n\n1. 将客户端恢复合并到指定版本：\n\n```\nsvn merge -r 112:111 svn://192.168.0.119/UBoot/trunk/u-boot-1.3.3\n\n```\n此步骤将下位机由112恢复到111版本：\n\n2. 重新修订基线版本\n\n```\nsvn commit -m \"Undoing change committed in r111.\"\n\n```\n此步骤将恢复后的111版本提交，但是此时的版本号为113","mtime":1379221447000,"source":"_posts/svn4.md"},"hh2lhianymkejv1x":{"_id":"hh2lhianymkejv1x","content":"title: ios 笔记之 内购\ndate: 2013-08-21 09:18:13\ntags: [技术]\ncategories: ios\n---\n> 昨晚同事拿了一个app 发现其app 内部页面打开了appstore  并没有唤起手机自带的appstore， 刚开始以为是用webview 加载的\n<!-- more --> ，可是自己些了一个demo 发现并不是那样一回事 用webview 加载appstore 地址 会被js 自动吊起本地的appstore，\n下面是我的发给同事的邮件 直接贴下来\n\n我们都绕了弯路 一直以为是用webview 加载的。 我下班做了测试 发现用webview 加载appstore的地址 ，ios 会根据User-Agent 自动判断 唤起本地的app store，其效果跟用[[UIApplicationsharedApplication] openURL:[NSURL URLWithString:@\"\"]];是一样的。\n\n后来我尝试改写User-Agent  发现打开的页面是电脑打开的页面一样的 并不是我们通过手机 打开app store 看到的页面。\n\n后来我看苹果的文档 发现 他们提供了一个类SKStoreProductViewController专门来干这个事情的\n\n[https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html)\n\n\n实现效果如下图\n\n{% img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1e7u10xs9nwj20m015c0x9.jpg 250 600  %}\n\n##下面是关键代码\n\n```\n需要引入的\n#import <StoreKit/StoreKit.h>\ndelegate 为SKStoreProductViewControllerDelegate\n\n\n调用方式\n    [self openAppWithIdentifier:@\"592043421\"];\n\n\n\n#pragma mark - SKStoreProductViewControllerDelegate\n- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController {\n    [viewController dismissViewControllerAnimated:YES completion:^{\n    }];\n}\n\n\n\n\n\n\n- (void)openAppWithIdentifier:(NSString *)appId {\n    SKStoreProductViewController *storeProductVC = [[SKStoreProductViewController alloc] init];\n    storeProductVC.delegate = self;\n    \n    NSDictionary *dict = [NSDictionary dictionaryWithObject:appId forKey:SKStoreProductParameterITunesItemIdentifier];\n    [storeProductVC loadProductWithParameters:dict completionBlock:^(BOOL result, NSError *error) {\n        if (result) {\n            [self presentViewController:storeProductVC animated:YES completion:nil];\n        }\n    }];\n}\n\n```\n","mtime":1377913082000,"source":"_posts/appstore.md"},"oag4ya7q6ylt968n":{"_id":"oag4ya7q6ylt968n","content":"title: svn命令总结\ndate: 2013-09-03 14:08:30\ntags: [技术]\ncategories: \n- svn\n---\n\n##1. 创建分支\nsvn cp http://svn.trunk/ http://svn.branches/  –m “create a branch”\n<!-- more -->\n##2. 合并分支\n\n###1、在某个branch里合并trunk上的修改，\n进入分支目录，然后执行：\n\n```\nsvn merge http://svn/repo/trunk\n\n```\n###2、在trunk上合并branch的修改。\n进入trunk目录，然后执行\n\n```\nsvn merge --reintegrate http://svn/repo/branches/branch1\n\n```\n##3. 将文件checkout到本地目录\n\nsvn checkout path（path是服务器上的目录）\n```\n例如：svn checkout svn://192.168.1.1/pro/domain\n简写：svn co\n\n```\n\n##4. 往版本库中添加新的文件\n\nsvn add file\n```\n例如：svn addtest.php(添加test.php)\nsvn add *.php(添加当前目录下所有的php文件)\n```\n\n##5. 将改动的文件提交到版本库\nsvn commit -m “LogMessage“ [-N] [--no-unlock] PATH(如果选择了保持锁，就使用–no-unlock开关)\n\n```\n例如：svn commit -m “add test file for my test“ test.php\n简写：svn ci\n```\n\n##6. 加锁/解锁\n\nsvn lock -m “LockMessage“ [--force] PATH\n\n```\n例如：svn lock -m “lock test file“ test.php\nsvn unlock PATH\n```\n\n##7. 更新到某个版本\n\nsvn update -r m path\n\n例如：\n```\nsvn update如果后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本。\nsvn update -r 200 test.php(将版本库中的文件test.php还原到版本200)\nsvn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)\n```\n\n简写：svn up\n\n##8.查看文件或者目录状态\n\n1. svn status path（目录下的文件和子目录的状态，正常状态不显示）\n\n【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】\n\n2. svn status -v path(显示文件和子目录状态)\n第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。  \n**注：** svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。\n简写：svn st\n\n##9.删除文件\n\nsvn delete path -m “delete test fle“\n\n例如：\n```\nsvn delete svn://192.168.1.1/pro/domain/test.php -m “delete test file”\n或者直接svn delete test.php 然后再svn ci -m ‘delete test file‘，\n```\n\n推荐使用这种简写：svn (del, remove, rm)\n\n##10.查看日志\n\nsvn log path\n例如：\n```\nsvn log test.php 显示这个文件的所有修改记录，及其版本号的变化\n```\n\n##11.查看文件详细信息\n\nsvn info path\n\n例如：\n```\nsvn info test.php\n```\n\n##12.比较差异\nsvn diff path(将修改的文件与基础版本比较)\n\n例如：\n```\nsvn diff test.php\n```\nsvn diff -r m:n path(对版本m和版本n比较差异)\n\n例如：\n```\nsvn diff -r 200:201 test.php\n```\n简写：svn di\n\n##13.将两个版本之间的差异合并到当前文件\nsvn merge -r m:n path\n例如：\n```\nsvn merge -r 200:205 test.php（将版本200与205之间的差异合并到当前文件，但是一般都会产生冲突，需要处理一下）\n```\n##14.SVN 帮助\nsvn help  \nsvn help ci  \n\n##15.版本库下的文件和目录列表\n\nsvn list path\n显示path目录下的所有属于版本库的文件和目录  \n简写：svn ls\n        \n##16.创建纳入版本控制下的新目录\nsvn mkdir: 创建纳入版本控制下的新目录。\n\n用法: \n\n1. mkdir PATH…\n2. mkdir URL…\n\n创建版本控制的目录。\n\n1. 每一个以工作副本 PATH 指定的目录，都会创建在本地端，并且加入新增调度，以待下一次的提交。\n2. 每个以URL指定的目录，都会透过立即提交于仓库中创建。在这两个情况下，所有的中间目录都必须事先存在。\n\n##17.恢复本地修改\nsvn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:  \n用法: revert PATH…  \n注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录\n        \n##18.代码库URL变更\n\nsvn switch (sw): 更新工作副本至不同的URL。\n\n用法: \n\n1. switch URL [PATH]\n2. switch –relocate FROM TO [PATH...]\n\n  * 更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的方法。\n\n  * 改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动(比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用这个命令更新工作副本与仓库的对应关系。\n \n##19.解决冲突\n\nsvn resolved: 移除工作副本的目录或文件的“冲突”状态。 \n\n用法: resolved PATH…\n\n**注意:** 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的\n相关文件，然后让 PATH 可以再次提交。\n         \n##20.输出指定文件或URL的内容。\n\nsvn cat 目标[@版本]…如果指定了版本，将从指定的版本开始查找。  \n\nsvn cat -r PREV filename > filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)  \n\n\n","mtime":1379221447000,"source":"_posts/svn9.md"},"1t2roib69ztyeurh":{"_id":"1t2roib69ztyeurh","content":"title: 散文\ndate: 2013-08-08 10:29:16\ntags: 情感 \n---\n##浮华过后，心若沉浮浅笑安然\n生活或许是一件艺术品，需懂得欣赏，意中细品，学会经受。<!--more-->人生似一场追梦，那就是无数个美丽的梦而创造。人生常在繁华中等待，只不过每个人都在等待一个自己想要的未来。人生的迁徙，沉重着你的步履，有些感怀让你沉浸。曾让你迷失了方向，繁华落幕后，空山流水静其身，花开似无情，花落去留意，放眼望去，世间的喜悲离合聚散相依，匆匆如尘埃里的一颗沙粒，生命的深度，靠心去我体悟，生命的宽度，需魅力去赞颂。\n\n浮华沉寂陌生的城市，穿越年华的酸楚，风停了，雨骤了，心倦了，等待与思念的相互侵蚀，生命的前行，梦的边缘，思绪舞动一隅的嗔怨。行走的日光倾城，常伴有风的抚慰，雨的湿浸，山水的同路，莲的独隅，红尘碾转，自断不了纷争，待过忘川时，不过淡似轻风，花开催人老，纵马须恣意，清浅仲夏煮一壶清茶，待坐而品茗，静看花开花落，笑看云卷亦舒。\n\n今夕何夕，尘缘路上的回眸一笑，注定了浅笑安然。流年似水，生命的时光中，因为有缘相识，荒草丛生的原野上，没有早一步，晚一步，这就是缘。夏雨微凉，一袭雨过，岁月氤氲了一帘幽梦，芬芳轻盈着一执而念的光阴，生活缱绻起了风景，流年浮华过后，\"此情可待成追忆，只是当时已惘然\".\n\n心最柔软的地方，穿过了心刺的屏障，曾为一朵玫瑰而绽放，蜿蜒寂寞的藤，月光隐约着浪漫的惆怅，穿越横亘的流浪，时间煮雨，回忆终究会让年华淡泊，活着也许是一种修行，时光静好，品一茗清茶，落花无言，人淡如菊，润一份心境，携一缕阳光，让芳华依旧绽放。字里行间的缠绵，泪痕迭起了四季的轮回，愿得一个人，白守不分离，铺满诗意的路径，夜如此静谧，带伤的诗句常娇嗔着粉饰，步伐太急，却忘了缓缓停下来让心安祥。\n\n山与水的缠绵，任流音乐的浮想，清寂时常敲碎夜的散漫，凄迷的烟雨里，水滴的顺势而滑，水声伴风雨的飘渺芳飞，无垠的夜空，静静的聆听，繁琐打搅，细密的疏雨，意境的恰入，飘散的雨滴，透过肌肤直抵心深处，奈何雨的朦胧，相思成林泪千行。无情的冷风常拔弄着心弦，溅湿的思愁，陌路的不在相见，这个季，风儿依柔，雨儿心醉，满目的寒殇，素色时光的轻狂，喧哗背后的沉静，简单的真谛，心若沉浮，此事不关山与月。\n\n浮华掠影后，静静的听雨，感风的倾诉，世界太喧闹，已至于背离了自己，沉静中的超脱，不常泛滥，无意的碰触，深知心里的冬天时常接伴，甚至盛夏炎炎，那份落韵的雪，也会勾画着伤感的景致。卑微轻触着虚无，平淡晕染着凄冷。如若没有那么多牵扯，也不会有那么多眷念，不用去刻意与深究，这个世界本就复杂，盼一份温暖，守一份静染，只愿在高山流水间吟诵，世间最难识是情，最难诉的是痴。\n\n生命总有尽头，心灵总需要出口，每个人身上都有一把锁，有人说寂寞是种狂欢，但真正的寂寞是无法用热闹来填埋，只有你为心灵找到了决口，上锁的心慢慢绽放，才能真正的释怀，人之所以挣扎与纠结，是把钥匙丢了，但希望总在远方起航心若沉浮，浅笑安然。\n\n\n<!-- ![](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg)-->\n<!-- {% img http://placekitten.com/890/280 %}-->\n{% img right http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg 300 400 壮壮 %}\n<!-- {% img right http://placekitten.com/300/500 150 250 Place Kitten #3 %}\n{% img right http://placekitten.com/300/500 150 250 'Place Kitten #4' 'An image of a very cute kitten' %} -->\n\n\n","mtime":1377913082000,"source":"_posts/散文.md"},"j2po0rhjlig6midm":{"_id":"j2po0rhjlig6midm","content":"title: svn错误local add incoming add upon merge\ndate: 2013-09-03 14:06:15\ntags: [技术]\ncategories: \n- svn\n---\n\n在svn命令行merge之后文件经常会出现local add, incoming add upon merge问题，导致无法提交，可以通过以下命令解决冲突 \nSummarizing to resolve the tree conflict committing your working dir with svn client 1.6.x you can use: \n<!-- more -->\n```\nsvn resolve --accept working -R . \n\n```\nwhere . is the directory in conflict.\n","mtime":1379221447000,"source":"_posts/svn8.md"},"vg0akxzmqs3wbm2c":{"_id":"vg0akxzmqs3wbm2c","content":"title: New Page\ndate: 2013-08-04 18:24:33\n---\n","mtime":1377913082000,"source":"new-page/index.md"},"b5clzjzmm9rhfirg":{"_id":"b5clzjzmm9rhfirg","content":"title: ios开发之你真的了解了KVC吗？\ndate: 2013-09-23 18:51:01\ntags: [技术]\ncategories: ios\n---\n>之前一直以为自己了解KVC 其实只是井底之蛙啦，真正的要把KVC原原本本的说出来还真的不是一件简单的事情。于是今天写下这边文章，告诫自己要知其然还要知其所以然。\n<!-- more -->\n\n##一.KVC的基本概念\nKey-value coding,它是一种使用字符串标识符，间接访问对象属性的机制,而不是直接调用getter 和 setter方法。通常我们使用valueForKey 来替代getter 方法，setValue:forKey来代替setter方法。\n\n下面是使用KVC 和 不使用 KVC的代码对比\n\n\tPersion *persion =  [ [Persion alloc] init ];\n\n\t//不使用KVC\n\tpersion.name = @\"hufeng\" ;\n\n\t//使用KVC的写法\n\t[persion  setValue:@\"hufeng\" forKey:@\"name\"];\n\n看出区别来了吗？你可能会说 你写的太简单了，我们实际用的时候不可能有这样复杂的类，下面我们写个复杂点的：我们有一个人 这个人有一个手机类 这个手机类 有一个电池类 我们要获取这个电池类 比之前复杂了吧。\n\n没有KVC \n\n\tPersion *persion =  [ [Persion alloc] init ];\n\n\tPhone *phone = persion.phone;\n\n\tBattery *battery = phone.battery;\n\n使用KVC\n\n\tBattery *battery = [persion valueForKeyPath: @\"phone.battery\" ];\n**注意- valueForKeyPath 里面的值是区分大小写的，你如果写出Phone.Battery 是不行的 **\n\n说到这里你可能会问 我能不能对 NSArray 调用KVC吗？ 答案是否定的，因为array 没有keys啊，但是你可以对array里面的item 使用KVC。\n\nKVC 最常用的还是在序列化和反序列话对象。我们经常需要把json字符串反序列化成我们想要的对象 下面是一个例子 将字典用NSKeyedArchiver 序列化成对象\n\n\n\t- (id)initWithDictionary:(NSDictionary *)dictionary {\n\n\t    self = [self init];\n\n\t    if (self){\n\n\t        [self setValuesForKeysWithDictionary:dictionary];\n\n\t    }\n\n\t    return self;\n\n\t}\n\n**注意 这里有一个坑 当我们setValue 给一个没有定义的字典值（forUndefinedKey）时 会抛出NSUndefinedKeyException异常的 记的处理此种情况**\n\n还有一个需要注意的是KVC 并没有类型检验，毕竟Object-C 还是动态的啦。 还是看下面的代码吧\n\n\t[persion setValue:[NSNumber numberWithInteger:1] forKey:@\"name\"]; \n\t// compiles and runs\n\n\tpersion.name = [NSNumber numberWithInteger:1]; \n\t// won't compile: Incompatible pointer types assigning to 'NSString *' from 'NSNumber *'\n\nsetValue forKey 得到的对象是泛型的id， 只有在使用的时候才能确定类型。你可能会问不至于吧 OC 这样弱啊，当然不是 OC 提供了了一个方法validateValue来解决这个问题 \n\n\t@property (nonatomic, strong) NSString name;\n\n\t- (BOOL)validateName:(id*)ioValue error:(NSError**)error {\n\t    // Validation logic goes here\n\n\t}\n\n\tPerson *p = [Person new];\n\n\tNSString *name = @\"Jason Hu\";\n\n\tNSError *error = nil;\n\t \n\n\t// This call below actually calls our validateName: error: method\n\n\tif ([p validateValue:&name forKey:@\"name\" error:&error]) {\n\n\t    [p setValue:name forKey:@\"name\"];\n\t}\n\n你可能会问写这样多代码 才只验证了一个属性 那如果我这个类有n+个属性 难道我要写n+个验证方法吗？\n\n---\n\n##二.KVC 验证\n\n到这里我们对KVC已经有了一个初步印象，到这里其实还只是冰山一角。\n下面我们要提高更高的要求，如果让key 支持 不区分大小写\n\n下面我们提到一个方法initialize\n\ninitialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目或者类文件被引用进来，但是没有使用，那么initialize也不会被调用 ，到这里 知道我们接下来要干嘛了吧\n\n\n\t+ (void)initialize {\n\t\t[super initialize];\n\n\t\tdispatch_once(&onceToken, ^{\n\t\t\tmodelProperties = [NSMutableDictionary dictionary];\n\t\t\tpropertyTypesArray = @[/* removed for brevity */];\n\t\t});\n\t\t\n\t\tNSMutableDictionary *translateNameDict = [NSMutableDictionary dictionary];\n\t\t[self hydrateModelProperties:[self class] translateDictionary:translateNameDict];\n\t\t[modelProperties setObject:translateNameDict forKey:[self calculateClassName]];\n\t}\n\n\t+ (void)hydrateModelProperties:(Class)class translateDictionary:(NSMutableDictionary *)translateDictionary {\n\t\tif (!class || class == [NSObject class]){\n\t\t\treturn;\n\t\t}\n\n\t\tunsigned int outCount, i;\n\t\tobjc_property_t *properties = class_copyPropertyList(class, &outCount);\n\t\t\n\t\tfor (i = 0; i < outCount; i++){\n\t\t\tobjc_property_t p = properties[i];\n\t\t\tconst char *name = property_getName(p);\n\t\t\tNSString *nsName = [[NSString alloc] initWithCString:name encoding:NSUTF8StringEncoding];\n\t\t\t\n\t\t\tNSString *lowerCaseName = [nsName lowercaseString];\n\t\t\t[translateDictionary setObject:nsName forKey:lowerCaseName];\n\t\t\t//注意此处哦\n\t\t\tNSString *propertyType = [self getPropertyType:p];\n\t\t\t[self addValidatorForProperty:nsName type:propertyType];\n\t\t}\n\t\t\n\t\tfree(properties);\n\n\t\t[self hydrateModelProperties:class_getSuperclass(class) translateDictionary:translateDictionary];\n\t}\n\n","mtime":1379939606000,"source":"_posts/ios33.md"},"3ub05iifklsmb3wm":{"_id":"3ub05iifklsmb3wm","content":"title: mac 下 node-qrcode的二维码库\ndate: 2013-11-27 21:51:25\ntags: [技术]\ncategories: mac\n---\n这两天在mac下折腾node.js 的二维码库 ,遇到了n多大坑. 按着其官方文档的说明只有下面简简单单几句\n```\nDependencies\n\nThese should be taken care of for you by npm but you should...\n\nnpm install canvas\nIf cairo gives you trouble and you cannot install canvas, checkout the canvas site. I know @tjholowaychuk has setup a way to download and install a version of cairo/pixman for testing.\n\nThe word \"QR Code\" is registered trademark of:\n\nDENSO WAVE INCORPORATED\n```\n\n如果你的系统是mac的话 你只按着上面的安装方法 保准你折腾的头破血流, 我就是血淋淋的例子啊.\n\n因为mac 下其要安装的库太多了 .下面一次列出来\n\n```\n\n1. brew install  pkgconfig  如果没有安装homebrew 的话 恭喜你 安装去吧.\n\n2. install XQuartz [下载地址](https://xquartz.macosforge.org)\n\n3. brew install Cairo\n\n4. coyped all /opt/X11/lib/pkgconfig/*.pc to /usr/local/lib/pkgconfig on your mac\n\n5. sudo npm install -g qrcode\n\n```\n\n\n以上的安装步骤 我可是折腾了足足一个晚上.\n\n写个demo 进行测试下 qrcode.js\n\n````\nvar http = require(\"http\");\nvar QRCode = require('qrcode');\nfunction onRequest(request, response) {\n  console.log(\"Request received.\");\n  response.writeHead(200, {\"Content-Type\": \"text/html\"});\n  QRCode.toDataURL(\"胡峰\",function(err,url){\n    if(err) console.log('error: '+err);\n    //console.log(url);\n    response.end(\"<!DOCTYPE html/><html><head><title>二维码</title></head><body><p >请扫描二维码</p><img src='\"+url+\"'/></body></html>\");\n  });\n}\n\nhttp.createServer(onRequest).listen(8888);\n\n```\n\n node qrcode.js  打开浏览器 ok了\n\n {%img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1eazxou2xo0j207o075aac.jpg%}\n\n\n\n","mtime":1385561717000,"source":"_posts/nodejs1.md"},"okann8ncpjaojuij":{"_id":"okann8ncpjaojuij","content":"title: ARC下block,weak,unsafe_unretained\ndate: 2013-11-30 20:44:06\ntags: [技术]\ncategories: ios\n---\n\n最近把项目转到ARC 下了,之前__block 之前总结过一篇关于 [block](http://blog.csdn.net/hufengvip/article/details/11585537) 的文章,有兴趣的童鞋可以去看下.\n\n<!-- more -->\n\n\n```\n@interface ViewController ： UIViewViewController \n {\n        NSString *_string;\n }\n\n __block ViewController *controller = self;   \n    _block = ^{\n         NSLog(@\"string %@\",controller->_string);\n    };\n```\nARC 下 __block 依然可用 但是实现发现 __block 在AF 执行异步多线程下 会调用返回后 才会调用dealloc将当前VC 销毁, 如果改为__weak 后\n当前的VC 会马上调用dealloc销毁. 而网络请求会以错误error.code  -999 异步取消返回.\n\n__weak UIViewController *vc = self; // OK for iOS 5 only\n\n__unsafe_unretained UIViewController *vc = self; // OK for iOS 4.x and up\n\n__block UIViewController *vc = self; // OK if you aren't using ARC\n\n以上是三个比较接近容易搞混的关键字.\n\n__weak 在释放指针后能够同时将指针置为nil\n\n__unsafe_unretained 只留下一个无效的也指针\n\n__block 打破循环 copy副本 内部修改\n\n\n\n\n","mtime":1385818140000,"source":"_posts/ios34.md"},"wrdv1y2xx1dypz5y":{"_id":"wrdv1y2xx1dypz5y","content":"title: ios系类教程之用instruments来检验你的app\ndate: 2014-01-13 21:44:58\ntags: [技术]\ncategories: ios\n---\n>比较了好多关于instruments 还是发现老外写的比较牛逼.于是果断翻译过来.有能力的的可以去看英文原版,鼓励大家看原版资料远离二手教程\nhttp://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode\n\n##入门\n为了节省大家的时间,提供一个演示的Demo给大家.[代码传送门](http://cdn4.raywenderlich.com/downloads/InstrumentsTutorial.zip).\n下载后解压然后用xcode打开.\n编译运行APP后 然后在搜索框内输入任意词汇,点击结果你会看到下面的结果   \n\n{%img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1eci9qbiaq7j208v0da3zj.jpg%}   \n\n正如你所见的,这个app很简单.程序其实调用的是Flickr的API,通过app顶部的搜索框执行搜索后在下面的tableview显示你搜索的搜索词,搜索词后面的括号内有搜索结果的个数,点击此行进入一个略所图的结果列表页面 如上图. 点击其中一行 进入图像的大图模式,在这个页面你可以根据需要旋转图像.\n到目前为止页面看起来差不多了,你也许会想应该可以直接提交appstore了吧.接下来这篇文章将会教你instruments工具来提高你app性能和稳定性.\n\n##\"时间探测器\"\n\n天下武功，唯快不破。很多公司都信奉这个教条.恨不得把app压法周期压缩到最低,这就导致了开发中隐藏了很多问题,有点经验的工程师草率的优化下,更糟的情况那些没有经验的工程师甚至不会对app进行任何优化.\n\n某种程度上来说,你开发过程中是可以忽略性能优化的. 十年前,移动设备的硬件资源是非常有限的.甚至连浮点数都是被禁止的.因为浮点数能导致代码变大计算的速度变慢.\n科技发展如此迅速的今天,硬件很大程度上可以弥补软件的短板.现在的移动设备3D硬件处理的效率甚至媲美于PC机了,但是你不能总依赖于硬件和处理器速度来掩饰你APP做的多垃圾吧.(如果安卓系统跑在Iphone上还能够像IOS一样顺滑吗?,其实是一个道理的)\n\n性能这个概念很抽线,所以我们必须借助数据化图形化的输出方式.你可能花一周的时间去优化一个有趣的算法,但是这算法只占总执行时间的0.5%,不管你花多少精力去优化它,没人会注意到.相反一个for循环花费了90%的时间,你稍微修改下就能提高10%的效率,就是这个简单的修改可以得到大家很大的好感.因为.他们运行app时的第一感受就是比之前快了很多.没人会care你修改的是一个多牛逼的算法,还是一个简单的for循环.\n这个说明了什么.\n与其花费时间在优化小细节上不如多点时间找到你改优化的地方.\n\n下面引出第一个工具 \"时间事件查看器\"(自己杜撰的名字英文--Time Profiler),------他可以测量时间的间隔,中断程序执行,跟踪每个线程的堆栈.你可以想象下是xcode调试时按下暂停时的画面  \n\n{%img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1ecibl3evcoj207c0g7wfl.jpg%}  \n\n比如,100个样本都在做1毫秒的间隔,然后在某个方法堆栈顶部有10个样本,你可以推算出大概的时间有10%个10毫秒花费在此方法中,这是一个近似值.\n\n废话少说,时间是个检测到的.\n从xcode的菜单选择Product-Profile,或者选择⌘I,{%img http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecic1kiax3j205v02nq2x.jpg%}程序会启动Instruments,这时候你会看到一个选择窗口  \n   \n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecic3fuaoqj20n10jl0v1.jpg%}  \n \n 这是instruments所有测试仪器的面板,选择 \"timer profilter\" 点击\"profile\"回启东模拟器和app,此时会要求你输入一次密码,以便instruments能有权限去截获监听此进程.  \n\n {%img center http://ww4.sinaimg.cn/small/a43af4ffjw1ecicaqnba9j20fh09tgm4.jpg%}  \n     \n 在工具窗口中，可以看到时间计数，并留下了一个小箭头移动到右侧的图形在屏幕的中央上方。这表明该应用程序正在运行。\n\n 现在开始运行app,搜索一些图片,这时候你发现查找一个结果太慢了,而且搜索结果列表页面滚动起来也是让人无法忍受的,\n 首先，确保工具栏中的视图选择有选择的所有三个选项，如下所示：  \n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecici64zqwj202y01ijr6.jpg %}    \n\n￼这将确保所有的面板都打开。现在，研究下面的截图和它下面的每个部分的解释：   \n\n{%img  center http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecicvvuvpqj20c208wq3v.jpg%}   \n\n~~~~~~~~~~~\n\n1. 录控按钮。中间的红色按钮将停止与启动它被点击时，应用程序目前正在分析。注意这实际上是停止和启动应用程序,而不是暂停它。  \n\n2. 运行定时器和运行导航,定时器显示APP已经运行了多长时间,箭头之间是可以移动的。如果停止，然后使用录制按钮重新启动应用程序，这将开始一个新的运行。显示屏便会显示“run2 of 2”，你可以回到第一次运行的数据，首先你停止当前运行，然后按下左箭头回去。  \n\n3. 运行轨道.   \n\n4. 扩展面板,在时间探查仪器的情况下，它是用来跟踪显示堆栈  \n\n5. 详细地面板。它显示了你正在使用的仪器的主要信息,这是使用频率最高的部门,可以从它这里看到cpu运行的时间   \n\n6. 选项面板 稍后介绍\n\n~~~~~~~~~~~\n\n重头戏来了.\n\n##深究\n\n执行图像搜索，并深究结果。我个人比较喜欢寻找“狗”，当然你也可以选择任意你想要的内容.比如猫啊美女啊什么的.\n\n现在上下滚动记下列表,让时间探测器测量下数据,然后注意看下屏幕的变化和数值.这些数值反应了CPU周期.\n\n但是你也许会发现下面的数值太多,看你的眼花缭乱. 下面打开左边的调用树 然后按着如下的配置\n\n{%img center http://ww3.sinaimg.cn/mw690/a43af4ffjw1ecidfkvchwj205508wwem.jpg%}\n\n以下介绍下配置选项：\n\n~~~~~~~~~~~\n\n\nSeparate by Thread: 每个线程应该分开考虑。只有这样你才能揪出那些大量占用CPU的\"重\"线程  \n\nInvert Call Tree: 从上倒下跟踪堆栈,这意味着你看到的表中的方法,将已从第0帧开始取样,这通常你是想要的,只有这样你才能看到CPU中话费时间最深的方法.也就是说FuncA{FunB{FunC}} 勾选此项后堆栈以C->B-A 把调用层级最深的C显示在最外面 \n\nHide Missing Symbols: 如果dSYM无法找到你的app或者系统框架的话,那么表中看不到方法名只能看到十六进制的数值,如果勾线此项可以隐藏这些符号,便于简化数据\n\nHide System Libraries: 勾选此项你会显示你app的代码,这是非常有用的. 因为通常你只关心cpu花在自己代码上的时间不是系统上的\n\nShow Obj-C Only: 只显示oc代码 ,如果你的程序是像OpenGl这样的程序,不要勾选侧向因为他有可能是C++的  \n\nFlatten Recursion: 递归函数, 每个堆栈跟踪一个条目\n\nTop Functions: 一个函数花费的时间直接在该函数中的总和，以及在函数调用该函数所花费的时间的总时间。因此，如果函数A调用B，那么A的时间报告在A花费的时间加上B.花费的时间,这非常真有用，因为它可以让你每次下到调用堆栈时挑最大的时间数字，归零在你最耗时的方法。\n\n~~~~~~~~~~~\n\n如果您已启用上述选项,虽然有些值可能会略有不同，下面的结果的顺序应该是类似下表： \n\n{%img center http://ww3.sinaimg.cn/mw690/a43af4ffjw1eciea0qldhj20cu08w75b.jpg%}   \n\n通过上面你能看到大部分时间都花在更新表格照片了.\n\n双击此行,然后将会看到如下  \n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecieegah2wj20cv08w0tj.jpg%}  \n\n那么这很有趣，不是吗！几乎四分之三的时间花费在setPhoto：方法都花在创造照片的图像数据！\n现在可以看到的是什么问题,NSData’s dataWithContentsOfURL 方法并不会立即返回,因为要从网上去数据,每次调用都需要长达几秒的时间返回,而此方法运行在主线程,可想而知会有什么结果了.\n其实为了解决这个问题,类提供了一个ImageCache 的后台异步下载的方法.\n\n现在，您可以切换到Xcode和手动找到该文件，但仪器有一个方便的“打开Xcode中”按钮，就在你的眼前。找到它的面板只是上面的代码并单击它：  \n\n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecieiognodj20c4044dfv.jpg%}  \n\n想如下修改\n\n```\n- (void)setPhoto:(FlickrPhoto *)photo {\n    _photo = photo;\n \n    self.textLabel.text = photo.title;f\n \n//    NSData *imageData = [NSData dataWithContentsOfURL:_photo.thumbnailUrl]; \n//    self.imageView.image = [UIImage imageWithData:imageData];\n \n    [[ImageCache sharedInstance] downloadImageAtURL:_photo.thumbnailUrl\n                                  completionHandler:^(UIImage *image) {\n                                      self.imageView.image = image;\n                                      [self setNeedsLayout];\n                                  }];\n}\n\n```\n\n修改好厚,在仪器重新运行该应用程序Product--Profile（或⌘I-记住，这些快捷键真的会为您节省一些时间）。\n请注意，这个时候会再问一次你是否使用一起。这是因为你还有一个窗口中打开这个程序，及仪器假定您要使用相同的选项再次运行。\n执行一些更多的搜索，并注意此时用户界面不是那么卡顿了！这些图像现在异步加载，并缓存在后台，所以一旦他们已经被下载一次，他们不必再次下载。\n看上去很不错！是时候发布了吗? 当然还不够\n\n\n## 分配，分配，分配\n\n接下来的仪器是分配工具。它能给出你所有创建和存储它们的内存的详细信息，它也显示你保留了每个对象的计数。\n\n关闭仪器，回到Xcode和选择Product->Profile。然后，从选择器分配并单击配置文件。如下图:\n\n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1eciet83x01j20xc0oqaeh.jpg%}  \n\n程序再次打开 然后你会看到  \n\n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecif0bcb3vj20c208w3zd.jpg %}\n\n这个时候你会发现两个曲目。一个叫(分配)Allocations，以及一个被称为VM Tracker(虚拟机跟踪)。该分配轨道将详细在本教程中讨论;虚拟机跟踪也是非常有用的，但更复杂一点。\n所以你的错误会追踪下？\n有隐藏的项目，你可能不知道有东西在那儿。你可能已经听说了内存泄漏。但你可能不知道的是，其实有两种泄漏。\n第一个是真正的内存泄漏，一个对象尚未被释放，但是不再被引用的了。因此，存储器不能被重新使用。\n第二类泄漏是比较麻烦一些。这就是所谓的“无界内存增长”。这发生在内存继续分配，并永远不会有机会被释放。\n如果永远这样下去你的程序占用的内存会无限大,当超过一定内存的话 会被系统的看门狗给kill掉.\n\n建立一个场景，你可以检测出无限的内存增长。首先，在应用程序使10个不同的搜索（不要用已经存在的搜索）。确保搜索的一些结果！现在让程序等待几秒钟。\n\n你应该已经注意到，在分配的轨道图不断上升。这是告诉你的,内存被分配了。它的这一特征，将引导你找到无限的内存增长。\n你将要执行的是\"heap shot analysis\"。为此，按这个按钮叫“Mark Heap”。你会发现的详细面板左侧的按钮  \n\n{% img center http://ww1.sinaimg.cn/small/a43af4ffjw1ecifcxzy9uj207e03q0sv.jpg %}  \n\n按下它，你会看到一个红色的标志出现在轨道上，像这样：\n\n{%img center http://ww3.sinaimg.cn/mw690/a43af4ffjw1ecifgqlk64j201304ft8h.jpg%}\n\n\nheap shot分析的目的是执行一个动作多次，看看如果内存是否无限增长。搜索一个内容，稍等几秒加载图像，然后返回主页。然后再标记堆。反复这样做不同的搜索。\n演戏几个搜索后，仪器会看起来像这样：\n\n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecifkhamr4j20c208wdgf.jpg%}\n\n这时你应该会疑问。图中的蓝色是怎么回事了，你继续这样操作10次这样的搜索 蓝色还不断变高：\n那肯定是不好的。别急，有什么关于内存的警告？你知道这些，对不对？内存警告是告诉一个应用程序，内存警告是ios处理app最好的方式尤其是在内存越来越吃紧的时候,你需要清除一些内存。\n内存一直增长其实也不一定是你的代码除了问题,也有可能是UIKit 系统框架本身导致的.\n\n通过选择HardwareSimulate内存警告在iOS模拟器的菜单栏模拟内存警告。你会发现，记忆体使用量出现小幅回落，但绝对不会回到它应该的。所以还是有无限的内存增长发生的地方。\n究其原因，堆出手做钻进搜索的每次迭代后，你可以看到内存的分配每个镜头之间。一起来看看在详细信息面板，你会看到一堆一堆的镜头。\n\n在iOS模拟器的菜单栏中选择hardwaresimulate内存警告模拟内存警告。你会发现内存使用会出现小幅回落，但肯定不会回到它应该在的地方。\n每一次的搜索后做你可以看到内存已拍摄之间的分配。在详细信息面板看一看，你会看到一好多堆镜头。\n\n##稳准狠\n第一个堆镜头作为参照,然后随便打开一个堆镜头,你会看到如下:  \n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecifzbusd2j20dc07caat.jpg%}  \n\n靠，这是一个很大的对象！从哪里开始看呢？\n最好的方式是通过列表，你在你的应用程序直接使用的类。在这种情况下，HTTPHeaderDict，CGRegion，CGPath，CFNumber，等等都是可以忽略了。\n但是，一个突出的是UIImage,这肯定是在你程序使用的。点击上的UIImage左侧的箭头显示的完整列表。选择一个，在扩展详细信息面板：\n{%img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1ecig2kckgtj203208w0sq.jpg%}  \n\n图中灰色的是系统库,黑色部分是你应用的代码,要获得此跟踪更多的上下文,双击唯一的黑框ImageCache方法,这时候将掉转到如下方法\n\n```\n- (void)downloadImageAtURL:(NSURL*)url completionHandler:(ImageCacheDownloadCompletionHandler)completion {\n    UIImage *cachedImage = [self imageForKey:[url absoluteString]];\n    if (cachedImage) {\n        completion(cachedImage);\n    } else {\n        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n            NSData *data = [NSData dataWithContentsOfURL:url];\n            UIImage *image = [UIImage imageWithData:data];\n            [self setImage:image forKey:[url absoluteString]];\n            dispatch_async(dispatch_get_main_queue(), ^{\n                completion(image);\n            });\n        });\n    }\n}\n\n```\n\n工具是非常有用的,你现在要努力通过自己的代码思考发生了什么.看看通过上面的方法，你会看到它调用一个名为setImage方法：forKey：。这种方法在缓存以防它再次使用以后的应用程序的图像。啊！那么这肯定听起来像它可能是一个问题!\n一起来看看该方法的实现：\n```\n- (void)setImage:(UIImage*)image forKey:(NSString*)key {\n    [_cache setObject:image forKey:key];\n}\n```\n从网络上下载一个图片添加字典中,你会注意到这些图片从来没有从字典清楚过\n,这就是内存为什么会一直增长,因为应用程序并不会从缓存里删除东西.它只会一直增加他们.\n要解决此问题,你需要的是ImageCache收到UIApplication内存吃紧的警告时.清理缓存.\n\n为了使ImageCache能接收通知，修改ini​​t方法如下：\n\n```\n- (id)init {\n    if ((self = [super init])) {\n        _cache = [NSMutableDictionary new];\n        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(memoryWarning:) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];\n    }\n    return self;\n}\n```\n注册UIApplicationDidReceiveMemoryWarningNotification执行memoryWarning：方法。\n\n```\n- (void)memoryWarning:(NSNotification*)note {\n    [_cache removeAllObjects];\n}\n\n```\nmemoryWarning删除缓存中的所有对象。这将确保没有持图像。\n为了测试此修复程序，再次启动仪器（从Xcode中有⌘I）和重复的步骤。不要忘了在模拟结束内存警告！\n\n**注意：请确保您从Xcode中退出，重新构建，而不是仅仅点击仪器仪表上的红色按钮，以确保您使用的是最新的代码。**\n\n这一次分析应该是这样的：\n\n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecign06n2yj20c208w0tb.jpg%}  \n\n这个时候，内存受到内存警告后急剧下降。但还是有一些内存整体增长，但远不及像以前那样。\n究其原因还是有一定的增长确实是由于系统库，并没有太多可以做的。看来，系统库不释放所有的内存，这可能是由设计或可能是一个错误。你可以在你的应用程序做的是释放尽可能多的内存越好，你已经做到这一点！\n干得好！还有一个问题，修补了, - 仍然有泄漏，你还没有解决的第一种类型的问题。\n\n##内存泄露\n\n内存泄漏的仪器。这是用来找到第一类泄漏前面提到的 - 当一个对象不再被引用时出现的那种\n检测泄漏是可以理解的一个很复杂的事情，但泄漏的工具记得，已分配的所有对象，并定期通过扫描每个对象以确定是否有任何不能从任何其他对象访问的。\n关闭仪器，回到Xcode和选择Product->Profile  \n\n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1eciguvy9x5j20xc0p8dke.jpg%}  \n\n回到你的应用程序！执行搜索，得到结果。然后点选结果的预览行打开全屏浏览器。按下旋转按钮在左上角，然后再按一次。\n回到仪器，等待片刻。如果你已经正确地完成上述步骤后，你会发现泄漏已经出现了！你的工具窗口将看起来像这样：  \n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecigwp5ymtj20c208wmxq.jpg%}  \n\n返回到模拟器，并按下旋转几次。然后返回到仪器和等会,得到如下结果：\n\n{%img center http://ww4.sinaimg.cn/mw690/a43af4ffjw1ecigy7zu2hj20c208w0tb.jpg%}\n\n哪来的泄漏从哪里来？扩展详细信息面板   \n{%img center http://ww1.sinaimg.cn/mw690/a43af4ffjw1ecici64zqwj202y01ijr6.jpg %}    \n在扩展的详细信息面板打开CGContext上名单。在列表中选择CGContext上的元素之一，这表明导致要创建的对象，如下面的堆栈跟踪： \n{%img center http://ww2.sinaimg.cn/mw690/a43af4ffjw1ecih21lep0j203208wdfz.jpg%}   \n\n再次，涉及到你的代码中的帧显示为黑色。由于只有一个，双击它，看看代码的方法。\n有问题的方法是rotateTapped： ，这是被调用时被窃听旋转按钮的处理程序。这种方法旋转原始图像，并创建一个新的图像，如下：\n\n```\n- (void)rotateTapped:(id)sender {\n    UIImage *currentImage = _imageView.image;\n    CGImageRef currentCGImage = currentImage.CGImage;\n \n    CGSize originalSize = currentImage.size;\n    CGSize rotatedSize = CGSizeMake(originalSize.height, originalSize.width);\n \n    CGContextRef context = CGBitmapContextCreate(NULL,\n                                                 rotatedSize.width,\n                                                 rotatedSize.height,\n                                                 CGImageGetBitsPerComponent(currentCGImage),\n                                                 CGImageGetBitsPerPixel(currentCGImage) * rotatedSize.width,\n                                                 CGImageGetColorSpace(currentCGImage),\n                                                 CGImageGetBitmapInfo(currentCGImage));\n \n    CGContextTranslateCTM(context, rotatedSize.width, 0.0f);\n    CGContextRotateCTM(context, M_PI_2);\n    CGContextDrawImage(context, (CGRect){.origin=CGPointZero, .size=originalSize}, currentCGImage);\n \n    CGImageRef newCGImage = CGBitmapContextCreateImage(context);\n    UIImage *newImage = [UIImage imageWithCGImage:newCGImage];\n \n    self.imageView.image = newImage;\n}\n\n```\n\n再次，仪器只能在这里给你一个提示，问题出在哪里，它不能告诉你确切位置的泄漏。这是唯一能够证明你在创建对象泄露的地方.你可能认为ARC并有不可能是造成代码中内存泄漏...对不对？\n回想一下，ARC只涉及Objective-C的对象。它不管理保留和的CoreFoundation对象而不是Objective-C的对象的释放。\n啊，现在它开始变得明显的问题是什么 \n-CGContextRef和CGImageRef对象永远不会被释放！为了解决这个问题，在rotateTapped方法的末尾添加以下两行代码：\n```\nCGImageRelease(newCGImage);\nCGContextRelease(context);\n```\n这两种调用都需要来维护这两个对象的保留计数。这个说明，你还需要了解引用计数 - 即使你在你的项目中使用的ARC！\n从在Xcode中，使用⌘I工具构建和运行应用程序。\n在使用泄漏仪器仪器再看看应用程序，看看是否泄漏的被固定。如果你正确地遵循上述步骤，泄漏应消失！\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n","mtime":1389637861000,"source":"_posts/ios35.md"}}}