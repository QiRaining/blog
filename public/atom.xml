<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[阿峰的技术窝窝]]></title>
  <subtitle><![CDATA[专注于移动互联网]]></subtitle>
  <link href="http://hufeng825.github.com/atom.xml" rel="self"/>
  <link href="http://hufeng825.github.com"/>
  <updated>2013-08-31T14:48:49.373Z</updated>
  <id>http://hufeng825.github.com/</id>
  <author>
    <name><![CDATA[Jason Hu]]></name>
    <email><![CDATA[hufeng@hufengvip.cn]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[复杂页面消退的一个简单实例]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios13/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios13/</id>
    <published>2013-08-31T14:42:52.000Z</published>
    <updated>2013-08-31T14:46:30.000Z</updated>
    <content type="html"><![CDATA[<p>如图</p>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e8680v5hirj20df09qglv.jpg" class="left" height="400" title="600">


<p><a id="more"></a><br>实现上面的这个又两种实现方式 </p>
<ul>
<li><p>一种是给页面1 发广播通知 </p>
</li>
<li><p>另外一种就是我要介绍的</p>
</li>
</ul>
<figure class="highlight"><pre> [(<span class="built_in">UINavigationController</span>*)<span class="keyword">self</span><span class="variable">.parentViewController</span><span class="variable">.presentingViewController</span>

     popToRootViewControllerAnimated:<span class="literal">YES</span>];

    [<span class="keyword">self</span> dismissModalViewControllerAnimated:<span class="literal">YES</span>];
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hexo/" term="hexo"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios 开发纸 序列化]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios12/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios12/</id>
    <published>2013-08-31T14:26:47.000Z</published>
    <updated>2013-08-31T14:48:04.000Z</updated>
    <content type="html"><![CDATA[<p>序列化</p>
<p>参考原始文档：</p>
<p><a href="https://github.com/mystcolor/JTObjectMapping" target="_blank">https://github.com/mystcolor/JTObjectMapping</a></p>
<p><a id="more"></a><br>使用方法</p>
<p>========</p>
<p>绝大多数情况下，需要用到的就是一个方法：</p>
<p>[NSObject objectFromJSONObject:stateObject mapping:nil];</p>
<p>其中，把NSObject换成我们想映射成的类的名字。</p>
<p>稍微复杂一点，假设类的属性和JSON里的key名字不是一一对应的，那么就要写一个映射关系表作为mapping参数：</p>
<pre><code>NSDictionary <span class="variable">*mapping</span> = [NSDictionary dictionaryWithObjectsAndKeys:

                         <span class="variable">@"</span>myState<span class="string">", <span class="variable">@"</span>state"</span>,

                         <span class="variable">@"</span>movieList<span class="string">", <span class="variable">@"</span>movie"</span>,

                         nil];

[NSObject objectFromJSONObject:stateObject mapping:mapping];</code></pre>
<p>如果再复杂一点，我们需要映射一个数组，数组的每个元素映射到一个对象，那么就用到第2个方法：</p>
<p>[NSObject mappingWithKey:@“responseState” mapping:nil]</p>
<p>同样，把NSObject换成数组元素对应的类，key是用来存放整个数组的那个属性。</p>
<p>注意</p>
<p>====</p>
<p>JSON里的字符串，是能自动映射成NSNumber或者int型的，不需要特别写代码。如果想把一个字符串日期，映射成NSDate型，请参考原始文档。</p>
<p>具体举个例子</p>
<p>===========</p>
<p>假设我们有这样一段JSON：</p>
<p> {</p>
<p> “state”:[</p>
<p> {</p>
<p> “respCode”:“0000”,</p>
<p> “respMsg”:“1”</p>
<p> }</p>
<p> ],</p>
<p> “movie”:[</p>
<p> {</p>
<p> “body”:“    一开始，这只是叶问的故事他生于佛山”,</p>
<p> “pics”:“/images/jz/4779-1-20121225133147.jpg,/images/jz/4779-2-20121225133147.jpg”,</p>
<p> “name”:“一代宗师”,</p>
<p> “movid”:“4779”,</p>
<p> “length”:“120”,</p>
<p> “hasplan”:“1”,</p>
<p> “trailor”:“/4779.m4v”,</p>
<p> “director”:“梁朝伟 章子怡 张震 ”,</p>
<p> “type”:“动作/传记/剧情/IMAX”,</p>
<p> “url”:&quot;<a href="http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&amp;w=140" target="_blank">http://img.fun-guide.mobi/show?src=http://zhaohang.fun-guide.mobi:8080/tm/images/hb/4779-20121225133147.jpg&amp;w=140</a>&quot;,</p>
<p> “popularity”:“6”</p>
<p> },</p>
<p> {</p>
<p> …</p>
<p> }</p>
<p> ]</p>
<p> }</p>
<p>现在，想把它映射到自定义的对象中去。有几种情况：</p>
<p>第一种情况，简单地把state数组里面的第一个元素映射成一个FGStateModel类</p>
<p>那么就是，取出这个节点：</p>
<pre><code>NSDictionary *stateObject = <span class="string">[[self.json objectForKey:@"state"] objectAtIndex:0];</code></pre>
<p>然后，执行映射：</p>
<pre><code><span class="keyword">self</span>.state = [<span class="class">FGStateModel</span> <span class="method">objectFromJSONObject:</span>stateObject <span class="method">mapping:</span><span class="keyword">nil</span>];</code></pre>
<p>第二种情况，把movie这个字典数组映射成一个数组，数组的每个元素是FGMovieModel</p>
<pre><code><span class="class">NSArray</span> *movieObject = [<span class="keyword">self</span>.json <span class="method">objectForKey:</span>@<span class="comment">"movie"</span>];

<span class="keyword">self</span>.movieList = [<span class="class">FGMovieModel</span> <span class="method">objectFromJSONObject:</span>movieObject <span class="method">mapping:</span><span class="keyword">nil</span>];</code></pre>
<p>第三种情况，如果对象的属性和JSON名字不一样，可以使用映射表，例如我们想把上面整个json对象映射成一个 FGResponseModel 对象，其中，state数组映射成 responseState 属性，movie 数组映射成 movieList 属性。那么，我们需要告诉映射器这个数组里的元素要映射成什么对象。</p>
<p>所以，通过 mapping 这个参数告诉它：“请把 JSON 里的 state 数组里的每个元素映射成一个 FGStateModel 对象，并且把最终的数组放到responseState这个属性里。另外，把 movie 这个数组映射成一个 FGMovieModel 数组，并且保存到 movieList 这个属性中。“</p>
<pre><code><span class="class">NSDictionary</span> *mapping = [<span class="class">NSDictionary</span> <span class="method">dictionaryWithObjectsAndKeys:</span>

                         [<span class="class">FGStateModel</span> <span class="method">mappingWithKey:</span>@<span class="comment">"responseState"</span> <span class="method">mapping:</span><span class="keyword">nil</span>], @<span class="comment">"state"</span>,

                         [<span class="class">FGMovieModel</span> <span class="method">mappingWithKey:</span>@<span class="comment">"movieList"</span> <span class="method">mapping:</span><span class="keyword">nil</span>], @<span class="comment">"movie"</span>,

                         <span class="keyword">nil</span>];

<span class="keyword">self</span>.response = [<span class="class">FGResponseModel</span> <span class="method">objectFromJSONObject:</span><span class="keyword">self</span>.json <span class="method">mapping:</span>mapping];</code></pre>
<figure class="highlight"><pre><span class="preprocessor">#import &lt;Foundation/Foundation.h&gt;</span>


@<span class="class"><span class="keyword">interface</span> <span class="title">FGMovieModel</span> : <span class="title">NSObject</span>


@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">body</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">pics</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">name</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">assign</span>) <span class="title">NSInteger</span> <span class="title">movid</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSNumber</span> *<span class="title">length</span>;


@<span class="title">end</span>
</pre></figure>

<figure class="highlight"><pre><span class="preprocessor">#import &lt;Foundation/Foundation.h&gt;</span>


@<span class="class"><span class="keyword">interface</span> <span class="title">FGResponseModel</span> : <span class="title">NSObject</span>

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSArray</span> *<span class="title">responseState</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSArray</span> *<span class="title">movieList</span>;

@<span class="title">end</span>

 
#<span class="title">import</span> &lt;<span class="title">Foundation</span>/<span class="title">Foundation</span>.<span class="title">h</span>&gt;


@<span class="title">interface</span> <span class="title">FGStateModel</span> : <span class="title">NSObject</span>


@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">respCode</span>;

@<span class="title">property</span> (<span class="title">nonatomic</span>, <span class="title">retain</span>) <span class="title">NSString</span> *<span class="title">respMsg</span>;


@<span class="title">end</span>
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hexo/" term="hexo"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[银行支付控件之 自动随机(shuffle)密码键盘的实现算法]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios11/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios11/</id>
    <published>2013-08-31T14:05:28.000Z</published>
    <updated>2013-08-31T14:22:21.000Z</updated>
    <content type="html"><![CDATA[<p>为了广大用户的支付安全,输入密码的页面密码键盘要用随机排序,因为有版权问题无法把自己写的代码全部贴出 所以下面只把关键的洗牌算法贴出来</p>
<h2>算法一</h2>
<figure class="highlight"><pre>NSMutableArray *randSequence = <span class="string">[[NSMutableArray alloc] initWithCapacity:8];
for (int ii = 0; ii &lt; 10; ++ii)
    [randSequence addObject:[NSNumber numberWithInt:ii]]</span>;

<span class="keyword">for</span> (int ii = <span class="number">9</span>; ii &gt; -<span class="number">1</span>; <span class="comment">--ii) {</span>
    int r = arc4random() % <span class="number">9</span>
    [randSequence exchangeObjectAtIndex:ii withObjectAtIndex:r];
</pre></figure>

<h2>算法二</h2>
<figure class="highlight"><pre>
@<span class="class"><span class="keyword">interface</span> <span class="title">NSMutableArray</span> (<span class="title">Shuffling</span>)
- (<span class="title">void</span>)<span class="title">shuffle</span>;
@<span class="title">end</span>


//  <span class="title">NSMutableArray_Shuffling</span>.<span class="title">m</span>

#<span class="title">import</span> "<span class="title">NSMutableArray_Shuffling</span>.<span class="title">h</span>"

@<span class="title">implementation</span> <span class="title">NSMutableArray</span> (<span class="title">Shuffling</span>)

- (<span class="title">void</span>)<span class="title">shuffle</span>
{</span>
    NSUInteger <span class="keyword">count</span> = [self <span class="keyword">count</span>];
    <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>; ++i) {
        <span class="comment">// Select a random element between i and end of array to swap with.</span>
        NSInteger nElements = <span class="keyword">count</span> - i;
        NSInteger n = (arc4random() % nElements) + i;
        [self exchangeObjectAtIndex:i withObjectAtIndex:n];
    }
}

@end
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[mac 下的默认配置]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios10/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios10/</id>
    <published>2013-08-31T13:45:59.000Z</published>
    <updated>2013-08-31T14:03:31.000Z</updated>
    <content type="html"><![CDATA[<p>请几天安装其他的shell 结果把默认的shell更改了  有没有快捷的方法更换会默认配置 <a id="more"></a>其实mac 下 有一个很简单命令可以搞定这些用户默认设置<br>打开终端社着敲敲如下的命令</p>
<pre><code><span class="attribute">chsh</code></pre>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e866tu4f66j20a107sq3i.jpg" class="left" title="运行效果 300  400">
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
    <category scheme="http://hufeng825.github.com/categories/ios/mac/" term="mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Xcode的持续集成指南]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios9/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios9/</id>
    <published>2013-08-31T13:11:39.000Z</published>
    <updated>2013-08-31T13:44:09.000Z</updated>
    <content type="html"><![CDATA[<h2>采用持续集成工作流</h2>
<p>设置MAC作为服务器，在其上运行Xcode的服务。然后确保你的本地项目，发布源代码库。要完成设立一个持续集成的工作流程，配置的机器人，不知疲倦地进行集成和时间表。<br><a id="more"></a></p>
<h2>OS X Server的安装和配置的Xcode服务</h2>
<p>要运行的Xcode的服务，您必须先安装运行的是Mac OS X v10.9开发者预览版OS X Server的预览。您还必须在服务器上安装Xcode开发者预览。自动构建，分析，测试，和归档您的产品，您将使用Xcode的服务。</p>
<h3>要安装和运行Xcode的服务</h3>
<ol>
<li><p>转到<a href="http://developer.apple.com/downloads的，并获得OS" target="_blank">http://developer.apple.com/downloads的，并获得OS</a> X v10.9开发者预览版，OS X Server的预览，和Xcode开发者预览版的预发布版本。</p>
</li>
<li><p>安装OS X v10.9开发者预览版，Mac OS X Server的预览，和Xcode开发者预览版的Mac上，你会运行Xcode的服务。</p>
</li>
<li><p>启动服务器应用程序/应用。</p>
</li>
<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>
</li>
<li><p>当您第一次打开Xcode���服务在一个特定的服务器上，该服务会询问您确定的Xcode版本，它应该用来执行其任务。</p>
</li>
<li><p>点击选择的Xcode，并选择使用的Xcode版本。</p>
</li>
<li><p>点击On / Off开关打开服务</p>
</li>
</ol>
<p>接下来，添加你的服务器允许访问Xcode的服务团队，如资产配置的配置文件和签名证书为iOS设备构建产品开发团队。你必须是一个管理员或开发团队的代理，这样才能把服务器加进来。</p>
<h3>要添加您的服务器开发团队</h3>
<ol>
<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>
</li>
<li><p>在“设置”窗格中，单击“添加”按钮，旁边的开发团队标签。</p>
</li>
<li><p>输入您的Apple开发者证书，并选择一个团队。</p>
</li>
</ol>
<p>加入团队后，Xcode的服务，您可以添加iOS开发设备运行单元测试时使用。</p>
<h3>要添加一个iOS开发设备的Xcode服务</h3>
<ol>
<li><p>在服务器应用程序边栏中，选择的Xcode的服务。</p>
</li>
<li><p>将设备连接到服务器，并等待，直到它出现在设备列表中。</p>
</li>
<li><p>点击“加入队伍”按钮旁边的列表中的设备。</p>
</li>
</ol>
<p>添加帐户资料库和您的服务器配置开发的Mac。你会写你的Mac上的使用Xcode代码，你就会让OS X服务器进行持续集成。您还必须发布或您当地的项目转移到资料库，可通过Xcode的服务。</p>
<h3>你开发的Mac OS X Server的帐户添加到Xcode</h3>
<ol>
<li><p>在Xcode的开发Mac上，单击“帐户”首选项“窗口。</p>
</li>
<li><p>点击添加按钮（+），并选择“添加服务器”。</p>
</li>
<li><p>从服务器列表中选择服务器，输入服务器地址，然后单击“下一步”按钮。</p>
</li>
<li><p>指定您的连接到服务器的凭据，然后单击“添加”。</p>
</li>
</ol>
<p>您可以添加到您的帐户资料库，加快结帐操作。（你也可以添加库到您的清单后，当您检查的项目）。</p>
<h3>要添加存储库到您的帐户</h3>
<ol>
<li><p>在Xcode的开发Mac上，单击“帐户”首选项“窗口。</p>
</li>
<li><p>点击添加按钮（+），并选择“添加库。</p>
</li>
<li><p>在文本字段中，输入库添加的地址，然后单击“完成”按钮。</p>
</li>
</ol>
<h2>Xcode的服务和团队成员共享项目</h2>
<p>对于Xcode的服务，您的项目进行集成，它必须包含这些项目的存储库的访问。启用访问托管Git仓库在服务器上运行的Xcode服务或Git或Subversion版本库，包含你的项目添加连接信息。</p>
<p>如果同一个团队开发，持续集成涉及到整个团队。谁的作品在产品上的人都必须能够访问所有产品的资源，使任何人都可以引起谁都可能解决问题。如果你有一个不保持源代码库中的项目或工作区，你必须检查你的文件到存储库，让其他团队成员可以在这些产品上。</p>
<p><strong>您可以在服务器上创建一个Xcode服务器，托管Git仓库</strong><br>开发团队可以共享更改产品OS X服务器托管在一个Git仓库。创建一个Xcode服务器托管Git仓库之前，你必须：</p>
<ol>
<li><p>确保都有谁应该能够访问存储库服务器上的用户帐户。</p>
</li>
<li><p>打开系统偏好设置中的服务器上的远程登录服务。</p>
</li>
</ol>
<h3>要创建一个Xcode服务器托管您的服务器上的Git仓库</h3>
<ol>
<li><p>在服务器应用程序边栏中，选择Xcode的服务，然后单击“存储库”按钮。</p>
</li>
<li><p>点击添加按钮（+），并指定存储库的信息：</p>
<ul>
<li>选择“主机一个Git仓库。”</li>
<li>名称：输入资料库的名称（例如，项目名称）。</li>
<li>访问：确定允许用户访问存储库。</li>
</ul>
</li>
<li><p>单击“创建”。</p>
<p> 新的资料库资料库列表中出现。如果你有一个发展的Mac上现有的Git管理的项目，你可以把你的变化，这个新的储存库，将其配置为远程，如未来。</p>
</li>
</ol>
<h3>从发展的Mac，您可以共享现有的Git管理项目</h3>
<p>当您共享一个项目，其中包含一个Git仓库，是当地发展的Mac，Xcode的服务可以检查出来进行集成。共享一个项目之前，你必须：</p>
<ol>
<li>作为OS X服务器运行Xcode的服务的管理员进行身份验证。</li>
<li>确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。</li>
</ol>
<h4>要共享项目</h4>
<ol>
<li><p>打开项目发展的Mac上，并选择源控制&gt; PROJECT_NAME &gt;配置PROJECT_NAME。</p>
</li>
<li><p>按一下远程控制。</p>
</li>
<li><p>点击“添加”按钮（+）。</p>
</li>
<li><p>选择“创建新的远程。</p>
</li>
<li><p>选择一台服务器。</p>
</li>
<li><p>输入远程名称。</p>
</li>
<li><p>单击“创建”。</p>
</li>
<li><p>单击“完成”。</p>
</li>
<li><p>这使得共享资源库的上游库项目存​​储库。</p>
</li>
</ol>
<h3>您可以创建一个新项目开发的Mac OS X服务器和主机守则</h3>
<p>当您创建您的开发Mac上的项目，你可以创建一个共享库。创建一个共享的项目之前，你必须：</p>
<ol>
<li>作为OS X服务器运行Xcode的服务的管理员进行身份验证。</li>
<li>确保服务器和Xcode的服务的，允许远程登录访问，通过安全Shell（SSH），它承载的存储库。在OS X服务器，你可以配置远程登录，在“系统偏好设定”中的“共享”窗格中。</li>
</ol>
<h4>要创建共享项目</h4>
<ol>
<li><p>选择“文件”&gt;“新建”&gt;“项目。</p>
</li>
<li><p>为您的项目中选择一个模板。</p>
</li>
<li><p>指定项目的选项，并单击“下一步”。</p>
</li>
<li><p>指定的位置。</p>
</li>
<li><p>选择“创建git仓库”选项。</p>
</li>
<li><p>确定服务器。</p>
</li>
</ol>
<p>单击“创建”。</p>
<p>您可以使用Git来管理你的开发Mac上的非托管的工作区目录<br>当你创建一个Xcode的工作区或项目，你必须包括一个Git仓库中生成的工作区目录的选项。如果您没有选择该选项，您的工作区目录不包括一个Git仓库。与他人使用Git版本控制系统要共享工作区目录，在该目录中，你必须初始化一个Git仓库。</p>
<p>您可以使用Subversion的管理项目<br>Xcode的服务可以连接你的Subversion版本库，并从它的检查项目。</p>
<h2>使用搜索引擎来生成，运行静态分析，测试和存档</h2>
<p>您可以运行一个项目的集成通过三个计划行动：</p>
<ol>
<li>分析，进行静态分析。</li>
<li>测试，运行一组测试案例。</li>
<li>存档，建立一个归档的产品，计划建成。</li>
</ol>
<p>您可以手动执行这些操作，为您做出更改产品。然而，手动集成可以是乏味且容易出错。例如，你可能会忘记发布一个小的变化，打破你的队友的单元测试之前进行测试操作。Xcode的服务提供了一个具有成本效益的方式自动执行集成：机器人。机器人会自动执行你的集成：</p>
<ol>
<li>每次更改发布到存储库。</li>
<li>上定期（比如说，每天进行集成，需要很长的时间才能完成）。<br>Â 机器人运行通过Xcode的服务，以在资源库中的项目的当前版本进行集成，是一个过程。包括一个集成构建，分析，测试，归档产品上。可以是成功的积分（即，所有的整合动作传递没有问题）的或不成功的。计划中定义的集成自动化，您必须共享该方案，并创建一个或多个机器人来执行这些集成。</li>
</ol>
<p>要充分利用您的产品开发流程的持续集成环境中，遵循以下做法：</p>
<ol>
<li><p>制定适当的单元测试套件和测试用例，显影单元测试后，包括他们在你的机器人运行计划。要了解关于单元测试的更多信息，请参见Xcode的单元测试指南<br>为了帮助确保您所做的更改都破不了您或其他人后，你应​​该配合这些变化与单元测试，确定是否规定一种或一组序列功能的方法。有些球队在它的头把这种方法首先开发测试，通过测试的方法，然后执行。</p>
</li>
<li><p>执行静态分析，你应该在您的集成包括静态分析。<br>静态分析是深刻检查你的代码，下面的代码路径，您的应用程序可能不遵循正常的发展过程中。这个过程揭示难以发现的编码错误，还确定了在你的代码不遵循建议的API的用法，比如基金会和AppKit的成语。</p>
</li>
<li><p>确保您的产品建立和正确打包。您您的产品作出了重大变化，特别是结构性的变化，如添加或删除文件后，应归档。让你的机器人自动为您归档。<br>当您的产品中包含的结构性问题，Xcode可以创建一个归档它为你的团队成员之间共享或提交到App Store。建立和归档产品的能力是你的代码更改的正确性的主要指标。</p>
</li>
</ol>
<h2>分享计划</h2>
<p>共享的计划被确定为在一个项目中共享和发布共享资源库，以及与其他共享项目文件。你可以分享计划之前，你必须检查的项目。</p>
<h3>要共享计划</h3>
<ol>
<li><p>开发的Mac上，打开的项目，其中包含共享的计划。</p>
</li>
<li><p>选择产品&gt;计划&gt;管理计划。</p>
</li>
<li><p>分享的计划，选择共享选项，并单击“确定”。</p>
</li>
<li><p>选择源控制&gt;提交。</p>
</li>
<li><p>选择共享的资料夹。</p>
</li>
<li><p>指定你提交的信息：</p>
<ul>
<li>在文本字段中输入你的提交信息。</li>
<li>选择“推到远程”选项（如果您的项目使用Git管理）。</li>
</ul>
</li>
<li><p>点击“提交文件”按钮。</p>
</li>
</ol>
<h2>创建机器人</h2>
<p>共享计划后，你可以创建一个机器人来执行持续集成。</p>
<p>要创建一个僵尸</p>
<p>开发的Mac上，打开的项目，其中包含计划，定义的行动，以自动化。</p>
<p>选择产品&gt;创建BOT，指定机器人的标识属性，并单击“下一步”。</p>
<p>与指定库凭据机器人，并单击“下一步”。</p>
<p>指定的整合时间表，行动的机器人来执行，以及是否清洁产品前建设。</p>
<p>附表：指定往往机器人集成。</p>
<p>定期：整合每小时，每天或每周。<br>在提交更改时集成发布到存储库。<br>手册：机器人不会自动整合。<br>操作：选择机器人作为整合的一部分执行的行动。</p>
<p>清洁：指定机器人是否重用以前的版本。</p>
<p>单击“下一步”。</p>
<p>如果您选择创建机器人执行第一次整合，整合的结果，出现在日志中的导航仪。</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hexo/" term="hexo"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[xcode 5.0 的持续继承]]></title>
    <link href="http://hufeng825.github.com/2013/08/31/ios8/"/>
    <id>http://hufeng825.github.com/2013/08/31/ios8/</id>
    <published>2013-08-31T12:41:27.000Z</published>
    <updated>2013-08-31T13:42:46.000Z</updated>
    <content type="html"><![CDATA[<p>&gt;<br>Xcode的支持持续集成通过Xcode的服务流程。Xcode的服务，可在OS X服务器，自动一体化建设过程中，您的应用程序的分析，测试和归档。<a id="more"></a>从开发的Mac，您可以创建机器人上运行一个单独的服务器，在那里他们执行这些集成。机器人可以帮助确保您的产品始终处于释放状态，当有故障时，服务会通知你的人或代码变化引起的故障。</p>
<img src="http://img.blog.csdn.net/20130617220248765" class="left" width="400" height="600">


<hr>
<h2>概览</h2>
<p>按照本文档中列出的步骤，建立一个持续集成的工作流程，使用Xcode和Xcode服务。<br>    注：持续集成工作流程通常依赖于一个或多个开发Mac上运行Xcode和一个独立的OS X服务器运行Xcode的服务。但是，您可以安装开发的Mac OS X Server的。这样的配置可以有助于评估如何采用持续集成。之后，你会发现它有一个专门的OSX服务器运行Xcode的托管服务，你的资料库，并远程执行集成更多有用的。</p>
<hr>
<h2>设置和自定义的Xcode服务</h2>
<pre><code>即使你从来没有架设一台服务器，你会发现OSX服务器上设立了Xcode服务是简单的过程。后服务运行起来，你可以添加开发设备，配置机器人，并指定发布标准。</code></pre>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/200-Adopting_a_Continuous_Integration_Workflow/adopt_continuous_integration.html#//apple_ref/doc/uid/TP40013292-CH3-SW1" target="_blank">有关章节： “采用持续集成工作流”</a></p>
<hr>
<h2>创建和运行僵尸</h2>
<pre><code>机器人的自动化工作流程的心脏。机器人构建和测试产品与您选择的方案。随着Xcode的服务能够访问你的项目的源代码库中，您可以创建并安排定期运行或在每个源代码提交的机器人。您也可以设定机器人发送邮件通知其集成的成功或失败。</code></pre>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW1" target="_blank">有关章节： “配置机器人执行连续集成”</a></p>
<h2>监控和​​管理集成</h2>
<pre><code>机器人的自动化工作流程的心脏。机器人构建和测试您的产品，您所选择的计划。Xcode的服务提供了日志管理机器人，查看测试结果，并读取整合日志导航。该服务还提供了通过一个网页，在那里您可以查看bot活动的总结以及集成细节的结果。</code></pre>
<p><a href="https://daw.apple.com/cgi-bin/WebObjects/DSAuthWeb.woa/wa/login?appIdKey=891bd3417a7776362562d2197f89480a8547b108fd934911bcbea0110d07f757&amp;path=%2F%2Flibrary%2Fprerelease%2Fios%2Fdocumentation%2FIDEs%2FConceptual%2Fxcode_guide-continuous_integration%2F300-Working_with_Bots%2Fview_integration_results%2Ehtml#//apple_ref/doc/uid/TP40013292-CH4-SW1" target="_blank">有关章节： “工作与机器人”</a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[快速清除subviews之 隐私循环]]></title>
    <link href="http://hufeng825.github.com/2013/08/29/ios7/"/>
    <id>http://hufeng825.github.com/2013/08/29/ios7/</id>
    <published>2013-08-29T10:48:47.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>问：如何快速把当前view下的所有子view 及其子子view们删除掉<br><a id="more"></a><br>解答这个问题前先介绍下 NSArray </p>
</blockquote>
<p>NSArray 类定义的方法</p>
<ol>
<li>makeObjectsPerformSelector:@select（aMethod）</li>
</ol>
<p>简介：让数组中的每个元素 都调用 aMethod </p>
<ol>
<li><p>makeObjectsPerformSelector:@select（aMethod）</p>
<p>　　　　              withObject:oneObject</p>
</li>
</ol>
<p><strong>ps：让数组中的每个元素 都调用 aMethod  并把 withObject 后边的 oneObject 对象做为参数传给方法aMethod</strong></p>
<p>因此可以利用隐私循环来快速清除subviews</p>
<p>[[self.view subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)];</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hexo/" term="hexo"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios iphone5 适配 之 如何是app 适用不通分辨率]]></title>
    <link href="http://hufeng825.github.com/2013/08/29/ios6/"/>
    <id>http://hufeng825.github.com/2013/08/29/ios6/</id>
    <published>2013-08-29T10:44:36.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<p>iphone5适配 有如下集中种思路</p>
<a id="more"></a>

<p>1：利用自身的autoresize 加上代码实现</p>
<p>2：写两套xib</p>
<p>3：利用ios5+ 以上的autolayout</p>
<p>前两种方式应用比较广泛 ，因为毕竟国内还有部分应用ios4.3的用户</p>
<p>下面给第二种方式应用下的部分代码</p>
<figure class="highlight"><pre>- (<span class="keyword">id</span>)init
{

    <span class="built_in">NSString</span>    *clssName = NSStringFromClass([<span class="keyword">self</span> <span class="built_in">class</span>]);
    <span class="built_in">NSString</span>    *xibName = is4InchScreen() ?[<span class="built_in">NSString</span> stringWithFormat:@<span class="string">"%@_4inch"</span>, clssName] : clssName;
    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:xibName bundle:<span class="literal">nil</span>];
    <span class="keyword">if</span> (<span class="keyword">self</span>) {}
    <span class="keyword">return</span> <span class="keyword">self</span>;

}
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios 通过当前view得到所在的viewcontroller]]></title>
    <link href="http://hufeng825.github.com/2013/08/29/ios5/"/>
    <id>http://hufeng825.github.com/2013/08/29/ios5/</id>
    <published>2013-08-29T10:35:01.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<p>long long ago ，带过的小弟遇到了一个问题，需要从当前的控件（一般是uiview）获取当前所在的viewcontroller<br><a id="more"></a><br>当时给出他的解决办法</p>
<figure class="highlight"><pre>@<span class="class"><span class="keyword">implementation</span> <span class="id">UIView</span> (<span class="id">GetVCAdditions</span>)</span>
- (<span class="built_in">UIViewController</span> *)GetiewController {
    Class vcc = [<span class="built_in">UIViewController</span> <span class="built_in">class</span>];
    UIResponder *responder = <span class="keyword">self</span>;
    <span class="keyword">while</span> ((responder = [responder nextResponder]))
        <span class="keyword">if</span> ([responder isKindOfClass: vcc])
            <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;
    <span class="keyword">return</span> <span class="literal">nil</span>;
}
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[removeFromSuperview添加动画使其更加高雅美观]]></title>
    <link href="http://hufeng825.github.com/2013/08/29/ios4/"/>
    <id>http://hufeng825.github.com/2013/08/29/ios4/</id>
    <published>2013-08-29T10:29:40.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>程序中难免使用removeFromSuperview，但是view控件直接从界面突然消失会显得非常不友好，作为一个高端大气上档次的app细节处处应该注意，<br><a id="more"></a><br>添加一个简单的动画给用户的感觉立刻不一样了。废话不说直接上代码</p>
<figure class="highlight"><pre>   [UIView animateWithDuration:<span class="number">0.2</span>

                     animations:^{_logViewController<span class="preprocessor">.view</span><span class="preprocessor">.alpha</span> = <span class="number">0.0</span><span class="comment">;}</span>

                     completion:^(BOOL finished)

                                { [_logViewController<span class="preprocessor">.view</span> removeFromSuperview]<span class="comment">; }</span>

     ]<span class="comment">;</span>
</pre></figure>

</blockquote>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios 清理工程中没有用到的图片]]></title>
    <link href="http://hufeng825.github.com/2013/08/29/ios3/"/>
    <id>http://hufeng825.github.com/2013/08/29/ios3/</id>
    <published>2013-08-29T08:43:14.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>发布前往往需要清理工程中没有用到的图片，这些图片可能是测试图片也可能是以往版本中替换遗留下来的图片</p>
</blockquote>
<a id="more"></a>

<h2>使用方法</h2>
<ol>
<li>将下面代码保存成**.sh 然后chomd 777 使其可执行</li>
<li>将**.sh 拷贝到工程根目录下</li>
<li>./执行**.sh </li>
<li><p>再同级目录下会生成一个imge.txt 结果文件</p>
<p>如下图  </p>
</li>
</ol>
<img src="http://ww3.sinaimg.cn/mw690/a43af4ffjw1e83pb1zvo7j215q0pq7bz.jpg" width="300" height="500">


<h2>源码</h2>
<figure class="highlight"><pre><span class="shebang">#!/bin/sh</span>

<span class="keyword">echo</span> <span class="string">"删除有风险 下手需谨慎 如需再次确认图片是否被引用到"</span>

<span class="keyword">echo</span> <span class="string">"Defult.png 和例如[UIImage imageNamed:@‘img.png'] 可能会误报"</span>


read -n1 -p  <span class="string">"【Y】查阅如何确认 【N】直接进行图片检索"</span> 

case <span class="variable">$answer</span> <span class="keyword">in</span> 

<span class="string">"Y"</span>|<span class="string">"y"</span>) 

open -a Safari <span class="string">"http://blog.csdn.net/hufeng825/article/details/8533647"</span>

<span class="keyword">echo</span> -n <span class="string">"按任意键开始程序"</span>;

read var

;;

<span class="string">"N"</span>|<span class="string">"n"</span>) 

<span class="keyword">echo</span> <span class="string">"命令执行时终端会输入结果 搜索完毕后 会在当前路径下自动生成imag.txt的结果报告"</span>

;;

*) 

;;

esac




PROJ=`find .  ! -name <span class="string">'*.xib'</span> -o -name <span class="string">'*.[mh]'</span> -o -name <span class="string">'*.storyboard'</span> -o -name <span class="string">'*.mm'</span> -o -name <span class="string">'*.html'</span> `


<span class="keyword">echo</span> <span class="string">"~~~~~~~~~~~~开始搜索~~~~~~~~~~~~"</span> &gt;&gt;<span class="string">'./image.txt'</span>;

<span class="keyword">for</span> png <span class="keyword">in</span> `find . -name <span class="string">'*.png'</span>`
<span class="keyword">do</span>

   name=`basename -s .png <span class="variable">$png</span>`
   name=`basename -s @2x <span class="variable">$name</span>`
   <span class="keyword">if</span> ! grep -qhs <span class="string">"<span class="variable">$name</span>"</span> <span class="string">"<span class="variable">$PROJ</span>"</span>; <span class="keyword">then</span>
        <span class="keyword">echo</span> <span class="string">"<span class="variable">$png</span> 可能没引用"</span> 
        <span class="keyword">echo</span> <span class="string">"<span class="variable">$png</span> 可能没引用"</span>  &gt;&gt;<span class="string">'./image.txt'</span> ;
   <span class="keyword">fi</span>
<span class="keyword">done</span>

<span class="keyword">for</span> jpg <span class="keyword">in</span> `find . -name <span class="string">'*.jpg'</span>`
<span class="keyword">do</span>
   name=`basename -s .jpg <span class="variable">$jpg</span>`
   name=`basename -s @2x <span class="variable">$name</span>`
   <span class="keyword">if</span> ! grep -qhs <span class="string">"<span class="variable">$name</span>"</span> <span class="string">"<span class="variable">$PROJ</span>"</span>; <span class="keyword">then</span>
        <span class="keyword">echo</span> <span class="string">"<span class="variable">$png</span> 可能没引用"</span> 
        <span class="keyword">echo</span> <span class="string">"<span class="variable">$jpg</span> 可能没引用"</span>  &gt;&gt;<span class="string">'./image.txt'</span>;
   <span class="keyword">fi</span>
<span class="keyword">done</span>

<span class="keyword">echo</span> <span class="string">"~~~~~~~~~~~~结束搜索~~~~~~~~~~~~"</span> &gt;&gt;<span class="string">'./image.txt'</span>;
&lt;&lt;EOF
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[MQ 笔记之 发送接受实例]]></title>
    <link href="http://hufeng825.github.com/2013/08/23/mq5/"/>
    <id>http://hufeng825.github.com/2013/08/23/mq5/</id>
    <published>2013-08-23T02:27:45.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>mq 支持多种发送格式  BytesMessage  MapMessage ObjectMessage TextMessage StreamMessage等<br><a id="more"></a></p>
</blockquote>
<p>本文章以 MapMessage 和 ObjectMessage 为例</p>
<p><strong>注意 发送ObjectMessage时  接受实例必须相同类名</strong></p>
<h2>发送实例</h2>
<p>import org.apache.activemq.ActiveMQConnectionFactory;</p>
<p>import javax.jms.*;</p>
<p>public class Send {</p>
<p> public static void main(String[] args) throws Exception {<br>        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory();</p>
<pre><code>    Connection connection = connectionFactory<span class="preprocessor">.createConnection</span>()<span class="comment">;</span>
    connection<span class="preprocessor">.start</span>()<span class="comment">;</span>

    Session session = connection<span class="preprocessor">.createSession</span>(Boolean<span class="preprocessor">.TRUE</span>, Session<span class="preprocessor">.AUTO</span>_ACKNOWLEDGE)<span class="comment">;</span>
    Destination destination = session<span class="preprocessor">.createQueue</span>(<span class="string">"hf"</span>)<span class="comment">;</span>

    MessageProducer producer = session<span class="preprocessor">.createProducer</span>(destination)<span class="comment">;</span>
   for(int i=<span class="number">0</span><span class="comment">; i&lt;3; i++) {</span></code></pre>
<p>//            MapMessage message = session.createMapMessage();<br>//           message.setLong(“count”, new Date().getTime());<br>//            message.setObject(“hf”,new SendData());<br>      ObjectMessage message = session.createObjectMessage();<br>      message.setObject(new SendData());<br>//           message.setBytes(“count”, getTestData(1));<br>            Thread.sleep(1);<br>            //通过消息生产者发出消息<br>            producer.send(message);<br>        }<br>        session.commit();<br>        session.close();<br>        connection.close();<br>    }<br>}</p>
<h2>接收实例</h2>
<figure class="highlight"><pre>import org<span class="preprocessor">.apache</span><span class="preprocessor">.activemq</span><span class="preprocessor">.ActiveMQConnectionFactory</span><span class="comment">;</span>

import javax<span class="preprocessor">.jms</span>.*<span class="comment">;</span>

public class Recive {

public static void main(String[] args) throws Exception {
    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory()<span class="comment">;</span>

    Connection connection = connectionFactory<span class="preprocessor">.createConnection</span>()<span class="comment">;</span>
    connection<span class="preprocessor">.start</span>()<span class="comment">;</span>

    final Session session = connection<span class="preprocessor">.createSession</span>(Boolean<span class="preprocessor">.TRUE</span>, Session<span class="preprocessor">.AUTO</span>_ACKNOWLEDGE)<span class="comment">;</span>
    Destination destination = session<span class="preprocessor">.createQueue</span>(<span class="string">"hf"</span>)<span class="comment">;</span>

    MessageConsumer consumer = session<span class="preprocessor">.createConsumer</span>(destination)<span class="comment">;</span>
<span class="comment">/*//listener 方式
consumer.setMessageListener(new MessageListener() {

    public void onMessage(Message msg) {
        MapMessage message = (MapMessage) msg;
        //TODO something....
        System.out.println("收到消息：" + new Date(message.getLong("count")));
        session.commit();
    }

});
Thread.sleep(30000);
	*/</span>
	int i=<span class="number">0</span><span class="comment">;</span>
	while(i&lt;<span class="number">100</span>) {
	i++<span class="comment">;</span>
	//            MapMessage message = (MapMessage) consumer<span class="preprocessor">.receive</span>()<span class="comment">;</span>
	ObjectMessage message = (ObjectMessage) consumer<span class="preprocessor">.receive</span>()<span class="comment">;</span>

	session<span class="preprocessor">.commit</span>()<span class="comment">;</span>

	//TODO something....
	//             System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(<span class="string">"收到消息："</span> + arrayToString(message<span class="preprocessor">.getBytes</span>(<span class="string">"count"</span>)))<span class="comment">;</span>

	System<span class="preprocessor">.out</span><span class="preprocessor">.println</span>(<span class="string">"收到消息："</span> + ((SendData) message<span class="preprocessor">.getObject</span>())<span class="preprocessor">.getDateStr</span>())<span class="comment">;</span>
	}

	session<span class="preprocessor">.close</span>()<span class="comment">;</span>
	connection<span class="preprocessor">.close</span>()<span class="comment">;</span>
}

//    public static final String arrayToString(byte[] bytes)
//    {
//        StringBuffer buff = new StringBuffer()<span class="comment">;</span>
//        for (int i = <span class="number">0</span><span class="comment">; i &lt; bytes.length; i++)</span>
//        {
//            buff<span class="preprocessor">.append</span>(bytes[i] + <span class="string">" "</span>)<span class="comment">;</span>
//        }
//        return buff<span class="preprocessor">.toString</span>()<span class="comment">;</span>
//    }
}
</pre></figure>

<h2>传递参数</h2>
<p>import java.io.Serializable;<br>import java.util.Date;</p>
<p>/<em>*
 </em> Created with IntelliJ IDEA.<br> <em> User: jason
 </em> Date: 13-8-22<br> <em> Time: 下午5:21
 </em> To change this template use File | Settings | File Templates.<br> */<br>public class SendData  implements Serializable {</p>
<p>//    private  static  final  long serialVersionUID = -23235245213533L;</p>
<pre><code><span class="keyword">private</span>  <span class="keyword">byte</span>[] buffer;

<span class="keyword">private</span> String dateStr;

<span class="keyword">public</span> SendData() {
    setBuffer(<span class="keyword">null</span>);
    setDateStr(<span class="keyword">null</span>);
}

<span class="keyword">public</span> <span class="keyword">byte</span>[] getBuffer() {
    <span class="keyword">return</span> buffer;
}

<span class="keyword">public</span> String getDateStr() {
    <span class="keyword">return</span> dateStr;
}

<span class="keyword">public</span> <span class="keyword">void</span> setDateStr(String dateStr) {
    <span class="keyword">this</span>.dateStr = String.valueOf(<span class="keyword">new</span> Date().getTime());
}

<span class="keyword">public</span> <span class="keyword">void</span> setBuffer(<span class="keyword">byte</span>[] buffer) {
    System.<span class="keyword">out</span>.print(<span class="string">"begin \n"</span>);
    <span class="keyword">byte</span> [ ] buffers = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1</span>];
    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ;  i&lt; buffers.length ;i++)
        buffers[i] = Byte.parseByte(<span class="string">"2"</span>);
    System.<span class="keyword">out</span>.print(<span class="string">"end \n"</span>);
    <span class="keyword">this</span>.buffer = buffers;
}</code></pre>
<p>}</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/MQ/" term="MQ"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[MQ 笔记之 游标 及其游标优化]]></title>
    <link href="http://hufeng825.github.com/2013/08/22/mq4/"/>
    <id>http://hufeng825.github.com/2013/08/22/mq4/</id>
    <published>2013-08-22T01:38:51.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<h2>概观</h2>
<blockquote>
<p>在ActiveMQ的Broker中，光标用来持有一批在内存等待发送目标地址的消息。默认情况下这小消息被从存储器取出只想一个cursor(存储光标)<br><a id="more"></a><br>5.0.0版本后，Activemq实现了一种新的内存模型来防止慢消费者阻塞快速生产者。通常消息在未消费或者发送后未收到消费者的确认信息时都会持久保存消息到存储中。当有消费者来消费消息时，broker会分页一批一批的从存储中取出消息，放入消息处理队列。游标就是指向下次批量获取消息时的存储位置。   </p>
</blockquote>
<p>ctiveMQ有另一种游标实现，VM cursor，在某些情境下非常快。VM cursor是，进入的消息直接关联cursor，同时存储到消息存储器中。（关联cursor的同时存储到消息存储器中）。如果消费者（consumer）非常快，可以跟的上消息流的话，VM cursor会工作的非常好。但是，对于慢消费者，这个策略就不是那么有效了。VMcursor被积压的消息填满，同时它可能会去调用流控制去抑制producer生产message。</p>
<h2>根据游标的保存方式不同，可分为三种类型：</h2>
<h3>Store-based cursors</h3>
<p>broker默认采用的游标。它将游标信息保存在存储中。针对速度不同的消费者，这种游标机制采取的方式不同。对于快速消费者，因为消费速度很快，存储中 的消息数量会很少，所以不需要游标。这时，消息发送到broker时，先保存在持久存储中，然后直接发送给了消费者。而对于慢消费者，消息的持久存储中会 保存大量的消息，所以需要使用游标来指定下一次批量读取消息的位置。  </p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v81y31hnj20ip04qaaj.jpg" class="center" title="Store-based实现原理图 300 200">

<p> <strong>图一：</strong></p>
<pre><code> 消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedHashMap，如果没有可用内存，则走路径2，当需要消息的时候，直接从消息存储的介质里每次读取一批消息，然后存入LinkedHashMap。</code></pre>
<h3>VM cursors</h3>
<p>若消费者能跟上生产者生产的速度，这时持久存储中消息虽然不是很多，但是若能也能在内存中保存一些游标，对获取存储中的消息的性能会有很大的提升。<br>那么VM Cursors在ActiveMQ4.x中是如何工作的呢？发送消息保存在内存中，并在需要的时候传递给调度队列。这可以是非常快的，但也有不利的一面，不能够处理非常缓慢的消费者或消费者已经很长一段时间处于非活动状态：   </p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7v878r0ahj20iu04tjrr.jpg" class="center" title="file实现原理图 300 200">

<p>  <strong>图二：</strong></p>
<pre><code>消息接收后，首先完成消息存储的工作，如(1)所示，然后会判断是否有空闲的内存可用，如果有的话，就走路径1，直接把消息存放在内存中的LinkedList，如果没有可用内存，则走路径2，把消息写入临时文件中，当需要消息的时候，直接从临时文件中读写一批，然后送入LinkedList。</code></pre>
<h3>File-based cursors</h3>
<p>对VM cursors 的一种改进。当内存中的游标达到一定限额后，就会将一些游标存储到磁盘上的临时文件中。使用这种类型的游标时，消息储存可能会变慢，但消费者处理一般都会更快。通过缓冲到磁盘，它可以让消息代理来处理不受内存限制的大量消息，而生产者发送消息的速度会受到影响：<br> <strong>图三</strong></p>
 <img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7v8airx6dj20it04sjrl.jpg" class="center" title="vm 实现原理 300 200">

<pre><code> 消息接收后，首先完成消息存储的工作，如(1)所示，然后直接把消息存放在内存中的LinkedList。</code></pre>
<h3>Paging for Non-Persistent Messages（非持久性的消息分页调度）</h3>
<p>Store based cursor也可以处理非持久性的消息，也就是没有存储在磁盘中的消息，非持久性消息被直接传递给游标，所以Store based cursor也只是嵌入了File based cursor的功能。</p>
<h2>3种消息cursor的比较</h2>
<table>
<thead>
<tr>
<th>消息cursor类型</th>
<th>性能</th>
<th>稳定性</th>
<th>最佳使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Store-based</td>
<td>当内存不够时，需要进行1次消息存储操作，性能在3种方式中居中</td>
<td>最好</td>
<td>activeMQ默认使用该cursor，因为它能满足大部分场景需要</td>
</tr>
<tr>
<td>File</td>
<td>当内存不够时，需要进行2次消息存储操作，并且在删除消息的时候也就相应的要删除2次，性能在3种方式中最差</td>
<td>居中</td>
<td>主要用在当消息存储慢(如消息是放在数据库里)，并且消费者相对快的情况下</td>
</tr>
<tr>
<td>VM</td>
<td>在内存够的情况下，3种message cursor性能一样</td>
<td>最容易出现内存溢出的问题</td>
<td>很快，但不能处理慢消息消费者</td>
</tr>
</tbody>
</table>
<h3>基于存储的消息指针_测试结果</h3>
<table>
<thead>
<tr>
<th>测试方法</th>
<th>结果说明</th>
<th>是否通过</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送,不接收，因为是默认的，所以不用在服务器端配置。</td>
<td>1．对于非持久化消息，一定数量之后，也会产生临时文件。 2．对于持久化的消息，则适用该方式的消息指针，直到达到磁盘空间的设置上限。</td>
<td>是</td>
<td></td>
</tr>
</tbody>
</table>
<h3>VM消息指针_测试结果</h3>
<table>
<thead>
<tr>
<th>测试方法</th>
<th>结果说明</th>
<th>是否通过</th>
<th>备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td>开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：cursore 队列中存储到一定量消息的时候，broker不再接收生产者发送过来的消息，56W左右，broker也不报错，客户端也不报错。</td>
<td>是</td>
<td>若设置producerflowControl=false，则消息数量持续增长，直到broker报错：WARN  AMQMessageStore  - Message could not be added to long term store: Java heap space java.lang.OutOfMemoryError: Java heap space </td>
</tr>
</tbody>
</table>
<h3>基于文件的消息指针_测试结果</h3>
<table>
<thead>
<tr>
<th>测试方法</th>
<th>结果说明</th>
<th>是否通过</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>开500个queue 持久化消息/非持久化消息 的发送客户端，一直发送，在Activemq.xml配置文件中配置：fileQueueCursor</td>
<td>一段时间之后，broker打印出一信息：INFO MonetStore - Monet Store using data directory &quot;C:\Activemq 5.1\bin..  \data\localhost\tmp_storage&quot;  临时文件被放置在tmp_storage目录下</td>
<td>是</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h2>Configuring Cursors</h2>
<p>Activemq默认使用store-based游标。当然也可为不同的Destination修改游标策略。通过修改destinationPolicy节点来更改默认配置。<br>destinationPolicy节点包含多ge policyMap节点。<br>policyMap包含一个policyEntries节点，policyEntries节点包含多个policyEntry 节点。policyEntry就是具体的一个游标策略了。<br>Topics的消费者分为持久订阅者和临时订阅者，所以有两套配置。Queues只有一类消费者，所以只有一套配置。<br>对于持久订阅者可以使用PendingDurableSubscriberMessageStoragePolicy来指定游标策略。可配置的策略有vmDurableCursor和fileDurableSubscriberCursor. </p>
<p><strong>对于临时订阅者可以使用pendingSubscriberPolicy 来指定。可配置的策略有vmCursor和fileCursor。下面是关于Topics的一些xml配置：</strong></p>
<figure class="highlight"><pre>&lt;beans <span class="keyword">...</span> &gt;
&lt;broker <span class="keyword">...</span>&gt;
    <span class="keyword">...</span>
&lt;destinationPolicy&gt;
&lt;policyMap&gt;
&lt;policyEntries&gt;
&lt;policyEntrytopic=<span class="string">"com.iona.&gt;"</span>&gt;
            <span class="keyword">...</span>
&lt;pendingSubscriberPolicy&gt;
&lt;vmCursor/&gt;
&lt;/pendingSubscriberPolicy&gt;
&lt;PendingDurableSubscriberMessageStoragePolicy&gt;
&lt;fileDurableSubscriberPolicy/&gt;
&lt;/PendingDurableSubscriberMessageStoragePolicy&gt;
            <span class="keyword">...</span>
&lt;/policyEntry&gt;
          <span class="keyword">...</span>
&lt;/policyEntries&gt;
&lt;/policyMap&gt;
&lt;/destinationPolicy&gt;
    <span class="keyword">...</span>
&lt;/broker&gt;
  <span class="keyword">...</span>
&lt;/beans&gt;
</pre></figure>

<p><strong>Queues 同样也有vm和file两种类型的游标存储策略。pendingQueuePolicy 节点的可配置子节点有vmQueueCursor和fileQueueCursor</strong></p>
<figure class="highlight"><pre>&lt;beans <span class="keyword">...</span> &gt;
&lt;broker <span class="keyword">...</span>&gt;
        <span class="keyword">...</span>   
&lt;destinationPolicy&gt;
&lt;policyMap&gt;
&lt;policyEntries&gt;
&lt;policyEntryqueue=<span class="string">"com.iona.&gt;"</span>&gt;  
                <span class="keyword">...</span>   
&lt;pendingQueuePolicy&gt;
&lt;vmQueueCursor/&gt;
&lt;/pendingQueuePolicy&gt;
                <span class="keyword">...</span>   
&lt;/policyEntry&gt;
              <span class="keyword">...</span>   
&lt;/policyEntries&gt;
&lt;/policyMap&gt;
&lt;/destinationPolicy&gt;
        <span class="keyword">...</span>   
&lt;/broker&gt;
      <span class="keyword">...</span>   
&lt;/beans&gt;
</pre></figure>

<h3>配置vmcursor：</h3>
<p>下面配置了一个borker的所有topic和queue都使用了vmCursor</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">broker</span> <span class="attribute">...</span> &gt;</span>
  ...
  <span class="tag">&lt;<span class="title">destinationPolicy</span>&gt;</span>
    <span class="tag">&lt;<span class="title">policyMap</span>&gt;</span>
      <span class="tag">&lt;<span class="title">policyEntries</span>&gt;</span>
        <span class="tag">&lt;<span class="title">policyEntry</span> <span class="attribute">topic</span>=<span class="value">"&gt;"</span>&gt;</span>
          <span class="tag">&lt;<span class="title">pendingSubscriberPolicy</span>&gt;</span>
            <span class="tag">&lt;<span class="title">vmCursor</span> /&gt;</span>
          <span class="tag">&lt;/<span class="title">pendingSubscriberPolicy</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">policyEntry</span>&gt;</span>
        <span class="tag">&lt;<span class="title">policyEntry</span> <span class="attribute">queue</span>=<span class="value">"&gt;"</span>&gt;</span>
          <span class="tag">&lt;<span class="title">pendingSubscriberPolicy</span>&gt;</span>
            <span class="tag">&lt;<span class="title">vmCursor</span> /&gt;</span>
          <span class="tag">&lt;/<span class="title">pendingSubscriberPolicy</span>&gt;</span>
        <span class="tag">&lt;/<span class="title">policyEntry</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">policyEntries</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">policyMap</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">destinationPolicy</span>&gt;</span>
  ...
<span class="tag">&lt;/<span class="title">broker</span>&gt;</span>
</pre></figure>

<p>topic和queue都使用了通配符【&gt;】,这个匹配所有的目标名称。你可以根据情况指定一些选择目标的模式。但是VM Cursor仅仅适用于那些消费者可以跟得上目标消息节奏的这种情况。</p>
<hr>
<p><a href="http://www.cnblogs.com/kaka/archive/2012/07/24/2606699.html" target="_blank">http://www.cnblogs.com/kaka/archive/2012/07/24/2606699.html</a><br><a href="http://netcomm.iteye.com/blog/470585" target="_blank">http://netcomm.iteye.com/blog/470585</a></p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/MQ/" term="MQ"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[MQ 笔记之 消息持久化]]></title>
    <link href="http://hufeng825.github.com/2013/08/21/mq3/"/>
    <id>http://hufeng825.github.com/2013/08/21/mq3/</id>
    <published>2013-08-21T15:43:37.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在broker中设置属性persistent=”true”(默认是true)，同时发送的消息也应该是persitent类型的。ActiveMQ消息持久化有三种方式：AMQ、KahaDB、JDBC。<br>配置文件在config/jetty.xml<br><a id="more"></a></p>
</blockquote>
<h2>一、AMQ</h2>
<p>AMQ是一种文件存储形式，它具有写入速度快和容易恢复的特点。消息存储在一个个文件中，文件的默认大小为32兆，如果一条消息的大小超过了32兆，那么这个值必须设置大点。当一个存储文件中的消息已经全部被消费，那么这个文件将被标识为可删除，在下一个清除阶段，这个文件被删除。默认配置如下：</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
  <span class="tag">&lt;<span class="title">amqPersistenceAdapter</span> <span class="attribute">directory</span>=<span class="value">"activemq-data"</span> <span class="attribute">maxFileLength</span>=<span class="value">"32mb"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span>
</pre></figure>

<table>
<thead>
<tr>
<th>属性名称</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>directory</td>
<td>activemq-data</td>
<td>消息文件和日志的存储目录</td>
</tr>
<tr>
<td>useNIO</td>
<td>true</td>
<td>使用NIO协议存储消息</td>
</tr>
<tr>
<td>syncOnWrite</td>
<td>false</td>
<td>同步写到磁盘，这个选项对性能影响非常大</td>
</tr>
<tr>
<td>maxFileLength</td>
<td>32mb</td>
<td>一个消息文件的大小</td>
</tr>
<tr>
<td>persistentIndex</td>
<td>true</td>
<td>消息索引的持久化，如果为false，那么索引保存在内存中</td>
</tr>
<tr>
<td>maxCheckpointMessageAddSize</td>
<td>4kb</td>
<td>一个事务允许的最大消息量</td>
</tr>
<tr>
<td>cleanupInterval</td>
<td>30000</td>
<td>清除操作周期，单位ms</td>
</tr>
<tr>
<td>indexBinSize</td>
<td>1024</td>
<td>索引文件缓存页面数，缺省为1024，当amq扩充或者缩减存储时，会锁定整个broker，导致一定时间的阻塞，所以这个值应该调整到比较大，但是代码中实现会动态伸缩，调整效果并不理想。</td>
</tr>
<tr>
<td>indexKeySize</td>
<td>96</td>
<td>索引key的大小，key是消息ID</td>
</tr>
<tr>
<td>indexPageSize</td>
<td>16kb</td>
<td>索引的页大小</td>
</tr>
<tr>
<td>directoryArchive</td>
<td>archive</td>
<td>存储被归档的消息文件目录</td>
</tr>
<tr>
<td>archiveDataLogs</td>
<td>false</td>
<td>当为true时，归档的消息文件被移到directoryArchive,而不是直接删除</td>
</tr>
</tbody>
</table>
<hr>
<h2>二、 KahaDB</h2>
<p>KahaDB是基于文件的本地数据库储存形式，虽然没有AMQ的速度快，但是它具有强扩展性，恢复的时间比AMQ短，从5.4版本之后KahaDB做为默认的持久化方式。默认配置如下</p>
<figure class="highlight"><pre> <span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
        <span class="tag">&lt;<span class="title">kahaDB</span> <span class="attribute">directory</span>=<span class="value">"activemq-data"</span> <span class="attribute">journalMaxFileLength</span>=<span class="value">"32mb"</span>/&gt;</span>
 <span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span>
</pre></figure>

<p>KahaDB的属性：</p>
<table>
<thead>
<tr>
<th>property name</th>
<th>default value</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>directory</td>
<td>activemq-data</td>
<td>消息文件和日志的存储目录</td>
</tr>
<tr>
<td>indexWriteBatchSize</td>
<td>1000</td>
<td>一批索引的大小，当要更新的索引量到达这个值时，更新到消息文件中</td>
</tr>
<tr>
<td>indexCacheSize</td>
<td>10000</td>
<td>内存中，索引的页大小</td>
</tr>
<tr>
<td>enableIndexWriteAsync</td>
<td>false</td>
<td>索引是否异步写到消息文件中</td>
</tr>
<tr>
<td>journalMaxFileLength</td>
<td>32mb</td>
<td>一个消息文件的大小</td>
</tr>
<tr>
<td>enableJournalDiskSyncs</td>
<td>true</td>
<td>是否讲非事务的消息同步写入到磁盘</td>
</tr>
<tr>
<td>cleanupInterval</td>
<td>30000</td>
<td>清除操作周期，单位ms</td>
</tr>
<tr>
<td>checkpointInterval</td>
<td>5000</td>
<td>索引写入到消息文件的周期，单位ms</td>
</tr>
<tr>
<td>ignoreMissingJournalfiles</td>
<td>false</td>
<td>忽略丢失的消息文件，false，当丢失了消息文件，启动异常</td>
</tr>
<tr>
<td>checkForCorruptJournalFiles</td>
<td>false</td>
<td>检查消息文件是否损坏，true，检查发现损坏会尝试修复</td>
</tr>
<tr>
<td>checksumJournalFiles</td>
<td>false</td>
<td>产生一个checksum，以便能够检测journal文件是否损坏。</td>
</tr>
<tr>
<td><code>5.4版本之后有效的属性:</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>archiveDataLogs</td>
<td>false</td>
<td>当为true时，归档的消息文件被移到directoryArchive,而不是直接删除</td>
</tr>
<tr>
<td>directoryArchive</td>
<td>null</td>
<td>存储被归档的消息文件目录</td>
</tr>
<tr>
<td>databaseLockedWaitDelay</td>
<td>10000</td>
<td>在使用负载时，等待获得文件锁的延迟时间，单位ms</td>
</tr>
<tr>
<td>maxAsyncJobs</td>
<td>10000</td>
<td>同个生产者产生等待写入的异步消息最大量</td>
</tr>
<tr>
<td>concurrentStoreAndDispatchTopics</td>
<td>false</td>
<td>当写入消息的时候，是否转发主题消息</td>
</tr>
<tr>
<td>concurrentStoreAndDispatchQueues</td>
<td>true</td>
<td>当写入消息的时候，是否转发队列消息</td>
</tr>
<tr>
<td>5.6版本之后有效的属性:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>archiveCorruptedIndex</td>
<td>false</td>
<td>是否归档错误的索引</td>
</tr>
</tbody>
</table>
<p>从5.6版本之后，有可能发布通过多个kahadb持久适配器来实现分布式目标队列存储。什么时候用呢？如果有一个快速的生产者和消费者，当某一个时刻生产者发生了不规范的消费，那么有可能产生一条消息被存储在两个消息文件中，同时，有些目标队列是危险的并且要求访问磁盘。在这种情况下，你应该用通配符来使用mKahaDB。如果目标队列是分布的，事务是可以跨越多个消息文件的。</p>
<p>每个KahaDB的实例都可以配置单独的适配器，如果没有目标队列提交给filteredKahaDB，那么意味着对所有的队列有效。如果一个队列没有对应的适配器，那么将会抛出一个异常。配置如下：</p>
<figure class="highlight"><pre><span class="xml"><span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
  <span class="tag">&lt;<span class="title">mKahaDB</span> <span class="attribute">directory</span>=<span class="value">"</span><span class="variable">${activemq.base}</span><span class="xml">/data/kahadb"&gt;
    <span class="tag">&lt;<span class="title">filteredPersistenceAdapters</span>&gt;</span>
      <span class="comment">&lt;!-- match all queues --&gt;</span>
      <span class="tag">&lt;<span class="title">filteredKahaDB</span> <span class="attribute">queue</span>=<span class="value">"&gt;"</span>&gt;</span>
        <span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
          <span class="tag">&lt;<span class="title">kahaDB</span> <span class="attribute">journalMaxFileLength</span>=<span class="value">"</span><span class="number">32</span><span class="xml">mb"/&gt;
        <span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">filteredKahaDB</span>&gt;</span>
      
      <span class="comment">&lt;!-- match all destinations --&gt;</span>
      <span class="tag">&lt;<span class="title">filteredKahaDB</span>&gt;</span>
        <span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
          <span class="tag">&lt;<span class="title">kahaDB</span> <span class="attribute">enableJournalDiskSyncs</span>=<span class="value">"false"</span>/&gt;</span>
        <span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">filteredKahaDB</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">filteredPersistenceAdapters</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">mKahaDB</span>&gt;</span>
 <span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span></span>
</pre></figure>

<p>如果filteredKahaDB的perDestination属性设置为true，那么匹配的目标队列将会得到自己对应的KahaDB实例。配置如下</p>
<figure class="highlight"><pre><span class="xml"><span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
  <span class="tag">&lt;<span class="title">mKahaDB</span> <span class="attribute">directory</span>=<span class="value">"</span><span class="variable">${activemq.base}</span><span class="xml">/data/kahadb"&gt;
    <span class="tag">&lt;<span class="title">filteredPersistenceAdapters</span>&gt;</span>
      <span class="comment">&lt;!-- kahaDB per destinations --&gt;</span>
      <span class="tag">&lt;<span class="title">filteredKahaDB</span> <span class="attribute">perDestination</span>=<span class="value">"true"</span> &gt;</span>
        <span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
          <span class="tag">&lt;<span class="title">kahaDB</span> <span class="attribute">journalMaxFileLength</span>=<span class="value">"</span><span class="number">32</span><span class="xml">mb" /&gt;
        <span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">filteredKahaDB</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">filteredPersistenceAdapters</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">mKahaDB</span>&gt;</span>
 <span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span></span>
</pre></figure>

<h2>三、 JDBC</h2>
<p>配置JDBC适配器</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">persistenceAdapter</span>&gt;</span>
        <span class="tag">&lt;<span class="title">jdbcPersistenceAdapter</span> <span class="attribute">dataSource</span>=<span class="value">"#mysql-ds"</span> <span class="attribute">createTablesOnStartup</span>=<span class="value">"false"</span> /&gt;</span>
<span class="tag">&lt;/<span class="title">persistenceAdapter</span>&gt;</span>
</pre></figure>

<p>dataSource指定持久化数据库的bean，createTablesOnStartup是否在启动的时候创建数据表，默认值是true，这样每次启动都会去创建数据表了，一般是第一次启动的时候设置为true，之后改成false。</p>
<p>MYSQL持久化bean</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"mysql-ds"</span> <span class="attribute">class</span>=<span class="value">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClassName"</span> <span class="attribute">value</span>=<span class="value">"com.mysql.jdbc.Driver"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"url"</span> <span class="attribute">value</span>=<span class="value">"jdbc:mysql://localhost/activemq?relaxAutoCommit=true"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"activemq"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"activemq"</span>/&gt;</span>
    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"poolPreparedStatements"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></figure>

<p>SQL Server持久化bean</p>
<figure class="highlight"><pre> <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"mssql-ds"</span> <span class="attribute">class</span>=<span class="value">"net.sourceforge.jtds.jdbcx.JtdsDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span>&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"serverName"</span> <span class="attribute">value</span>=<span class="value">"SERVERNAME"</span>/&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"portNumber"</span> <span class="attribute">value</span>=<span class="value">"PORTNUMBER"</span>/&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"databaseName"</span> <span class="attribute">value</span>=<span class="value">"DATABASENAME"</span>/&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"USER"</span>/&gt;</span>
   <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"PASSWORD"</span>/&gt;</span>
 <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></figure>

<p>Oracle持久化bean</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"oracle-ds"</span> <span class="attribute">class</span>=<span class="value">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClassName"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"url"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@10.53.132.47:1521:activemq"</span>/&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"activemq"</span>/&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"activemq"</span>/&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxActive"</span> <span class="attribute">value</span>=<span class="value">"200"</span>/&gt;</span>
	<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"poolPreparedStatements"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></figure>

<p>DB2持久化bean</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"db2-ds"</span> <span class="attribute">class</span>=<span class="value">"org.apache.commons.dbcp.BasicDataSource"</span>  <span class="attribute">destroy-method</span>=<span class="value">"close"</span>&gt;</span>
      <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClassName"</span> <span class="attribute">value</span>=<span class="value">"com.ibm.db2.jcc.DB2Driver"</span>/&gt;</span>
      <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"url"</span> <span class="attribute">value</span>=<span class="value">"jdbc:db2://hndb02.bf.ctc.com:50002/activemq"</span>/&gt;</span>
      <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"activemq"</span>/&gt;</span>
      <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"activemq"</span>/&gt;</span>
      <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxActive"</span> <span class="attribute">value</span>=<span class="value">"200"</span>/&gt;</span>
      <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"poolPreparedStatements"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span>
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></figure>

<hr>
<blockquote>
<p>本博文from 淮少吧</p>
</blockquote>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/MQ/" term="MQ"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[MQ 笔记之 JMS 简介 （什么是JMS）]]></title>
    <link href="http://hufeng825.github.com/2013/08/21/mq2/"/>
    <id>http://hufeng825.github.com/2013/08/21/mq2/</id>
    <published>2013-08-21T13:22:00.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<h2>一：JMS基本概念</h2>
<h3>1.      JMS的目标</h3>
<p>为企业级的应用提供一种智能的消息系统，JMS定义了一整套的企业级的消息概念与工具，<br><a id="more"></a></p>
<p>尽可能最小化的Java语言概念去构建最大化企业消息应用。统一已经存在的企业级消息系</p>
<p>统功能。</p>
<h3>2.      JMS提供者</h3>
<p>JMS提供者是指那些完全完成JMS功能与管理功能的JMS消息厂商，理论上JMS提供者完成 </p>
<p>JMS消息产品必须是100%的纯Java语言实现，可以运行在跨平台的架构与操作系统上，当前</p>
<p>一些JMS厂商包括IBM,Oracle, JBoss社区 (JBoss Community), Apache 社区(ApacheCommunity)。</p>
<h3>3.      JMS应用程序, 一个完整的JMS应用应该实现以下功能：</h3>
<ul>
<li><p>JMS 客户端 – Java语言开发的接受与发送消息的程序</p>
</li>
<li><p>非JMS客户端 – 基于消息系统的本地API实现而不是JMS</p>
</li>
<li><p>消息 – 应用程序用来相互交流信息的载体</p>
</li>
<li><p>被管理对象–预先配置的JMS对象，JMS管理员创建，被客户端运用。如链接工厂，主题等</p>
</li>
<li><p>JMS提供者–完成JMS功能与管理功能的消息系统</p>
</li>
</ul>
<h2>二: JMS 规范</h2>
<h3>连接工厂</h3>
<p>连接工厂是GUST用来创建连接的对象，例如ActiveMQ提供的ActiveMQConnectionFactory。</p>
<h3>连接</h3>
<p>JMS Connection封装了客户与JMS提供者之间的一个虚拟的连接。</p>
<h3>会话</h3>
<p>MS Session是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。</p>
<h3>目的地</h3>
<p>目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2 规范中定义了两种消息传递域</p>
<h4>点对点的消息模式(Point to Point Messaging)</h4>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7umekfemwj20is06o0tb.jpg" height="300" title=" 200 点对点">


<hr>
<p>下面的JMS对象在点对点消息模式中是必须的：</p>
<ul>
<li><p>队列(Queue) – 一个提供者命名的队列对象，客户端将会使用这个命名的队列对象</p>
</li>
<li><p>队列链接工厂(QueueConnectionFactory) – 客户端使用队列链接工厂创建链接队列ConnectionQueue来取得与JMS点对点消息提供者的链接。</p>
</li>
<li><p>链接队列(ConnectionQueue) – 一个活动的链接队列存在在客户端与点对点消息提供者之间，客户用它创建一个或者多个JMS队列会话(QueueSession)</p>
</li>
<li><p>队列会话(QueueSession) – 用来创建队列消息的发送者与接受者(QueueSenderandQueueReceiver)</p>
</li>
<li><p>消息发送者(QueueSender 或者MessageProducer)– 发送消息到已经声明的队列</p>
</li>
<li><p>消息接受者(QueueReceiver或者MessageConsumer) – 接受已经被发送到指定队列的消息</p>
</li>
</ul>
<p><strong>注意如下：</strong></p>
<ul>
<li>每个消息只能有一个消费者。</li>
<li>消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。</li>
</ul>
<h4>发布订阅模式(publish – subscribe Mode)</h4>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7umpp9onwj20is0ayjsk.jpg" class="center" height="200" title=" 300 发布者">

<hr>
<ul>
<li><p>主题Topic(Destination) – 一个提供者命名的主题对象，客户端将会使用这个命名的主题对象</p>
</li>
<li><p>主题链接工厂(TopciConnectionFactory) – 客户端使用主题链接工厂创建链接主题 ConnectionTopic来取得与JMS消息Pub/Sub提供者的链接</p>
</li>
<li><p>链接主题(ConnectionTopic) – 一个活动的链接主题存在发布者与订阅者之间</p>
</li>
<li><p>会话(TopicSession) – 用来创建主题消息的发布者与订阅者 (TopicPublisher  and TopicSubscribers)</p>
</li>
<li><p>消息发送者MessageProducer) – 发送消息到已经声明的主题</p>
</li>
<li><p>消息接受者(MessageConsumer) – 接受已经被发送到指定主题的消息</p>
</li>
</ul>
<p><strong>注意如下：</strong></p>
<ul>
<li>每个消息可以有多个消费者。</li>
<li>生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。</li>
</ul>
<hr>
<blockquote>
<p>本系列博文参考自whitesock  淮少吧 贾志刚</p>
</blockquote>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/MQ/" term="MQ"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios 笔记之 内购]]></title>
    <link href="http://hufeng825.github.com/2013/08/21/appstore/"/>
    <id>http://hufeng825.github.com/2013/08/21/appstore/</id>
    <published>2013-08-21T01:18:13.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>昨晚同事拿了一个app 发现其app 内部页面打开了appstore  并没有唤起手机自带的appstore， 刚开始以为是用webview 加载的<br><a id="more"></a> ，可是自己些了一个demo 发现并不是那样一回事 用webview 加载appstore 地址 会被js 自动吊起本地的appstore，<br>下面是我的发给同事的邮件 直接贴下来</p>
</blockquote>
<p>我们都绕了弯路 一直以为是用webview 加载的。 我下班做了测试 发现用webview 加载appstore的地址 ，ios 会根据User-Agent 自动判断 唤起本地的app store，其效果跟用[[UIApplicationsharedApplication] openURL:[NSURL URLWithString:@“”]];是一样的。</p>
<p>后来我尝试改写User-Agent  发现打开的页面是���脑打开的页面一样的 并不是我们通过手机 打开app store 看到的页面。</p>
<p>后来我看苹果的文档 发现 他们提供了一个类SKStoreProductViewController专门来干这个事情的</p>
<p><a href="https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html" target="_blank"><a href="https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html">https://developer.apple.com/library/ios/documentation/StoreKit/Reference/SKITunesProductViewController_Ref/Introduction/Introduction.html</a></a></p>
<p>实现效果如下图</p>
<img src="http://ww4.sinaimg.cn/mw690/a43af4ffjw1e7u10xs9nwj20m015c0x9.jpg" class="center" width="250" height="600">


<h2>下面是关键代码</h2>
<figure class="highlight"><pre>需要引入的
<span class="preprocessor">#import &lt;StoreKit/StoreKit.h&gt;</span>
<span class="class"><span class="keyword">delegate</span> 为<span class="title">SKStoreProductViewControllerDelegate</span>


调用方式
    [<span class="title">self</span> <span class="title">openAppWithIdentifier</span>:@"592043421"];



#<span class="title">pragma</span> <span class="title">mark</span> - <span class="title">SKStoreProductViewControllerDelegate</span>
- (<span class="title">void</span>)<span class="title">productViewControllerDidFinish</span>:(<span class="title">SKStoreProductViewController</span> *)<span class="title">viewController</span> {</span>
    [viewController dismissViewControllerAnimated:YES completion:^{
    }];
}






- (<span class="keyword">void</span>)openAppWithIdentifier:(NSString *)appId {
    SKStoreProductViewController *storeProductVC = [[SKStoreProductViewController alloc] init];
    storeProductVC.<span class="class"><span class="keyword">delegate</span> = <span class="title">self</span>;
    
    <span class="title">NSDictionary</span> *<span class="title">dict</span> = [<span class="title">NSDictionary</span> <span class="title">dictionaryWithObject</span>:<span class="title">appId</span> <span class="title">forKey</span>:<span class="title">SKStoreProductParameterITunesItemIdentifier</span>];
    [<span class="title">storeProductVC</span> <span class="title">loadProductWithParameters</span>:<span class="title">dict</span> <span class="title">completionBlock</span>:^(<span class="title">BOOL</span> <span class="title">result</span>, <span class="title">NSError</span> *<span class="title">error</span>) {</span>
        if (result) {
            [self presentViewController:storeProductVC animated:YES completion:nil];
        }
    }];
}
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[MQ 笔记之 mac 下安装环境]]></title>
    <link href="http://hufeng825.github.com/2013/08/20/mq1/"/>
    <id>http://hufeng825.github.com/2013/08/20/mq1/</id>
    <published>2013-08-20T09:47:34.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<h2>下载</h2>
<p><a href="http://www.apache.org/dyn/closer.cgi?path=/activemq/apache-activemq/5.8.0/apache-activemq-5.8.0-bin.tar.gz" target="_blank">从下载地址中下载包</a><br>解压包然后把包放到一个自己不会手一抖就删掉的位置，此处我放到了本地的document下<br>如下图<br><a id="more"></a></p>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7uav8h7lbj20o80gkjtw.jpg" class="left" width="200" height="300" title="图片">

<h2>添加环境到path</h2>
<p>把/你的保存路径/apache-activemq-5.8.0/bin/activemq 添加到 PATH 中 </p>
<ol>
<li>cd </li>
<li>执行 vi .profile </li>
<li>输入 i </li>
<li>插入 export MQ=/你的路径/apache-activemq-5.8.0/bin/macosx/activemq</li>
<li>wq</li>
<li>source .profile</li>
</ol>
<h2>启动mq</h2>
<p>$Mq start<br>输入账号 admin 密码  admin</p>
<p><strong>注意</strong> 如果用代理上网 请把网络环境设置下 如下图</p>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubcv9nx0j20oa08egmc.jpg" width="200" height="300" title="网络配置">


<h2>查看启动效果</h2>
<img src="http://ww1.sinaimg.cn/mw690/a43af4ffjw1e7ubfs7cg1j21ga0oe0yw.jpg" width="200" height="300" title="启动效果">


<h2>基本配置</h2>
<p>conf/jetty.xml</p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"securityConstraint"</span>&gt;</span>
 
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"BASIC"</span> /&gt;</span>
 
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"roles"</span> <span class="attribute">value</span>=<span class="value">"admin"</span> /&gt;</span>
 
        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticate"</span> <span class="attribute">value</span>=<span class="value">"false"</span> /&gt;</span>
 
<span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
</pre></figure>

<p>此处可以配置登陆用户权限</p>
<figure class="highlight"><pre> <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connectors"</span>&gt;</span>
            <span class="tag">&lt;<span class="title">list</span>&gt;</span>
                <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"Connector"</span> <span class="attribute">class</span>=<span class="value">"org.eclipse.jetty.server.nio.SelectChannelConnector"</span>&gt;</span>
                    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"port"</span> <span class="attribute">value</span>=<span class="value">"8161"</span> /&gt;</span>
                <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>
            <span class="tag">&lt;/<span class="title">list</span>&gt;</span>
 <span class="tag">&lt;/<span class="title">property</span>&gt;</span>
</pre></figure>

<p>此处用来修改端口号</p>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/MQ/" term="MQ"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ios 开发笔记之图片 Image]]></title>
    <link href="http://hufeng825.github.com/2013/08/20/iosimage/"/>
    <id>http://hufeng825.github.com/2013/08/20/iosimage/</id>
    <published>2013-08-20T01:29:39.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<h2>关于图片资源</h2>
<p>ios 程序会把图片资源编译成二进制文件，程序运行时会把这些图片从磁盘加载直接到内存，如果图片很大，加载速度就会很慢。<br><a id="more"></a><br>为了优化提高性能，需要尽量压缩图片资源。（ps 苹果公司的UIKit 开发者Andy Matuschak指出：使用resizable image是最快的方法。）</p>
<h2>关于图片资源的压缩</h2>
<p>如果不需要用半透明的图片 则尽量不要用png 格式的图片。相应的可以用jpg格式的。另外谷歌最新推出的一种格式webp</p>
<h3>1 WebP是什么</h3>
<p>WebP是Google推出的一种同时提供了有损压缩与无损压缩的图片格式。目前互联网上传输的数据有65%都是图片，WebP就是出于减少数据量、加速网络传输的目的而开发的。WebP希望能够达到和JPEG同水平的图片质量，但是更小的文件，以减少图片的传送时间。<br>在有损压缩的状况下，WebP比同样画质的JPEG少了25% ～ 34%的文件大小 。而在无损压缩的情形中，比起用libpng产生的PNG图片，WebP少了34%的文件大小，也比用pngout再处理过的PNG图片少了26%的文件大小。</p>
<h3>2 WebP的使用</h3>
<p>webp图片压缩率会比jpeg、png更高，因此下载图片会更省流量，特别适合在mobile app上使用。 比如iOS app上，可以把webp编译生成framework，然后加入引用就可以是使用了。强烈推荐。<br>这iOS解析时，可以直接使用 WebPImage。<br>NSData <em>imageData = [NSData dataWithContentsOfURL:url];<br>UIImage </em>tmpImage = [[WebPImage alloc] loadWebPFromData:imageData];<br>SDWebImage最近也提供了对webp的支持，起先不支持自己写了一个分类，现在可以直接用他的UIImage+WebP</p>
<h2>关于加载方式</h2>
<p>  imageNamed每次都读图片到缓存中，只适合频繁使用的图片，<br>initWithContentsOfFile的方法加载图片后，不缓存，适合加载不常使用的图片。<br>引导图片一般情况下只会启动一次而且图片也一般情况下比较大所以用imageNamed 会非常， 如果用initWithContentsOfFile:，这些图片所占用内存可以很快被释放</p>
<blockquote>
<p>资料参考by wufawei stackoverflow</p>
</blockquote>
]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/ios/" term="ios"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Markdown]]></title>
    <link href="http://hufeng825.github.com/2013/08/14/markdown/"/>
    <id>http://hufeng825.github.com/2013/08/14/markdown/</id>
    <published>2013-08-14T08:13:21.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<p>本文简单介绍下 Markdown 语法<br><a id="more"></a></p>
<h3>什么是Markdown</h3>
<p>Markdown是一个将文本转化为HTML的工具。简单来说，Markdown是一个兼顾可读性与易用性的轻量级标记体系。Markdown并不追求大而全，它只关心HTML里最常用的几个标记，对于一些不常用的标记它允许直接将HTML标记插入文本。</p>
<hr>
<h2>表格</h2>
<table>
<thead>
<tr>
<th>标号</th>
<th>面向对象概念</th>
<th>面向关系概念 </th>
</tr>
</thead>
<tbody>
<tr>
<td><em>1</em></td>
<td><code>对象</code></td>
<td><strong>表的行（即记录）</strong></td>
</tr>
<tr>
<td>2</td>
<td>属性</td>
<td>表的列（即字段）</td>
</tr>
</tbody>
</table>
<p>代码如下</p>
<figure class="highlight"><pre><span class="comment">标号</span>  <span class="comment">|</span> <span class="comment">面向对象概念</span> <span class="comment">|</span> <span class="comment">面向关系概念</span> 
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">|</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
<span class="comment">*1*</span> <span class="comment">|</span> <span class="comment">`对象`</span> <span class="comment">|</span> <span class="comment">**表的行（即记录）**</span>
<span class="comment">2</span> <span class="comment">|</span> <span class="comment">属性</span> <span class="comment">|</span> <span class="comment">表的列（即字段）
</pre></figure>

<hr>
<h2>标题</h2>
<p>Markdown提供了两种方式（Setext和Atx）来显示标题。</p>
<p>代码如下</p>
<figure class="highlight"><pre><span class="comment">Setext方式</span>
<span class="comment">标题1</span>
<span class="comment">=================</span>

<span class="comment">标题2</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>

<span class="comment">Atx方式</span>
<span class="comment">#</span> <span class="comment">标题1</span>
<span class="comment">##</span> <span class="comment">标题2</span>
<span class="comment">######</span> <span class="comment">标题6
</pre></figure>

<hr>
<h2>换行</h2>
<p>在文字的末尾使用两个或两个以上的空格来表示换行。</p>
<p>代码如下</p>
<figure class="highlight"><pre><span class="blockquote">&gt; 这是一个引用，</span>
<span class="blockquote">&gt; 这里木有换行，   </span>
<span class="blockquote">&gt; 在这里换行了。</span>
<span class="blockquote">&gt; &gt; 内部嵌套</span>
</pre></figure>

<hr>
<h2>列表</h2>
<h3>无序列表使用*、+或-后面加上空格来表示。</h3>
<p>代码如下 </p>
<figure class="highlight"><pre><span class="bullet">* </span>Item 1
<span class="bullet">* </span>Item 2
<span class="bullet">* </span>Item 3

<span class="bullet">+ </span>Item 1
<span class="bullet">+ </span>Item 2
<span class="bullet">+ </span>Item 3

<span class="bullet">- </span>Item 1
<span class="bullet">- </span>Item 2
<span class="bullet">- </span>Item 3
</pre></figure>

<h3>有序列表使用数字加英文句号加空格表示。</h3>
<p>代码如下 </p>
<figure class="highlight"><pre><span class="bullet">1. </span>Item 1
<span class="bullet">2. </span>Item 2
<span class="bullet">3. </span>Item 3
</pre></figure>

<hr>
<h2>代码区域</h2>
<p>行内代码使用反斜杠`表示。<br>代码段落则是在每行文字前加4个空格或者1个缩进符表示。</p>
<hr>
<h2>强调</h2>
<p>Markdown使用*或_表示强调。</p>
<p>代码如下 </p>
<figure class="highlight"><pre>
单星号 = <span class="emphasis">*斜体*</span>
单下划线 = <span class="emphasis">_斜体_</span>
双星号 = <span class="strong">**加粗**</span>
双下划线 = <span class="strong">__加粗__</span>
</pre></figure>

<p>链接</p>
<p>Markdown支持两种风格的链接：Inline和Reference。</p>
<p>语法：</p>
<p>Inline：以中括号标记显示的链接文本，后面紧跟用小括号包围的链接。如果链接有title属性，则在链接中使用空格加“title属性”。<br>Reference：一般应用于多个不同位置使用相同链接。通常分为两个部分，调用部分为[链接文本][ref]；定义部分可以出现在文本中的其他位置，格式为[ref]: <a href="http://some/link/address" target="_blank">http://some/link/address</a> (可选的标题)。<br>注：ref中不区分大小写。</p>
<p>代码如下 </p>
<figure class="highlight"><pre>
这是一个Inline[示例](http:<span class="comment">//www.baidu.com "可选的title")。</span>
这是一个Reference[示例][<span class="keyword">ref</span>]。
[<span class="keyword">ref</span>]: http:<span class="comment">//www.baidu.com</span>
</pre></figure>

<hr>
<h2>图片</h2>
<p>图片的使用方法基本上和链接类似，只是在中括号前加叹号。<br>注：Markdown不能设置图片大小，如果必须设置则应使用HTML标记<img>。</p>
<p>代码如下 </p>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">notextile</span>&gt;</span>0<span class="tag">&lt;/<span class="title">notextile</span>&gt;</span>

Inline示例：![替代文本](http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg "可选的title")
Reference示例：![替代文本][pic]
[pic]: http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg "可选的title"
HTML示例：<span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg"</span> <span class="attribute">alt</span>=<span class="value">"替代文本"</span> <span class="attribute">title</span>=<span class="value">"标题文本"</span> <span class="attribute">width</span>=<span class="value">"200"</span> /&gt;</span>
</pre></figure>

<p>效果</p>
<img src="http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg" class="right" width="300" height="400" title="可选的title">

<p>Inline示例：<img src="http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg" alt="替代文本" title="可选的title"><br>Reference示例：![替代文本][<a href="http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg" target="_blank">http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg</a>]</p>
<p>HTML示例：<img src="http://ww4.sinaimg.cn/large/a43af4ffjw1e3nomotys9j.jpg" alt="替代文本" title="标题文本" width="200" /></p>
<hr>
<h2>自动链接</h2>
<p>使用尖括号，可以为输入的URL或者邮箱自动创建链接。如test@test.com。</p>
<h2>分隔线</h2>
<p>在一行中使用三个或三个以上的*、-或_可以添加分隔线，其中可以有空白，但是不能有其他字符。</p>
<h2>转义字符</h2>
<p>Markdown中的转义字符为\，可以转义的有：</p>
<figure class="highlight"><pre><span class="command">\\</span> 反斜杠
<span class="command">\`</span> 反引号
<span class="command">\*</span> 星号
<span class="command">\_</span> 下划线
<span class="command">\{</span><span class="command">\}</span> 大括号
<span class="command">\[</span><span class="command">\]</span> 中括号
<span class="command">\(</span><span class="command">\)</span> 小括号
<span class="command">\#</span> 井号
<span class="command">\+</span> 加号
<span class="command">\-</span> 减号
<span class="command">\.</span> 英文句号
<span class="command">\!</span> 感叹号
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hexo/" term="hexo"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[hibernate 笔记之 基础概念和配置]]></title>
    <link href="http://hufeng825.github.com/2013/08/14/hibernate0/"/>
    <id>http://hufeng825.github.com/2013/08/14/hibernate0/</id>
    <published>2013-08-14T07:56:58.000Z</published>
    <updated>2013-08-31T01:38:02.000Z</updated>
    <content type="html"><![CDATA[<h2>ORM 概念</h2>
<blockquote>
<p>ORM 解决主要的问题是对象— 关系映射， 域模型是面向对象的，而关系模型数据是面向关系的，一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录。</p>
</blockquote>
<a id="more"></a>

<h3>对象的持久化</h3>
<p>• 狭义的理解,“持久化”仅仅指把对象永久保存到数据库中</p>
<p>• 广义的理解,“持久化”包括和数据库相关的各种操作:</p>
<ul>
<li><p>保存:把对象永久保存到数据库中。</p>
</li>
<li><p>更新:更新数据库中对象(记录)的状态。</p>
</li>
<li><p>删除:从数据库中删除一个对象。</p>
</li>
<li><p>查询:根据特定的查询条件,把符合查询条件的一个或多个对象从数据 库加载到内存中。</p>
</li>
<li><p>加载:根据特定的OID,把一个对象从数据库加载到内 </p>
<blockquote>
<p>‘ OID —-&gt;为了在系统中能够找到所需对象,需要为每一个对象分配一个唯一的标识号。 在关系数据库中称之为主键,而在对象术语中,则叫做对象标识(Object identifier-OID). ’</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>标号</th>
<th>面向对象概念</th>
<th>面向关系概念 </th>
</tr>
</thead>
<tbody>
<tr>
<td><em>1</em></td>
<td><code>对象</code></td>
<td><strong>表的行（即记录）</strong></td>
</tr>
<tr>
<td>2</td>
<td>属性</td>
<td>表的列（即字段）</td>
</tr>
</tbody>
</table>
<h2>注意事项</h2>
<ol>
<li>有一个无参的构造器  反射时需要</li>
<li>类不能声明为final  如果声明就不能实现延迟加载了</li>
</ol>
<h2>hibernate 配置文件</h2>
<blockquote>
<p>hibernate.cfg.xml</p>
</blockquote>
<figure class="highlight"><pre><span class="tag">&lt;<span class="title">hibernate-configuration</span>&gt;</span>
	<span class="tag">&lt;<span class="title">session-factory</span>&gt;</span>
		<span class="comment">&lt;!-- 数据连接相关的配置 --&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="title">property</span>&gt;</span>			
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.connection.password"</span>&gt;</span>1234<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
			
		<span class="comment">&lt;!-- 执行操作时显示SQL语句 --&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span>

		<span class="comment">&lt;!-- 格式化输出的SQL语句 --&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		
		<span class="comment">&lt;!-- 配置数据库方言 --&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="title">property</span>&gt;</span>	
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
			
		<span class="comment">&lt;!-- 配置映射文件 --&gt;</span>			
		<span class="tag">&lt;<span class="title">mapping</span> <span class="attribute">resource</span>=<span class="value">"com/vince/entity/User.hbm.xml"</span>/&gt;</span>	
		<span class="tag">&lt;/<span class="title">session-factory</span>&gt;</span>	
<span class="tag">&lt;/<span class="title">hibernate-configuration</span>&gt;</span>
</pre></figure>

<p>hbm2ddl.auto:该属性可帮助程序员实现正向工程, 即由 java 代码生成数据库脚本, 进而生成具体的表结构. 。取值 create | update | create-drop | validate</p>
<p>– create : 会根据 .hbm.xml 文件来生成数据表, 但是每次运行都会删 除上一次的表 ,重新生成表, 哪怕二次没有任何改变</p>
<p>– create-drop:会根据.hbm.xml文件生成表,但是SessionFactory一关 闭, 表就自动删除</p>
<p>– update:最常用的属性值,也会根据.hbm.xml文件生成表,但 若 .hbm.xml 文件和数据库中对应的数据表的表结构不同, Hiberante 将更新数据表结构,但不会删除已有的行和列</p>
<p>– validate : 会和数据库中的表进行比较, 若 .hbm.xml 文件中的列在数 据表中不存在,则抛出异常</p>
<ul>
<li>format_sql:是否将 SQL 转化为格式良好的 SQL . 取值 true | false</li>
</ul>
<hr>
<h2>hibernate 映射文件</h2>
<blockquote>
<p>User.hbm.xml</p>
</blockquote>
<figure class="highlight"><pre><span class="pi">&lt;?xml version="1.0"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE hibernate-mapping PUBLIC
	"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span>

<span class="tag">&lt;<span class="title">hibernate-mapping</span> <span class="attribute">package</span>=<span class="value">"com.vince.entity"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"User"</span> <span class="attribute">table</span>=<span class="value">"USER_TABLE"</span> <span class="attribute">dynamic-update</span>=<span class="value">"true"</span> <span class="attribute">dynamic-insert</span>=<span class="value">"true"</span>&gt;</span>
		<span class="comment">&lt;!-- 配置主键 --&gt;</span>
		<span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"id"</span> <span class="attribute">column</span>=<span class="value">"ID"</span>&gt;</span>
			<span class="comment">&lt;!-- native表示使用本地数据库生成主键的方式 --&gt;</span>
			<span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"native"</span>&gt;</span><span class="tag">&lt;/<span class="title">generator</span>&gt;</span>
		<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
		<span class="comment">&lt;!-- 其它属性的配置 --&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">column</span>=<span class="value">"NAME"</span> <span class="attribute">not-null</span>=<span class="value">"true"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">column</span>=<span class="value">"AGE"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"createDate"</span> <span class="attribute">column</span>=<span class="value">"CREATE_DATE"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">class</span>&gt;</span>

<span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>


-------

<span class="tag">&lt;<span class="title">hibernate-mapping</span> <span class="attribute">package</span>=<span class="value">"com.vince.entity"</span>&gt;</span>
	<span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Emp"</span> <span class="attribute">table</span>=<span class="value">"EMP"</span> <span class="attribute">dynamic-insert</span>=<span class="value">"true"</span>
		<span class="attribute">dynamic-update</span>=<span class="value">"true"</span>&gt;</span>
		<span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"id"</span> <span class="attribute">type</span>=<span class="value">"int"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"ID"</span> /&gt;</span>
			<span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"native"</span> /&gt;</span>
		<span class="tag">&lt;/<span class="title">id</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">type</span>=<span class="value">"java.lang.String"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"NAME"</span> /&gt;</span>
		<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"salary"</span> <span class="attribute">type</span>=<span class="value">"float"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"SALARY"</span> /&gt;</span>
		<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">type</span>=<span class="value">"int"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">column</span> <span class="attribute">name</span>=<span class="value">"AGE"</span> /&gt;</span>
		<span class="tag">&lt;/<span class="title">property</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">class</span>&gt;</span>
<span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span>
</pre></figure>

<h3>主键生成策略</h3>
<img src="http://ww2.sinaimg.cn/mw690/a43af4ffjw1e7n5a834npj20x00lajw6.jpg
" class="center" title="hiberate 主键生成策略">


<hr>
<h2>SessionFactory 接口</h2>
<p>• 针对单个数据库映射关系经过编译后的内存镜像,是线程安 全的。</p>
<p>• Configuration 对象根据当前的配置信息生成 SessionFactory 对象。SessionFactory 对象一旦构造完毕,即被赋予特定的 配置信息</p>
<ul>
<li><p>Configuration cfg = new Configuration().configure();</p>
</li>
<li><p>SessionFactory sf = cfg.buildSessionFactory();</p>
</li>
</ul>
<p>• SessionFactory是生成Session的工厂:</p>
<ul>
<li>Session session = sf.openSession();</li>
</ul>
<p>• 构造 SessionFactory 很消耗资源</p>
<h2>hibernate.hbm2ddl.auto</h2>
<ol>
<li>create-drop   每次启动重新创建 结束后删除</li>
<li>create 每次启动都重新创建</li>
<li>update 不一样就更新</li>
<li>validate 仅仅验证</li>
</ol>
<h2>如何使用</h2>
<h3>使用范例</h3>
<figure class="highlight"><pre><span class="package"><span class="keyword">package</span> <span class="title">hufeng</span>.<span class="title">test</span> ;

<span class="title">import</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">Session</span> ;
<span class="title">import</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">SessionFactory</span> ;
<span class="title">import</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">cfg</span>.<span class="title">Configuration</span> ;

<span class="title">public</span> <span class="title">class</span>  <span class="title">Test</span>{</span>
	publick <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args){
	<span class="comment">// 加载hibernate 配置文件 （默认加载classpath 下的hibernate.cfg.xml）</span>
	Configuration cfg = <span class="keyword">new</span> Configuration().config();
	
	<span class="comment">// 通过Configulation 对象创建SessionFactory 工厂</span>
	SessionFactory factory = cfg.buildSessionFactory();
 	
 	<span class="comment">//Session操作数据库的一次会话</span>
 	<span class="comment">//线程不安全</span>
 	Session session = factory.openSession();


 	<span class="comment">//开启事务 --&gt; 把很多操作组合成一个整体 让事物具有原子性</span>
 	Transaction tx =  session.beginTransation();


 	CustomUser user = <span class="keyword">new</span> CustomUser(<span class="string">"jason"</span>,<span class="number">20</span>,<span class="keyword">new</span> Date());

 	<span class="comment">//保存数据</span>
 	session.save(user);

 	<span class="comment">//提交事物</span>
 	tx.commit();

 	<span class="comment">//关闭</span>
 	session.close();
 	factory.close();
 }
}
</pre></figure>

<h3>创建Hibernate 工具类</h3>
<figure class="highlight"><pre><span class="keyword">public</span> final <span class="class"><span class="keyword">class</span> <span class="id">HibernateUtil</span>{</span>
	<span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory;
	<span class="keyword">private</span> HibernateUtil(){}

	<span class="keyword">static</span> {
		Configuration cfg  = new Configuration()<span class="variable">.configure</span>();
		sessionFactory = cfg<span class="variable">.buildSessionFactory</span>();
	}

	 <span class="keyword">public</span> <span class="keyword">static</span> SessionFactory  getSesstionFactory()
	 {
	 	<span class="keyword">return</span> sessionFactory;
	 }

	 <span class="keyword">public</span> <span class="keyword">static</span> Session getSession()
	 {
	 	<span class="keyword">return</span> sessionFactory<span class="variable">.openSession</span>();
	 }

	 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> save(Object obj)
	 {
	 	Session session = getSession();
	 	Transaction tx = session<span class="variable">.benginTransaction</span>();
	 	session<span class="variable">.save</span>(obj);
	 	session<span class="variable">.evict</span>(obj);<span class="comment">//把对象清理出esssion 避免批处理时session中的缓存过多 导致内存溢出</span>
	 	<span class="comment">//session.clear()；清楚session中所有的对象</span>
	 	tx<span class="variable">.commit</span>();
	 	session<span class="variable">.close</span>();
	 }
}
</pre></figure>

<h3>应用工具类后的代码</h3>
<figure class="highlight"><pre><span class="package"><span class="keyword">package</span> <span class="title">hufeng</span>.<span class="title">test</span> ;

<span class="title">import</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">Session</span> ;
<span class="title">import</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">SessionFactory</span> ;
<span class="title">import</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">cfg</span>.<span class="title">Configuration</span> ;
<span class="title">import</span> <span class="title">org</span>.<span class="title">util</span>.<span class="title">HibernateUtil</span>;

<span class="title">public</span> <span class="title">class</span> <span class="title">Test</span> {</span>
	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> save()
	{
		User user =<span class="keyword">new</span> User(<span class="string">"jack"</span>,<span class="number">22</span>,<span class="keyword">new</span> Date()));
		HibernateUtil.save(user);
	}
}

publick <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)
{
	save();
}
</pre></figure>

<h3>更加规范应用HQL的代码</h3>
<figure class="highlight"><pre>public final class HibernateUtil {

	private static SessionFactory sessionFactory<span class="comment">;</span>

	private HibernateUtil() {
	}

	static {
		Configuration cfg = new Configuration()<span class="preprocessor">.configure</span>()<span class="comment">;</span>
		sessionFactory = cfg<span class="preprocessor">.buildSessionFactory</span>()<span class="comment">;</span>
	}

	public static SessionFactory getSessionFactory() {
		return sessionFactory<span class="comment">;</span>
	}

	public static Session getSession() {
		return sessionFactory<span class="preprocessor">.openSession</span>()<span class="comment">;</span>
	}

	public static void save(Object obj) {
		Session session = null<span class="comment">;</span>
		try {
			session = getSession()<span class="comment">;</span>
			Transaction tx = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
			session<span class="preprocessor">.save</span>(obj)<span class="comment">;</span>
			tx<span class="preprocessor">.commit</span>()<span class="comment">;</span>
		} catch (HibernateException e) {
			e<span class="preprocessor">.printStackTrace</span>()<span class="comment">;</span>
		} finally {
			session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		}
	}
	public static void update(Object obj) {
		Session session = null<span class="comment">;</span>
		try {
			session = getSession()<span class="comment">;</span>
			Transaction tx = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
			session<span class="preprocessor">.update</span>(obj)<span class="comment">;</span>
			tx<span class="preprocessor">.commit</span>()<span class="comment">;</span>
		} catch (HibernateException e) {
			e<span class="preprocessor">.printStackTrace</span>()<span class="comment">;</span>
		} finally {
			session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		}
	}
	
	public static void delete(Object obj) {
		Session session = null<span class="comment">;</span>
		try {
			session = getSession()<span class="comment">;</span>
			Transaction tx = session<span class="preprocessor">.beginTransaction</span>()<span class="comment">;</span>
			session<span class="preprocessor">.delete</span>(obj)<span class="comment">;</span>
			tx<span class="preprocessor">.commit</span>()<span class="comment">;</span>
		} catch (HibernateException e) {
			e<span class="preprocessor">.printStackTrace</span>()<span class="comment">;</span>
		} finally {
			session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		}
	}
	
	public static Object get(Class clazz,Serializable id) {
		Session session = null<span class="comment">;</span>
		try {
			session = getSession()<span class="comment">;</span>
			return session<span class="preprocessor">.get</span>(clazz, id)<span class="comment">;</span>
		} catch (HibernateException e) {
			e<span class="preprocessor">.printStackTrace</span>()<span class="comment">;</span>
		} finally {
			session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		}
		return null<span class="comment">;</span>
	}

}

--------
@Override
	public List&lt;Emp&gt; list() throws Exception {
		Session session  = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		//hql针对对象查询语句
		String hql = <span class="string">"from Emp"</span><span class="comment">;//</span>
		//创建查询(hql)
		Query query = session<span class="preprocessor">.createQuery</span>(hql)<span class="comment">;</span>
		List&lt;Emp&gt; list = query<span class="preprocessor">.list</span>()<span class="comment">;</span>
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		return list<span class="comment">;</span>
	}

	@Override
	public void <span class="keyword">add</span>(Emp emp) throws Exception {
		HibernateUtil<span class="preprocessor">.save</span>(emp)<span class="comment">;</span>
		
	}

	@Override
	public List&lt;Emp&gt; listByName(String name) throws Exception {
		Session session  = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		String hql = <span class="string">"from Emp e where e.name=?"</span><span class="comment">;</span>
		Query query = session<span class="preprocessor">.createQuery</span>(hql)<span class="comment">;</span>
		//sql ？起始位置从<span class="number">1</span>开始
		//hql ？起始位置从<span class="number">0</span>开始
		query<span class="preprocessor">.setString</span>(<span class="number">0</span>, name)<span class="comment">;</span>
		
		List&lt;Emp&gt; list = query<span class="preprocessor">.list</span>()<span class="comment">;</span>
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		return list<span class="comment">;</span>
	}

	@Override
	public List&lt;Emp&gt; listByAge(int age) throws Exception {
		
		
		return null<span class="comment">;</span>
	}

	//使用别名代替?方式，可以不用考虑设置参数的顺序
	@Override
	public List&lt;Emp&gt; listByNameAge(String name, int age) throws Exception {
		Session session = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		String hql = <span class="string">"from Emp e where e.age=:age and e.name=:name"</span><span class="comment">;</span>
		Query query = session<span class="preprocessor">.createQuery</span>(hql)<span class="comment">;</span>
//		query<span class="preprocessor">.setString</span>(<span class="number">0</span>, name)<span class="comment">;</span>
//		query<span class="preprocessor">.setInteger</span>(<span class="number">1</span>, age)<span class="comment">;</span>
		query<span class="preprocessor">.setString</span>(<span class="string">"name"</span>, name)<span class="comment">;</span>
		query<span class="preprocessor">.setInteger</span>(<span class="string">"age"</span>, age)<span class="comment">;</span>
		
		//对分页的支持
		query<span class="preprocessor">.setFirstResult</span>(<span class="number">0</span>)<span class="comment">;//设置查询的起始位置</span>
		query<span class="preprocessor">.setMaxResults</span>(<span class="number">1</span>)<span class="comment">;//设置每页的记录数</span>
		
		
		List&lt;Emp&gt; emps = query<span class="preprocessor">.list</span>()<span class="comment">;</span>
		
		
		
		//iterate查询会执行 N+<span class="number">1</span>条语句
//		Iterator&lt;Emp&gt; emps = query<span class="preprocessor">.iterate</span>()<span class="comment">;</span>
		
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		return emps<span class="comment">;</span>
	}

	@Override
	public List&lt;Emp&gt; listLikeName(String name) {
		Session session = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		String hql = <span class="string">"from Emp e where e.name like :name"</span><span class="comment">;</span>
		Query query = session<span class="preprocessor">.createQuery</span>(hql)<span class="comment">;</span>
		query<span class="preprocessor">.setString</span>(<span class="string">"name"</span>, <span class="string">"%"</span>+name+<span class="string">"%"</span>)<span class="comment">;</span>
		List&lt;Emp&gt; list = query<span class="preprocessor">.list</span>()<span class="comment">;</span>
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		return list<span class="comment">;</span>
	}

	@Override
	public Emp getByName(String name) {
		String hql = <span class="string">"from Emp e where e.name=:name"</span><span class="comment">;</span>
		Session session = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		Query query = session<span class="preprocessor">.createQuery</span>(hql)<span class="comment">;</span>
		query<span class="preprocessor">.setString</span>(<span class="string">"name"</span>, name)<span class="comment">;</span>
		//返回唯一的结果
		Emp emp = (Emp)query<span class="preprocessor">.uniqueResult</span>()<span class="comment">;</span>
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		return emp<span class="comment">;</span>
	}

	//QBC检索方式(了解)
	@Override
	public Emp getById(int id) {
		
		Session session = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		Criteria criteria = session<span class="preprocessor">.createCriteria</span>(Emp<span class="preprocessor">.class</span>)<span class="comment">;</span>
		//添加查询条件
		criteria<span class="preprocessor">.add</span>(Restrictions<span class="preprocessor">.eq</span>(<span class="string">"id"</span>, id))<span class="comment">;</span>
		Emp emp = (Emp)criteria<span class="preprocessor">.uniqueResult</span>()<span class="comment">;</span>
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		return emp<span class="comment">;</span>
	}

	@Override
	public long countEmp() {
		String hql = <span class="string">"select count(id) as id from Emp"</span><span class="comment">;</span>
		Session session = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		Query query = session<span class="preprocessor">.createQuery</span>(hql)<span class="comment">;</span>
		long count = (long)query<span class="preprocessor">.uniqueResult</span>()<span class="comment">;</span>
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
		return count<span class="comment">;</span>
	}
	public void countEmp2() {
		String hql = <span class="string">"select count(id),avg(age) as id from Emp"</span><span class="comment">;</span>
		Session session = HibernateUtil<span class="preprocessor">.getSession</span>()<span class="comment">;</span>
		Query query = session<span class="preprocessor">.createQuery</span>(hql)<span class="comment">;</span>
		List list = query<span class="preprocessor">.list</span>()<span class="comment">;</span>
		Object[] objs = (Object[])list<span class="preprocessor">.get</span>(<span class="number">0</span>)<span class="comment">;</span>
		int count = (int)objs[<span class="number">0</span>]<span class="comment">;</span>
		int avg = (int)objs[<span class="number">1</span>]<span class="comment">;</span>
		session<span class="preprocessor">.close</span>()<span class="comment">;</span>
	}
</pre></figure>

]]></content>
    <category scheme="http://hufeng825.github.com/tags/技术/" term="技术"/>
    <category scheme="http://hufeng825.github.com/categories/hibernate/" term="hibernate"/>
  </entry>
</feed>
